<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[點燈坊]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="https://oomusou.io/"/>
  <updated>2018-08-16T03:42:28.311Z</updated>
  <id>https://oomusou.io/</id>
  
  <author>
    <name><![CDATA[真 OO無双]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Vue CLI 之 Hello World (Windows)]]></title>
    <link href="https://oomusou.io/vue/vuecli/hello-world-win/"/>
    <id>https://oomusou.io/vue/vuecli/hello-world-win/</id>
    <published>2018-08-15T14:23:43.000Z</published>
    <updated>2018-08-16T03:42:28.311Z</updated>
    <content type="html"><![CDATA[<p>現代前端的 Tooling 繁雜， 一直是跨入前端的門檻，讓 CLI 成為 Tooling 的抽象層，由 CLI 幫我們解決繁瑣的 Tooling 整合。</p>
<p>由於 Vue CLI 3 的發表，Vue 的 CLI 又向前邁進一大步，本文介紹如何使用 Vue CLI 3 快速建立 Vue 專案。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>Windows 10 Professional 1803 (17134.191)<br>Node.js 8.11.3<br>Yarn 1.9.4<br>Vue.js 2.5.17<br>Vue CLI 3.0.0</p>
<h2 id="Node-js">Node.js</h2><hr>
<p>現代前端都基於 Node.js 生態系，Vue 也不例外，首先必須安裝 Node.js。</p>
<p><img src="/images/vue/vuecli/hello-world-win/vuecli009.png" alt="vuecli009"></p>
<p>到 <a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js 官網</a>下載 8.11.3 LTS，只要下一步下一步安裝即可。</p>
<p><img src="/images/vue/vuecli/hello-world-win/vuecli010.png" alt="vuecli010"></p>
<p>安裝完後會多了 <code>Node.js command prompt</code>，將來所有 Vue 的 CLI，都要使用此 command prompt。</p>
<h2 id="Yarn">Yarn</h2><hr>
<p>Node.js 內建 NPM 套件管理工具，但 NPM 的演算法實在不優，速度很慢，Facebook 另外提出了 Yarn 管理前端套件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> yarn</span></span><br></pre></td></tr></table></figure>
<p>使用 NPM 以 <code>g</code> lobal 方式安裝 Yarn。</p>
<p><img src="/images/vue/vuecli/hello-world-win/vuecli011.png" alt="vuecli011"></p>
<p>將來安裝前端套件，將以 Yarn 取代 NPM。</p>
<h2 id="設定_Yarn_套件路徑">設定 Yarn 套件路徑</h2><hr>
<p>由於 Node.js 內建 NPM，因此 NPM 套件 path 已經整好，但 Yarn 由於是外加套件，所以 path 要另外設定。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn <span class="keyword">global</span> bin</span><br></pre></td></tr></table></figure>
<p>使用 <code>yarn global bin</code> 回傳 global 套件所在的 path。</p>
<p><img src="/images/vue/vuecli/hello-world-win/vuecli012.png" alt="vuecli012"></p>
<ol>
<li>輸入 <code>yarn global bin</code></li>
<li>顯示 global 套件的 path，每個人的 path 會不一樣</li>
</ol>
<blockquote>
<p>Yarn 的套件路徑設定只有 Windows 需要，在 macOS 不必</p>
</blockquote>
<p><img src="/images/vue/vuecli/hello-world-win/vuecli013.png" alt="vuecli013"></p>
<ol>
<li>將 path 設定到系統環境變數</li>
<li>重新啟動 <code>Node.js command prompt</code></li>
</ol>
<h2 id="Vue_CLI">Vue CLI</h2><hr>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn <span class="built_in">global</span> <span class="keyword">add</span> @vue/<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>
<p>使用 Yarn 以 <code>g</code> lobal 方式安裝 Vue CLI。</p>
<p><img src="/images/vue/vuecli/hello-world-win/vuecli002.png" alt="vuecli002"></p>
<h2 id="建立_Project">建立 Project</h2><hr>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>vue create hello-world</span><br></pre></td></tr></table></figure>
<p>使用 <code>vue create</code> 建立 Vue 專案。</p>
<p><img src="/images/vue/vuecli/hello-world-win/vuecli003.png" alt="vuecli003"></p>
<p><img src="/images/vue/vuecli/hello-world-win/vuecli004.png" alt="vuecli004"></p>
<ol>
<li>選擇 project 類型，先按 ↩ 選擇預設的 <code>babel + eslint</code> 即可</li>
</ol>
<p><img src="/images/vue/vuecli/hello-world-win/vuecli014.png" alt="vuecli014"></p>
<ol>
<li>選擇套件管理工具，選擇預設的 <code>Yarn</code></li>
</ol>
<p><img src="/images/vue/vuecli/hello-world-win/vuecli015.png" alt="vuecli015"></p>
<ol>
<li>成功建立專案</li>
</ol>
<h2 id="執行_Vue">執行 Vue</h2><hr>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd hello-world</span><br><span class="line">hello-world <span class="variable">$ </span>yarn serve</span><br></pre></td></tr></table></figure>
<p>使用 <code>yarn serve</code> 執行 Vue。</p>
<p><img src="/images/vue/vuecli/hello-world-win/vuecli006.png" alt="vuecli006"></p>
<ol>
<li>進入 <code>hello-world</code> 目錄</li>
<li>輸入 <code>yarn serve</code> 執行 Vue</li>
</ol>
<p><img src="/images/vue/vuecli/hello-world-win/vuecli007.png" alt="vuecli007"></p>
<ol>
<li>Vue 啟動在 <code>http://localhost:8080</code></li>
</ol>
<p><img src="/images/vue/vuecli/hello-world-win/vuecli008.png" alt="vuecli008"></p>
<p>Vue 順利執行在 <code>localhost:8080</code>。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>Vue CLI 3 讓我們類似 Angular CLI 快速建立專案，也將相關的設定 tooling 都準備好，大幅降低進入現代前端的門檻</li>
</ul>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://vuejs.org/" target="_blank" rel="external">Vue.js</a>, <a href="https://cli.vuejs.org/" target="_blank" rel="external">Vue CLI 3</a></p>
]]></content>
    <summary type="html">
    <![CDATA[使用 Vue CLI 3 快速建立 Project]]>
    
    </summary>
    
      <category term="Vue" scheme="https://oomusou.io/tags/Vue/"/>
    
      <category term="Vue CLI" scheme="https://oomusou.io/tags/Vue-CLI/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vue CLI 之 Instant Prototyping]]></title>
    <link href="https://oomusou.io/vue/vuecli/instant-prototyping/"/>
    <id>https://oomusou.io/vue/vuecli/instant-prototyping/</id>
    <published>2018-08-15T12:23:43.000Z</published>
    <updated>2018-08-16T03:42:19.425Z</updated>
    <content type="html"><![CDATA[<p>Vue CLI 3 提供了一個很酷的 Instant Prototyping，在學習 Vue 時非常有用，讓我們不用建立 Vue 專案，只要一個 <code>.vue</code> 檔就可開始練習與 demo。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>Node.js 8.11.3<br>Yarn 1.9.4<br>Vue 2.5.17<br>Vue CLI 3.0.0<br>WebStorm 2018.2.1</p>
<h2 id="安裝_CLI-Service_Global">安裝 CLI-Service Global</h2><hr>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn <span class="built_in">global</span> <span class="keyword">add</span> @vue/<span class="keyword">cli</span>-service-<span class="built_in">global</span></span><br></pre></td></tr></table></figure>
<p>Vue CLI 並沒有內建 CLI-Service Global，要另外安裝。</p>
<p><img src="/images/vue/vuecli/instant-prototyping/prototype000.png" alt="prototype000"></p>
<h2 id="建立_-vue">建立 .vue</h2><hr>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;template&#62;&#10;  &#60;h1&#62;Hello!&#60;/h1&#62;&#10;&#60;/template&#62;</span><br></pre></td></tr></table></figure>
<p>用任何工具建立 <code>.vue</code> 皆可，如存檔命名為 <code>hello.vue</code>。</p>
<p><img src="/images/vue/vuecli/instant-prototyping/prototype001.png" alt="prototype001"></p>
<ol>
<li>就算使用 Vim 建立 <code>.vue</code> 也行</li>
</ol>
<h2 id="執行_Vue">執行 Vue</h2><hr>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>vue serve hello.vue</span><br></pre></td></tr></table></figure>
<p><code>vue serve</code> 後面接 <code>檔案名稱</code>，就可執行 Vue。</p>
<p><img src="/images/vue/vuecli/instant-prototyping/prototype002.png" alt="prototype002"></p>
<p><img src="/images/vue/vuecli/instant-prototyping/prototype003.png" alt="prototype003"></p>
<p>Vue 啟動在 <code>http://localhost:8080/</code></p>
<p><img src="/images/vue/vuecli/instant-prototyping/prototype004.png" alt="prototype004"></p>
<p>Vue 順利執行在 <code>localhost:8080</code>。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>Vue CLI 3 的 Instant Prototyping 讓我們在學習測試 Vue 時更方便，不用再使用 Yarn 建立新專案，只要一個 <code>.vue</code> 檔即可</li>
</ul>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://cli.vuejs.org/" target="_blank" rel="external">Vue CLI</a>, <a href="https://cli.vuejs.org/guide/prototyping.html" target="_blank" rel="external">Instant Prototyping</a></p>
]]></content>
    <summary type="html">
    <![CDATA[不用建立 Vue 專案就可 demo]]>
    
    </summary>
    
      <category term="Vue" scheme="https://oomusou.io/tags/Vue/"/>
    
      <category term="Vue CLI" scheme="https://oomusou.io/tags/Vue-CLI/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 VS Code 開發 Vue ?]]></title>
    <link href="https://oomusou.io/vscode/vue/"/>
    <id>https://oomusou.io/vscode/vue/</id>
    <published>2018-08-14T13:23:43.000Z</published>
    <updated>2018-08-15T08:45:02.507Z</updated>
    <content type="html"><![CDATA[<p>VS Code 可以說是目前最受歡迎的前端開發環境，只要安裝合適的套件，就能在 VS Code 開發 Vue，適合前後端分離時的純前端開發。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>VS Code 1.25.1<br>Prettier 1.6.1<br>ESLint 1.4.12<br>Vetur 0.12.6<br>Vue 2.5.17</p>
<h2 id="Packages">Packages</h2><hr>
<ul>
<li>Prettier</li>
<li>ESLint</li>
<li>Vetur</li>
</ul>
<h2 id="Prettier">Prettier</h2><hr>
<p><img src="/images/vscode/vue/vscode001.png" alt="vscode001"></p>
<p>負責 Formatter 角色，當我們按下熱鍵 <code>⌥ + ⇧ + F</code> Format Document 時，VS Code 會啟動 Prettier 為我們重整 JavaScript / CSS 的格式。</p>
<h2 id="ESLint">ESLint</h2><hr>
<p><img src="/images/vscode/vue/vscode000.png" alt="vscode000"></p>
<p>負責 Linter 角色，Vue CLI 3 目前已經整合 ESLint，除了另外下 <code>yarn lint</code> 執行 ESLint 外，更可以在 VS Code 下即時警告。</p>
<h2 id="Vetur">Vetur</h2><hr>
<p><img src="/images/vscode/vue/vscode002.png" alt="vscode002"></p>
<p>負責 Vue 的 LSP (Language Service Protocol) 角色，是目前支援 Vue 最完整的 LSP。</p>
<h2 id="針對_-js_設定">針對 .js 設定</h2><hr>
<p>對於副檔名是 <code>.js</code>，VS Code 預設以 Prettier 進行 format，但 ESLint 加入後，JavaScript 又有了新的 format 出現，必須讓 Prettier 也支援 ESLint，熱鍵 <code>⌥ + ⇧ + F</code> Format Document 時，才會套用 ESLint 格式。</p>
<p><img src="/images/vscode/vue/vscode003.png" alt="vscode003"></p>
<h2 id="針對_-vue_設定">針對 .vue 設定</h2><hr>
<p><code>.vue</code> 一直是各大工具最頭疼的格式，因為 <code>.vue</code> 同時包含 HTML、CSS 與 JavaScript，到底要交給哪個工具負責 lint 與 format 呢 ?</p>
<h3 id="Formatter">Formatter</h3><p><img src="/images/vscode/vue/vscode004.png" alt="vscode004"></p>
<ul>
<li><code>.vue</code> 格式的 JavaScript 部分，由 <code>vscode-typescript</code> 處理</li>
<li><code>.vue</code> 格式的 HTML 部分，由 <code>js-beautify-html</code> 處理</li>
</ul>
<h3 id="Linter">Linter</h3><p><img src="/images/vscode/vue/vscode005.png" alt="vscode005"></p>
<ol>
<li>ESLint 預設並不支援 <code>.vue</code>，所以特別在 <code>eslint.validate</code> 加上 <code>vue</code></li>
<li>ESLint 內建 <code>autoFix</code>，可以幫我們自動修正錯誤</li>
</ol>
<h2 id="存檔同時_Format_與_Lint_Fix">存檔同時 Format 與 Lint Fix</h2><hr>
<p><img src="/images/vscode/vue/vscode006.png" alt="vscode006"></p>
<ol>
<li><code>editor.formatOnSave</code> 設定為 <code>true</code>，存檔時自動執行 Prettier</li>
<li><code>eslint.autoFixOnSave</code> 設定為 <code>true</code>，存檔時自動執行 ESLint fix</li>
</ol>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>針對於 <code>.vue</code> 格式，只要熱鍵  <code>⌘ + S</code> 存檔，同時執行 Prettier 與 ESLint fix，<code>.vue</code> 總算有理想解決方式</li>
</ul>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://twitter.com/octref" target="_blank" rel="external">Pine Wu</a>, <a href="https://vuejs.github.io/vetur/" target="_blank" rel="external">Vetur</a><br><a href="https://twitter.com/octref" target="_blank" rel="external">Pine Wu</a>, <a href="https://www.youtube.com/watch?v=05tNXJ-Kric" target="_blank" rel="external">var vetur = vscode + vue</a><br><a href="http://www.52cik.com/" target="_blank" rel="external">楼教主</a>, <a href="http://www.52cik.com/2018/02/20/vscode-vue.html" target="_blank" rel="external">在 vscode 中统一 vue 编码风格</a></p>
]]></content>
    <summary type="html">
    <![CDATA[VS Code 支援 Vue 尚稱完整]]>
    
    </summary>
    
      <category term="VS Code" scheme="https://oomusou.io/tags/VS-Code/"/>
    
      <category term="Vue" scheme="https://oomusou.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 Docker 打造 Vue 開發環境 ?]]></title>
    <link href="https://oomusou.io/docker/vue/"/>
    <id>https://oomusou.io/docker/vue/</id>
    <published>2018-08-14T12:23:43.000Z</published>
    <updated>2018-08-14T09:51:39.839Z</updated>
    <content type="html"><![CDATA[<p>現代前端基於 Node.js 技術，且 Node.js 版本變化快速，還要安裝不少 package，若你不想讓 Node.js 版本與 package 污染整個系統環境，則 Docker 是個很好的解決方式，讓 Node.js 與相關 package 全部封在 Container 內。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>Docker for Mac 18.06.0-ce-mac70 (26399)<br>Node.js 8.11.3<br>Yarn 1.9.4<br>Vue.js 2.5.17<br>Vue CLI 3.0.0<br>WebStorm 2018.2.1</p>
<h2 id="Dockerfile">Dockerfile</h2><hr>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FROM</span> node:<span class="number">8.11</span>.<span class="number">3</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash">yarn global add @vue/cli</span></span><br></pre></td></tr></table></figure>
<p>使用 Node.js 8.11.3 LTS 版本，<code>alpine</code> 版本的 image 較小</p>
<h2 id="Docker_Compose">Docker Compose</h2><hr>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version: &#34;3&#34;&#10;&#10;services:&#10;  vue:&#10;    build: .&#10;    container_name: MyVue&#10;    volumes:&#10;      - &#34;$&#123;HOST_DIR&#125;:/vue&#34;&#10;    expose:&#10;      - 8080&#10;    ports:&#10;      - $&#123;VUE_PORT&#125;:8080&#10;    tty: true</span><br></pre></td></tr></table></figure>
<ul>
<li>將 container 內的 <code>/vue</code> 目錄對應到 host 目錄，將會在 <code>.env</code> 內設定</li>
<li><code>vue serve</code> 預設會啟動在 <code>8080</code> port，可自行對應到 host 的任意 port，將會在 <code>.env</code> 設定</li>
</ul>
<h2 id="-env">.env</h2><hr>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">HOST_DIR=<span class="value">~/Code/Vue</span></span></span><br><span class="line"><span class="setting">VUE_PORT=<span class="value"><span class="number">1234</span></span></span></span><br></pre></td></tr></table></figure>
<p>設定 host 目錄與 port。</p>
<h2 id="啟動_Container">啟動 Container</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up <span class="operator">-d</span></span><br></pre></td></tr></table></figure>
<p>啟動 Vue container。</p>
<p><img src="/images/docker/vue/vue000.png" alt="vue000"></p>
<h2 id="進入_Container">進入 Container</h2><hr>
<p>由於 Node.js 與 Vue CLI 是裝在 Container 內，所以必須進入 Container 使用 Vue CLI。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -<span class="keyword">it</span> MyVue sh</span><br></pre></td></tr></table></figure>
<p><img src="/images/docker/vue/vue001.png" alt="vue001"></p>
<ol>
<li><code>#</code> 為 Container 內的 Linux 環境</li>
</ol>
<h2 id="建立專案">建立專案</h2><hr>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="preprocessor"># cd vue</span></span><br><span class="line">/vue <span class="preprocessor"># vue create hello-world</span></span><br></pre></td></tr></table></figure>
<p>進入 vue 目錄，使用 <code>vue create</code> 建立專案。</p>
<p><img src="/images/docker/vue/vue002.png" alt="vue002"></p>
<p><img src="/images/docker/vue/vue003.png" alt="vue003"></p>
<ul>
<li>之後建立專案方式跟我們在 Host 完全一樣，差異只是原本 Vue CLI 跑在 Host，而現在 Vue CLI 跑在 Docker 內</li>
</ul>
<h2 id="執行_Vue">執行 Vue</h2><hr>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd hello-world</span><br><span class="line">hello-world <span class="variable">$ </span>yarn serve</span><br></pre></td></tr></table></figure>
<p><img src="/images/docker/vue/vue004.png" alt="vue004"></p>
<ol>
<li>Vue 啟動在 <code>http://localhost:8080</code>，但別忘了我們 Docker Compose 將 <code>1234</code> 對應到 <code>8080</code>，所以在 Host 應該使用 <code>http://localhost:1234</code></li>
</ol>
<p><img src="/images/docker/vue/vue005.png" alt="vue005"></p>
<ol>
<li>Host 在 <code>http://localhost:1234</code> 看到 Vue</li>
</ol>
<h2 id="開發_Vue">開發 Vue</h2><hr>
<p>雖然目前 Node.js 與 Vue CLI 是安裝在 Container 內，但對於開發則無影響，因為 Host 的目錄已經與 Container 的目錄做 mapping。</p>
<p>依 <code>.env</code> 設定，Host 的 <code>~/Code/Vue</code> 就相當於 Container 的 <code>/vue</code>，只要在 Host 做任何修改，就相當於在 container 內修改。 </p>
<p><img src="/images/docker/vue/vue006.png" alt="vue006"></p>
<ol>
<li>將原本的 <code>Welcome to your Vue.js App</code> 改成 <code>Welcome to your Vue App</code>，然後存檔</li>
</ol>
<p><img src="/images/docker/vue/vue007.png" alt="vue007"></p>
<ol>
<li>存檔後，瀏覽器也會自動更新</li>
</ol>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>若你不想在本機安裝 Node.js、Yarn、Vue CLI，則使用 Docker 是最簡單的方式</li>
<li>若想要測試不同 Node.js 、Yarn 與 Vue CLI 版本，也不用在本機安裝，只要修改 Dockerfile 與 Docker Compose 即可，本機永遠乾淨</li>
<li>開發工具一樣裝在 Host，所以開發習慣完全沒有改變</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/docker-vue" target="_blank" rel="external">GitHub</a> 上找到</p>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://jonny-huang.github.io" target="_blank" rel="external">Jonny Huang</a>, <a href="https://jonny-huang.github.io/docker/docker_01/" target="_blank" rel="external">用 Docker 建立不同 Angular CLI 版本的開發環境</a></p>
]]></content>
    <summary type="html">
    <![CDATA[使用 Docker 將 Vue 開發環境與本機隔離]]>
    
    </summary>
    
      <category term="Docker" scheme="https://oomusou.io/tags/Docker/"/>
    
      <category term="Vue" scheme="https://oomusou.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 VS Code 開發 Haskell ?]]></title>
    <link href="https://oomusou.io/haskell/hie/"/>
    <id>https://oomusou.io/haskell/hie/</id>
    <published>2018-08-13T15:23:43.000Z</published>
    <updated>2018-08-14T02:56:12.916Z</updated>
    <content type="html"><![CDATA[<p>Haskell 是個非常純的 FP 語言，如所有 data 都是 Immutable，所有 function 都是 Lazy Evaluation，這些觀念都是一般程式語言所沒有的，透過 Haskell，可以讓我們學習更純的 FP 概念，而不是 workaround 式的 FP，進而改變思考方式。</p>
<p>Haskell IDE Engine 是基於 LSP (Language Service Protocol)，讓我們在 VS Code 就可以享受如 IDE 強大功能。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>Stack 1.7.1<br>Haskell IDE Engine 0.2.2.0<br>Haskell Language Server 0.0.21<br>VS Code 1.25.1</p>
<h2 id="Haskell_Stack">Haskell Stack</h2><hr>
<p>Stack 為 Haskell 的 CLI，最大特色是將 GHC 安裝在專案目錄下，不會污染系統環境。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">brew </span>install haskell-stack</span><br></pre></td></tr></table></figure>
<p>使用 Homebrew 安裝 Stack。</p>
<p><img src="/images/haskell/hie/hie004.png" alt="hie004"></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ stack <span class="keyword">install</span> cabal-<span class="keyword">install</span></span><br></pre></td></tr></table></figure>
<p>HIE 也需要 <code>cabal</code>，使用 Stack 安裝 <code>cabal-install</code>，<code>cabal</code> 將安裝到 <code>~/local/bin</code> 目錄下。</p>
<p><img src="/images/haskell/hie/hie013.png" alt="hie013"></p>
<h2 id="設定路徑">設定路徑</h2><hr>
<p>HIE 所需的檔案都會放在 <code>~/.local/bin</code> 下，先設定好系統路徑。</p>
<p><img src="/images/haskell/hie/hie010.png" alt="hie010"></p>
<h2 id="建立專案">建立專案</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stack</span> <span class="keyword">new</span> hello-world</span><br></pre></td></tr></table></figure>
<p>使用 Stack 建立專案。</p>
<p><img src="/images/haskell/hie/hie005.png" alt="hie005"></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd hello-world</span><br><span class="line">hello-world <span class="variable">$ </span>stack setup</span><br></pre></td></tr></table></figure>
<p>使用 Stack 安裝 Haskell 專案所需要的 GHC。</p>
<p><img src="/images/haskell/hie/hie006.png" alt="hie006"></p>
<h2 id="編譯專案">編譯專案</h2><hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello-world $ <span class="built_in">stack</span> build</span><br></pre></td></tr></table></figure>
<p>使用 Stack 編譯 Haskell 專案。</p>
<p><img src="/images/haskell/hie/hie007.png" alt="hie007"></p>
<h2 id="執行_Haskell">執行 Haskell</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello-world $ stack <span class="built_in">exec</span> hello-world-exe</span><br></pre></td></tr></table></figure>
<p>Stack 預設會將專案編譯成 <code>專案名稱-exe</code>，使用 <code>stack exec</code> 執行 Haskell 執行檔。</p>
<blockquote>
<p>其實 <code>hello-world-exe</code> 已經是執行檔，只在目錄在很深，使用 <code>stack exec</code> 會自動幫我們找到執行檔執行，<code>stack exec</code> 並非 Haskell run-time</p>
</blockquote>
<p><img src="/images/haskell/hie/hie008.png" alt="hie008"></p>
<h2 id="Haskell_IDE_Engine">Haskell IDE Engine</h2><hr>
<p>Haskell IDE Engine 是基於 LSP (Language Service Protocol) 實作，簡稱 HIE。</p>
<p>VS Code 透過 HIE，就能達成相當於 IDE 才有的功能，目前 HIE 還無法在 Homebrew 找到，必須親自編譯。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/haskell</span><span class="regexp">/haskell-ide-engine --recursive</span></span><br></pre></td></tr></table></figure>
<p>Git clone 最新的 HIE 專案。</p>
<p><img src="/images/haskell/hie/hie000.png" alt="hie000"></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cd</span> haskell-ide-engine</span><br><span class="line">haskell-ide-engine $ <span class="keyword">make</span> build-<span class="keyword">all</span></span><br></pre></td></tr></table></figure>
<ol>
<li>進入 <code>haskell-ide-engine</code> 目錄</li>
<li>使用 Make 編譯 HIE</li>
</ol>
<p><img src="/images/haskell/hie/hie001.png" alt="hie001"></p>
<blockquote>
<p>這段時間會非常久，請耐心等待，在我的 Macbook Pro 15 Mid2014，需要約 40 分鐘時間編譯</p>
</blockquote>
<p><img src="/images/haskell/hie/hie003.png" alt="hie003"></p>
<p>若 Make 沒錯誤，最後的訊息如上。</p>
<p><img src="/images/haskell/hie/hie002.png" alt="hie002"></p>
<p>除了 <code>cabal</code> 為剛剛 <code>stack install cabal-install</code> 所安裝，剩下的檔案都是 <code>make build-all</code>  所編譯。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hie <span class="comment">--version</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/haskell/hie/hie011.png" alt="hie011"></p>
<ol>
<li>能顯示 HIE 版本，表示 HIE 編譯成功</li>
</ol>
<h2 id="VS_Code">VS Code</h2><hr>
<p>HIE 已經編譯成功，最後一哩路是 VS Code 的套件部分。</p>
<p><img src="/images/haskell/hie/hie009.png" alt="hie009"></p>
<ol>
<li>在 VS Code 安裝 <code>Haskell Language Server</code></li>
</ol>
<p><img src="/images/haskell/hie/hie012.png" alt="hie012"></p>
<p>VS Code 開啟 Haskell 專案，若沒有任何錯誤訊息，則表示 HIE 安裝成功。</p>
<blockquote>
<p><code>~/.local/bin</code> 設定在系統路徑非常重要，否則要在 VS Code 設定 HIE 路徑，非常麻煩</p>
</blockquote>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>Haskell IDE Engine 為 LSP，透過 HIE，我們就可以使用我們喜歡的 VS Code 編輯 Haskell，並享受 IDE 般支援</li>
<li>HIE 目前在 macOS 尚無 Homebrew 可下載，必須親自編譯才能使用</li>
<li>設定好 VS Code + HIE，就可以開心享受 Haskell 的純 FP 思維了 </li>
</ul>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://github.com/haskell" target="_blank" rel="external">Haskell</a>, <a href="https://github.com/haskell/haskell-ide-engine" target="_blank" rel="external">Haskell IDE Engine</a><br><a href="https://qiita.com/waddlaw" target="_blank" rel="external">Waddlaw</a>, <a href="https://qiita.com/waddlaw/items/b83cd10311200095fe87" target="_blank" rel="external">VS Code と haskell-ide-engine で Haskell 開発環境を構築する</a></p>
]]></content>
    <summary type="html">
    <![CDATA[使用 VS Code + Haskell IDE Engine]]>
    
    </summary>
    
      <category term="Haskell" scheme="https://oomusou.io/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 Vue 搭配 ESLint + Airbnb Style Guide ?]]></title>
    <link href="https://oomusou.io/vue/vuecli/eslint/"/>
    <id>https://oomusou.io/vue/vuecli/eslint/</id>
    <published>2018-08-13T13:23:43.000Z</published>
    <updated>2018-08-15T08:19:56.523Z</updated>
    <content type="html"><![CDATA[<p>Vue CLI 3 已經整合 ESLint 與著名的 Airbnb JavaScript Style Guide，只要跟著 Vue CLI 3 的 Wizard，我們也能輕易地將 ESLint 與 Airbnb 整進 Vue 專案。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>Node.js 8.11.3<br>Yarn 1.9.4<br>Vue 2.5.17<br>Vue CLI 3.0.0<br>WebStorm 2018.2.1</p>
<h2 id="建立_Project">建立 Project</h2><hr>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>vue create hello-world</span><br></pre></td></tr></table></figure>
<p>使用 <code>vue create</code> 建立 Vue 專案。</p>
<p><img src="/images/vue/vuecli/eslint/eslint000.png" alt="eslint000"></p>
<h2 id="選擇_Feature">選擇 Feature</h2><hr>
<p><img src="/images/vue/vuecli/eslint/eslint001.png" alt="eslint001"></p>
<ol>
<li>不選擇 <code>babel, eslint</code>，選擇 <code>Manually select features</code></li>
</ol>
<h2 id="選擇_Babel_與_Linter">選擇 Babel 與 Linter</h2><hr>
<p><img src="/images/vue/vuecli/eslint/eslint002.png" alt="eslint002"></p>
<ol>
<li>選擇 <code>Babel</code></li>
<li>選擇 <code>Linter / Formatter</code></li>
</ol>
<p><img src="/images/vue/vuecli/eslint/eslint003.png" alt="eslint003"></p>
<ol>
<li>選擇 <code>ESLint + Airbnb config</code></li>
</ol>
<h2 id="存檔時執行_ESLint">存檔時執行 ESLint</h2><hr>
<p><img src="/images/vue/vuecli/eslint/eslint004.png" alt="eslint004"></p>
<ol>
<li>選擇 <code>Lint on save</code></li>
</ol>
<h2 id="Config_存檔方式">Config 存檔方式</h2><hr>
<p><img src="/images/vue/vuecli/eslint/eslint005.png" alt="eslint005"></p>
<ol>
<li>選擇 <code>In dedicated config files</code>，也就是設定會單獨在 <code>.eslintrc.js</code>，而不是存到 <code>package.json</code> 內</li>
</ol>
<h2 id="將設定存成預設值">將設定存成預設值</h2><hr>
<p><img src="/images/vue/vuecli/eslint/eslint006.png" alt="eslint006"></p>
<ol>
<li>選擇 <code>Y</code> 將 ESLint + Airbnb 存成預設值</li>
<li>將預設值存成 <code>.vuerc</code></li>
</ol>
<blockquote>
<p><code>.vuerc</code> 將存到 home directory 根目錄下，將來 <code>vue create</code> 時，將可選擇 <code>.vuerc</code> 內的設定</p>
</blockquote>
<p><img src="/images/vue/vuecli/eslint/eslint009.png" alt="eslint009"></p>
<p>將來建立專案時，將多了 <code>.vuerc (babel, eslint)</code> 選項，也就是剛剛存的預設值。</p>
<h2 id="選擇套件管理工具">選擇套件管理工具</h2><hr>
<p><img src="/images/vue/vuecli/eslint/eslint007.png" alt="eslint007"></p>
<ol>
<li>選擇 Yarn，將以 Yarn 作為標準的套件管理工具</li>
</ol>
<p><img src="/images/vue/vuecli/eslint/eslint008.png" alt="eslint008"></p>
<p>Vue CLI 建立專案成功。</p>
<h2 id="WebStorm">WebStorm</h2><hr>
<p><img src="/images/vue/vuecli/eslint/eslint010.png" alt="eslint010"></p>
<ul>
<li>WebStorm 能正確搭配 ESList 與 Airbnb Style Guide 發出警告</li>
<li>按熱鍵 <code>⌘ + ⌥ + L</code> 同值執行 format 與 lint fix</li>
</ul>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>Vue CLI 3 已經將 ESLint 與 Airbnb Style Guide 整好，WebStorm 也能聰明地抓到 Vue CLI 的設定進行檢查與修正</li>
</ul>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://github.com/airbnb" target="_blank" rel="external">Airbnb</a>, <a href="https://github.com/airbnb/javascript" target="_blank" rel="external">Airbnb JavaScript Style Guide</a><br><a href="https://vuejs.org/" target="_blank" rel="external">Vue.js</a>, <a href="https://cli.vuejs.org/" target="_blank" rel="external">Vue CLI 3</a></p>
]]></content>
    <summary type="html">
    <![CDATA[使用 ESLint 與 Airbnb 為 Vue 做更嚴的檢查]]>
    
    </summary>
    
      <category term="ESLint" scheme="https://oomusou.io/tags/ESLint/"/>
    
      <category term="Vue" scheme="https://oomusou.io/tags/Vue/"/>
    
      <category term="Vue CLI" scheme="https://oomusou.io/tags/Vue-CLI/"/>
    
      <category term="WebStorm" scheme="https://oomusou.io/tags/WebStorm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 WebStorm 開發 Vue ?]]></title>
    <link href="https://oomusou.io/webstorm/vue/"/>
    <id>https://oomusou.io/webstorm/vue/</id>
    <published>2018-08-13T12:23:43.000Z</published>
    <updated>2018-08-15T08:30:00.404Z</updated>
    <content type="html"><![CDATA[<p>WebStorm 已經提供 Vue 的 plugin，支援 Vue 完整，唯一只有 <code>.vue</code> 格式縮排部分，Webstorm 與 Vue 的看法迥異，在 Reformat  Code 之後，縮排會完全跑掉，需要特別設定。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>Node.js 8.11.3<br>Yarn 1.9.4<br>Vue 2.5.17<br>WebStorm 2018.2.1</p>
<h2 id="-vue_格式">.vue 格式</h2><hr>
<p><img src="/images/webstorm/vue/vue000.png" alt="vue000"></p>
<p>由 Vue CLI 所建立的 <code>App.vue</code>，我們發現 Vue 的縮排有幾個特點 :</p>
<ol>
<li>無論是 HTML、JavaScript 或 CSS，其縮排都使用 2 個 space</li>
<li><code>&lt;script/&gt;</code> 與 <code>&lt;style/&gt;</code> 的第一層不再縮排</li>
</ol>
<p><img src="/images/webstorm/vue/vue001.png" alt="vue001"></p>
<p>經過 WebStorm 的 Reformat Code，縮排就跑掉了。</p>
<h2 id="調整縮排">調整縮排</h2><hr>
<h3 id="CSS">CSS</h3><p><img src="/images/webstorm/vue/vue002.png" alt="vue002"></p>
<ol>
<li><strong><em>Preferences -&gt; Editor -&gt; Code -&gt; CSS -&gt; Tabs and Indents</em></strong></li>
<li>Tab size、Indent 與 Continuation indent 全改成 <code>2</code></li>
</ol>
<h3 id="HTML">HTML</h3><p><img src="/images/webstorm/vue/vue003.png" alt="vue003"></p>
<ol>
<li><strong><em>Preferences -&gt; Editor -&gt; Code -&gt; HTML -&gt; Tabs and Indents</em></strong></li>
<li>Tab size、Indent 與 Continuation indent 全改成 <code>2</code></li>
</ol>
<h3 id="JavaScript">JavaScript</h3><p><img src="/images/webstorm/vue/vue004.png" alt="vue004"></p>
<ol>
<li><strong><em>Preferences -&gt; Editor -&gt; Code -&gt; JavaScript -&gt; Tabs and Indents</em></strong></li>
<li>Tab size、Indent 與 Continuation indent 全改成 <code>2</code></li>
</ol>
<h2 id="Template_與_Script_不縮排">Template 與 Script 不縮排</h2><hr>
<p><img src="/images/webstorm/vue/vue005.png" alt="vue005"></p>
<ol>
<li><strong><em>Preferences -&gt; Editor -&gt; Code -&gt; HTML -&gt; Other</em></strong></li>
<li>修改 <code>Do not indent children of:</code> </li>
</ol>
<p><img src="/images/webstorm/vue/vue006.png" alt="vue006"></p>
<ol>
<li>新增 <code>script</code> 與 <code>style</code></li>
</ol>
<blockquote>
<p>也就是 <code>&lt;script/&gt;</code> 與 <code>&lt;style/&gt;</code> 的第一層不縮排，符合 Vue 的習慣</p>
</blockquote>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>此設定在 JetBrains 其他工具也適用</li>
<li>WebStorm 目前支援 Vue 良好，只要調整縮排部分，就可完美在 WebStorm 開發 Vue，不用再安裝任何 package</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[WebStorm 目前已經完整支援 Vue]]>
    
    </summary>
    
      <category term="Vue" scheme="https://oomusou.io/tags/Vue/"/>
    
      <category term="WebStorm" scheme="https://oomusou.io/tags/WebStorm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vue CLI 之 Hello World (macOS)]]></title>
    <link href="https://oomusou.io/vue/vuecli/hello-world-mac/"/>
    <id>https://oomusou.io/vue/vuecli/hello-world-mac/</id>
    <published>2018-08-11T13:23:43.000Z</published>
    <updated>2018-08-16T03:42:14.631Z</updated>
    <content type="html"><![CDATA[<p>現代前端的 Tooling 繁雜， 一直是跨入前端的門檻，讓 CLI 成為 Tooling 的抽象層，由 CLI 幫我們解決繁瑣的 Tooling 整合。</p>
<p>由於 Vue CLI 3 的發表，Vue 的 CLI 又向前邁進一大步，本文介紹如何使用 Vue CLI 3 快速建立 Vue 專案。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>Node.js 8.11.3<br>Yarn 1.9.4<br>Vue.js 2.5.17<br>Vue CLI 3.0.0</p>
<h2 id="Node-js">Node.js</h2><hr>
<p>現代前端都基於 Node.js 生態系，Vue 也不例外，首先必須安裝 Node.js。</p>
<p><img src="/images/vue/vuecli/hello-world-mac/vuecli009.png" alt="vuecli009"></p>
<p>到 <a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a> 官網下載 8.11.3 LTS，只要下一步下一步安裝即可。</p>
<h2 id="Yarn">Yarn</h2><hr>
<p>Node.js 內建 NPM 套件管理工具，但 NPM 的演算法實在不優，速度很慢，Facebook 另外提出了 Yarn 管理前端套件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g yarn</span><br></pre></td></tr></table></figure>
<p>使用 NPM 以 <code>g</code> lobal 方式安裝 Yarn。</p>
<p><img src="/images/vue/vuecli/hello-world-mac/vuecli001.png" alt="vuecli001"></p>
<p>將來安裝前端套件，將以 Yarn 取代 NPM。</p>
<h2 id="Vue_CLI">Vue CLI</h2><hr>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn <span class="built_in">global</span> <span class="keyword">add</span> @vue/<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>
<p>使用 Yarn 以 <code>g</code> lobal 方式安裝 Vue CLI。</p>
<p><img src="/images/vue/vuecli/hello-world-mac/vuecli002.png" alt="vuecli002"></p>
<h2 id="建立_Project">建立 Project</h2><hr>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>vue create hello-world</span><br></pre></td></tr></table></figure>
<p>使用 <code>vue create</code> 建立 Vue 專案。</p>
<p><img src="/images/vue/vuecli/hello-world-mac/vuecli003.png" alt="vuecli003"></p>
<p><img src="/images/vue/vuecli/hello-world-mac/vuecli004.png" alt="vuecli004"></p>
<ol>
<li>選擇 project 類型，先按 ↩ 選擇預設的 (babel + eslint) 即可</li>
</ol>
<p><img src="/images/vue/vuecli/hello-world-mac/vuecli010.png" alt="vuecli010"></p>
<ol>
<li>選擇套件管理工具，選擇預設的 <code>Yarn</code></li>
</ol>
<p><img src="/images/vue/vuecli/hello-world-mac/vuecli005.png" alt="vuecli005"></p>
<ol>
<li>成功建立專案</li>
</ol>
<h2 id="執行_Vue">執行 Vue</h2><hr>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd hello-world</span><br><span class="line">hello-world <span class="variable">$ </span>yarn serve</span><br></pre></td></tr></table></figure>
<p>使用 <code>yarn serve</code> 執行 Vue。</p>
<p><img src="/images/vue/vuecli/hello-world-mac/vuecli006.png" alt="vuecli006"></p>
<ol>
<li>進入 <code>hello-world</code> 目錄</li>
<li>輸入 <code>yarn serve</code> 執行 Vue</li>
</ol>
<p><img src="/images/vue/vuecli/hello-world-mac/vuecli007.png" alt="vuecli007"></p>
<ol>
<li>Vue 啟動在 <code>http://localhost:8080</code></li>
</ol>
<p><img src="/images/vue/vuecli/hello-world-mac/vuecli008.png" alt="vuecli008"></p>
<p>Vue 順利執行在 <code>localhost:8080</code>。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>Vue CLI 3 讓我們類似 Angular CLI 快速建立專案，也將相關的設定 tooling 都準備好，大幅降低現代前端的進入門檻</li>
</ul>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://vuejs.org/" target="_blank" rel="external">Vue.js</a>, <a href="https://cli.vuejs.org/" target="_blank" rel="external">Vue CLI 3</a></p>
]]></content>
    <summary type="html">
    <![CDATA[使用 Vue CLI 3 快速建立 Project]]>
    
    </summary>
    
      <category term="Vue" scheme="https://oomusou.io/tags/Vue/"/>
    
      <category term="Vue CLI" scheme="https://oomusou.io/tags/Vue-CLI/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Functional Programming 簡介 (使用 C#)]]></title>
    <link href="https://oomusou.io/fp/intro/"/>
    <id>https://oomusou.io/fp/intro/</id>
    <published>2018-08-06T12:23:43.000Z</published>
    <updated>2018-08-15T01:40:13.484Z</updated>
    <content type="html"><![CDATA[<p>這幾年由於 Reactive Programming 興起，使得 FP 這古老的 Programming Paradigm 又成為顯學，FP 大都使用 JavaScript、Haskell … 等偏 FP 語言闡述，很少人使用 C# 來談 FP，本系列將使用大家的老朋友 C#，帶領大家一步一步進入 FP 世界。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>C# 7.2</p>
<blockquote>
<p>本文為 <a href="https://www.manning.com/books/functional-programming-in-c-sharp" target="_blank" rel="external">Funtional Programming in C#</a> 一書第一章的讀後心得</p>
</blockquote>
<h2 id="Introduction">Introduction</h2><hr>
<ul>
<li>FP 是一種 Programming Paradigm，不是 Design Pattern 也不是 Framework，更不是 Language</li>
<li>是一種以 function 為中心的 <code>思考方式</code> 與 <code>程式風格</code></li>
<li>有別於目前主流 Imperative、OOP，所以被稱為<code>邪教</code> ? </li>
</ul>
<blockquote>
<p>Imperative</p>
<p>以 command 或 statement 方式，一行一行的執行程式</p>
</blockquote>
<h2 id="Function">Function</h2><hr>
<p>在討論什麼是 Functional Programming 之前，我們先來定義什麼是 <strong>Function</strong> :</p>
<p><strong>Mathematical Function</strong></p>
<p><img src="/images/fp/intro/fp000.svg" alt="fp000"></p>
<p>在數學裡，function 就是 x 與 <code>y = f(x)</code> 的對應關係。</p>
<blockquote>
<p>f(x) 結果只與 x 的輸入有關，不會其他任何東西相關。</p>
</blockquote>
<p><img src="/images/fp/intro/fp001.svg" alt="fp001"></p>
<ul>
<li><strong>Domain</strong> : 所有的 <code>x</code> 稱為 <code>定義域</code></li>
<li><strong>Codomain</strong> : 所有 <code>可能</code> 的 <code>f(x)</code> 稱為 <code>對應域</code></li>
<li><strong>Range</strong> : 所有 <code>實際</code> 的 <code>f(x)</code> 稱為 <code>值域</code></li>
</ul>
<blockquote>
<p>這些都不是什麼高深的數學，在國一的代數我們就會了</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span>(<span class="params"><span class="keyword">int</span> x</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>int</code> : 為 Codomain</li>
<li><code>int x</code> :  為 Domain</li>
</ul>
<p>Pure Function : Codomain 只與 Domain 相關。</p>
<blockquote>
<p>Pure Function 就是 Mathematical Function 在程式語言的實踐</p>
</blockquote>
<p><strong>Programming Function</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> z = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span>(<span class="params"><span class="keyword">int</span> x</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    w = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x + z + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>func()</code> 可以讀取 <code>func()</code> 外面的 <code>z</code>，甚至可以改寫 <code>func()</code> 外部的 <code>w</code>，這就是所謂的 Side Effect。</p>
<p>因為讀取與寫入 function 的外部變數造成 Side Effect，使得變數改變的 <code>時機</code> 變得很重要，也就是所謂的 Race Condition。</p>
<blockquote>
<p>OS 恐龍書花了很多的篇幅都在解決 Race Condition (Lock、Mutex ….)。</p>
</blockquote>
<h2 id="Functional_Programming">Functional Programming</h2><hr>
<blockquote>
<p>把 function 當成 data 使用，並避免 State Mutation</p>
</blockquote>
<ul>
<li>Function as data (把 function 當成 data 使用)</li>
<li>No state mutation (不要修改 data，只要修改資料，就需擔心可能 Race Condition)</li>
</ul>
<h2 id="Function_as_Data">Function as Data</h2><hr>
<blockquote>
<p>比  function 當成 data 使用</p>
</blockquote>
<ul>
<li>能把 function 當 input、把 function 當 return</li>
<li>能將 function 指定給變數</li>
<li>能將 function 存進 Collection</li>
</ul>
<blockquote>
<p>以前 data 能怎麼用，function 就怎麼用</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Console;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Linq.Enumerable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">string</span> <span class="title">triple</span>(<span class="params"><span class="keyword">int</span> x</span>) </span>=&gt; (x * <span class="number">3</span>).ToString();</span><br><span class="line"></span><br><span class="line">            Range(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">                .Select(triple)</span><br><span class="line">                .ToList()</span><br><span class="line">                .ForEach(WriteLine);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<p>10 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">triple</span>(<span class="params"><span class="keyword">int</span> x</span>) </span>=&gt; (x * <span class="number">3</span>).ToString();</span><br></pre></td></tr></table></figure>
<p>使用 C# 7 的 Local Function 宣告 <code>triple()</code> 。</p>
<p>12 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range(<span class="number">1</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>使用 <code>Range()</code> 建立 <code>IEnumerable&lt;int&gt;</code>，因為有 <code>using static System.Linq.Enumerable;</code></p>
<blockquote>
<p><code>using static</code> 在 FP 建議使用，會讓 code 更精簡</p>
</blockquote>
<p>13 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.Select(triple)</span><br></pre></td></tr></table></figure>
<p><code>Select()</code> 就是 FP 的 <code>Map()</code>，為 <code>IEnumerable</code> 的 Extension Method。</p>
<p>與 <code>Map()</code> 一樣，<code>Select()</code> 並沒有修改原本的 <code>Range(1, 3)</code>，而是 return 新的 IEnumerable。</p>
<p><code>triple</code> 為 function，但如 data 般傳進 <code>Select()</code>，<code>Select()</code> 也就是所謂的 Higher Order Function。</p>
<blockquote>
<p>在 LINQ 的 <code>.</code> ，若使用 Extension Method，則不是 OOP 的 Method，而是 FP 的 Pipeline</p>
</blockquote>
<p>14 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.ToList()</span><br><span class="line">.ForEach(WriteLine);</span><br></pre></td></tr></table></figure>
<p>因為 List 才有 <code>ForEach()</code>，所以要先轉成 List。</p>
<p>直接使用 <code>WriteLine</code>，因為有 <code>using static System.Console;</code>。</p>
<h2 id="No_State_Mutation">No State Mutation</h2><hr>
<blockquote>
<p>不要修改 data</p>
</blockquote>
<p><code>7, 6, 1</code> 只取 <code>奇數</code>，並且 <code>由小到大</code> 排序。</p>
<p><strong>Imperative</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> original = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt; &#123;<span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">var</span> result = GetOddsByAsc(original);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> iter <span class="keyword">in</span> result)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(iter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">GetOddsByAsc</span>(<span class="params">IEnumerable&lt;<span class="keyword">int</span>&gt; original</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> result = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> iter <span class="keyword">in</span> original)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (iter % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    result.Add(iter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.Sort();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>21 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure>
<p>Imperative 典型寫法會先建立一個 <code>result</code> 變數。</p>
<p>23 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> iter <span class="keyword">in</span> original)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (iter % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result.Add(iter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根據 <code>條件</code> 不斷修改變數。</p>
<p>31 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.Sort();</span><br></pre></td></tr></table></figure>
<p>直接修改 <code>result</code> 資料排序。</p>
<p><strong>Functional</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Console;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> original = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt; &#123;<span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">var</span> result = GetOddsByAsc(original);</span><br><span class="line"></span><br><span class="line">            result.ForEach(WriteLine);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">GetOddsByAsc</span>(<span class="params">IEnumerable&lt;<span class="keyword">int</span>&gt; original</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">isOdd</span>(<span class="params"><span class="keyword">int</span> x</span>) </span>=&gt; x % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">asc</span>(<span class="params"><span class="keyword">int</span> x</span>) </span>=&gt; x;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> original</span><br><span class="line">                .Where(isOdd)</span><br><span class="line">                .OrderBy(asc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>22 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> original</span><br><span class="line">    .Where(isOdd)</span><br><span class="line">    .OrderBy(asc);</span><br></pre></td></tr></table></figure>
<p><code>original</code> 經由 pipeline 方式，先經過 <code>Where()</code> 找出 <code>奇數</code>，最後再以 <code>asc</code> 排序。</p>
<p>Code 就類似 <code>講話</code>，看不到實作細節，可讀性高。</p>
<p>不需要建立 <code>result</code> 暫存變數，也沒有修改 <code>original</code> 與 <code>result</code>，從頭到尾都沒有修改 data，這就是所謂的 <code>No State Mutation</code>，而是每次 pipeline 都建立新的 data。</p>
<blockquote>
<ul>
<li>LINQ 的 <code>Where()</code> 就是 FP 的 <code>filter()</code>，</li>
<li>LINQ 的 <code>OrderBy()</code> 就是 FP 的 <code>sort()</code></li>
</ul>
</blockquote>
<h2 id="Parallel_Computation">Parallel Computation</h2><hr>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Linq.Enumerable</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Console;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nums = Range(-<span class="number">10000</span>, <span class="number">20001</span>).Reverse().ToList();</span><br><span class="line"><span class="comment">// =&gt; [10000, 9999, ... , -9999, -10000]</span></span><br><span class="line">Action task1 = () =&gt; WriteLine(nums.Sum());</span><br><span class="line">Action task2 = () =&gt; &#123; nums.Sort(); WriteLine(nums.Sum()); &#125;;</span><br><span class="line"></span><br><span class="line">Parallel.Invoke(task1, task2);</span><br><span class="line"><span class="comment">// prints: 92332970</span></span><br><span class="line"><span class="comment">//         0</span></span><br></pre></td></tr></table></figure>
<p>由於 <code>Sort</code> 會直接去改 <code>nums</code>，造成了 Race Condition。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Linq.Enumerable</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Console;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nums = Range(-<span class="number">10000</span>, <span class="number">20001</span>).Reverse().ToList();</span><br><span class="line"><span class="comment">// =&gt; [10000, 9999, ... , -9999, -10000]</span></span><br><span class="line">Action task1 = () =&gt; WriteLine(nums.Sum());</span><br><span class="line">Action task2 = () =&gt; WriteLine(nums.OrderBy(x =&gt; x).Sum());</span><br><span class="line"></span><br><span class="line">Parallel.Invoke(task1, task2);</span><br><span class="line"><span class="comment">// prints: 0</span></span><br><span class="line"><span class="comment">//         0</span></span><br></pre></td></tr></table></figure>
<p><code>task2</code> 並不會去修改 <code>nums</code>，因此不會 Race Condition。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Console;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> original = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt; &#123;<span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">var</span> result = GetOddsByAsc(original);</span><br><span class="line"></span><br><span class="line">            result.ForEach(WriteLine);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IEnumerable&lt;<span class="keyword">int</span>&gt; <span class="title">GetOddsByAsc</span>(<span class="params">IEnumerable&lt;<span class="keyword">int</span>&gt; original</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">asc</span>(<span class="params"><span class="keyword">int</span> x</span>) </span>=&gt; x;</span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">isOdd</span>(<span class="params"><span class="keyword">int</span> x</span>) </span>=&gt; x % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> original</span><br><span class="line">                .AsParallel()</span><br><span class="line">                .Where(isOdd)</span><br><span class="line">                .OrderBy(asc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>22 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> original</span><br><span class="line">    .AsParallel()</span><br><span class="line">    .Where(isOdd)</span><br><span class="line">    .OrderBy(asc);</span><br></pre></td></tr></table></figure>
<p>只要加上 <code>AsParallel()</code> 之後，完全無痛升級多核心。</p>
<p>因為 <code>Where(isOdd)</code> 與 <code>OrderBy(asc)</code> 都是 Pure Function，沒有 Side Effect，也就沒有 Race Condition，因此可以放心使用多核心平行運算。</p>
<h2 id="FP_vs-_OOP">FP vs. OOP</h2><hr>
<p>OOP 是大家習慣的編程方式，FP 究竟有哪些觀念與 OOP 不同呢 ?</p>
<p><strong>Encapsulation</strong></p>
<ul>
<li>OOP : data 與 logic 包在 class 內</li>
<li>FP : data 與 logic 分家，data 就是 data，logic 就是 function，不使用 class</li>
</ul>
<p><strong>State Mutation</strong></p>
<ul>
<li>OOP : 繼續使用 Imperative 修改 state</li>
<li>FP : No State Mutation =&gt; Immutable =&gt; No Side Effect =&gt; No Race Condition =&gt; Pure Function =&gt; Dataflow =&gt; Pipeline (其實都在講同一件事情)</li>
</ul>
<blockquote>
<p>大部分人最難突破的 FP 點在此，這與傳統程式思維差異很大，為什麼不能改 data 呢 ?</p>
</blockquote>
<p><strong>Modularity</strong></p>
<ul>
<li>OOP : 以 class 為單位</li>
<li>FP : 以 function 為單元</li>
</ul>
<p><strong>Dependency</strong></p>
<ul>
<li>OOP : Dependency Injection</li>
<li>FP : Higher Order Function (Function Injection)</li>
</ul>
<p><strong>Loose Coupling</strong></p>
<ul>
<li>OOP : 使用 Interface</li>
<li>FP : Function Signature 就是 interface，使用 Function Composition / Function Pipeline</li>
</ul>
<h2 id="SOLID">SOLID</h2><hr>
<p><strong>SRP</strong></p>
<ul>
<li>OOP : Class 與 Method 要單一職責</li>
<li>FP :  Module 與 Function 要單一職責</li>
</ul>
<p><strong>OCP</strong></p>
<ul>
<li>OOP : Interface，使用 Object Composition</li>
<li>FP : Function Signature 就是 interface，使用 Function Composition</li>
</ul>
<p><strong>LSP</strong></p>
<ul>
<li>OOP : 有限度的繼承</li>
<li>FP : N/A</li>
</ul>
<p><strong>ISP</strong></p>
<ul>
<li>OOP : Interface 要盡量小</li>
<li>FP : Interface 小到極致就變成 function</li>
</ul>
<p><strong>DIP</strong></p>
<ul>
<li>OOP : Dependency Injection</li>
<li>FP : Higher Order Function</li>
</ul>
<blockquote>
<p>SOLID 原則在 OOP 與 FP 都適用，不過 OOP 與 FP 在實現手法並不一樣，OOP 以 class 實現，FP 以 function 實現</p>
</blockquote>
<h2 id="FP_鹹魚翻身">FP 鹹魚翻身</h2><hr>
<p>FP 其實是比 OOP 更古老的技術，LISP 早在 1958 年就問世，而 Smalltalk 則在 1972 年發表，但因為 FP 基於數學，且強調 No State Mutation，與 CPU 設計理念不合 (CPU 就是要你不斷改暫存器與記憶體)，很多人無法接受而視為 <code>邪教</code>，一直到最近才鹹魚翻身： </p>
<ol>
<li>硬體單核心時脈出現瓶頸，CPU 已經無法做出時脈超過 5GHz 以上，因此單執行緒程式速度也面臨瓶頸，但隨著半導體製程進步，單位面積可以塞入更多電晶體，因此 CPU 可以放進更多核心，但 Imperative 寫法依賴 Side Effect，使得多核心很難發揮，但 FP 沒有 Side Effect，很容易多核心平行運算，發揮多核心威力</li>
<li>Side Effect 寫法很難單元測試，因為不保證每次的結果都ㄧ樣，但 FP 的 Pure Function 很適合單元測試</li>
<li>OOP 的 Object Compostion 需依賴 Interface，容易造成 interface 滿天飛與 Over Design，但 FP 的 Function Compostion 不需要額外 interface，只要求你使用 Dataflow 思考，並使用 Pure Function 避免 Side Effect 即可</li>
<li>Reactive Programming 並不適合使用 OOP，但卻異常適合 FP，這使得 FP 找到了 <code>殺手級</code> 應用</li>
</ol>
<h2 id="C#_適合_FP_嗎_?">C# 適合 FP 嗎 ?</h2><hr>
<p>回想 FP 定義 :</p>
<ol>
<li>Function as Data</li>
<li>No State Mutation</li>
</ol>
<p><strong>Function as Data</strong></p>
<ul>
<li>C# 從 1.0 就有 Delegate，可以將 function 當成 input 與 output 使用</li>
<li>C# 3.0 支援 Lambda，讓 Anonymous Function 更容易實現</li>
<li>C# 3.0 支援 Func、Predicate、Action，讓 Anonyoua Delegate 更為方便</li>
<li>C# 的 Type Inference 比較弱，必須明確指定 Delegate 或 Func 型別 (不滿意但可接受，希望 C# 對 Type Inference 持續加油) </li>
</ul>
<p><strong>No State Mutation</strong></p>
<ul>
<li>Primitive Type 只有 <code>string</code> 與 <code>datetime</code> 為 Immutable</li>
<li>由於 C# 是從 Imperative 與 OOP 起家，任何 data 預設都是 Mutable，而不像 FP 語言預設 data 都是 Immutable，需自己加上 <code>readonly</code></li>
<li>自訂型別預設是 Mutable</li>
<li>Collection 預設是 Mutable，但已經提供 Immutable Collection</li>
</ul>
<p>所以大體上除了 Type Inference 與 Immutable 支援比較不足外，C# 7 算是個準 FP 語言，C# 亦持續朝更完整的 FP 邁進 :</p>
<ul>
<li>Record Type (Immutable 自訂 Type)</li>
<li>Algebraic Data Type (適合 DDD)</li>
<li>Pattern Matching</li>
<li>更強的 Tuple</li>
</ul>
<p>C# 8 將會是更成熟的 FP 語言。</p>
<h2 id="C#_對_FP_支援">C# 對 FP 支援</h2><p><strong>C# 3 與 LINQ</strong></p>
<ul>
<li>LINQ 本質上就是 FP，並不是使用 OOP 技術</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Enumerable</span><br><span class="line">    .Range(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    .Where(i =&gt; i % <span class="number">20</span> == <span class="number">0</span>)</span><br><span class="line">    .OrderBy(i =&gt; -i)</span><br><span class="line">    .Select(i =&gt; $<span class="string">"&#123;i&#125;%"</span>)</span><br></pre></td></tr></table></figure>
<p><code>Where()</code>、<code>OrderBy()</code>、<code>Select()</code> 都以 function 為參數，且並沒有去修改原本的 <code>Enumerable.Range(1, 100)</code>，完全符合 FP 的基本定義 :</p>
<ul>
<li>Function as Data</li>
<li>No State Mutation</li>
</ul>
<p>且 C# 提供了 Lambda，讓我們以更精簡的方式撰寫 Delegate，對於 FP 這種只使用一次的 Anonymous Function 特別有效，這也使得 C# 更適合寫 FP。</p>
<blockquote>
<p>不過 C# 社群大都沒發現 LINQ 的 FP 的本質，只有在處理 <code>IEnumerable</code> 與 <code>IQueryable</code> 才會使用 FP，其他 code 又繼續使用 Imperative 與 OOP，並沒有完全發揮 Functional C# 的潛力，也就是 FP 思維其實沒有深入 C# 社群</p>
</blockquote>
<p><strong>C# 6、7</strong></p>
<p>C# 6、7 乍看之下沒有提供實質功能，都是 syntax sugar，若以 OOP 角度來看的確如此，但若以 FP 角度，所有的 syntax sugar 都是為了讓 C# 成為更好的 FP 而準備。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Circle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> Radius &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> Circumference =&gt; PI * <span class="number">2</span> * Radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="keyword">double</span> radius</span>) </span>=&gt; Radius = radius;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> Area</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">double</span> <span class="title">Square</span>(<span class="params"><span class="keyword">double</span> d</span>) </span>=&gt; Pow(d, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> PI * Square(Radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> (<span class="keyword">double</span> Circumference, <span class="keyword">double</span> Area) Stats =&gt; (Circumference, Area);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Using Static</strong></p>
<p>第 1 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> Area</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">Square</span>(<span class="params"><span class="keyword">double</span> d</span>) </span>=&gt; Pow(d, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> PI * Square(Radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C# 6 的 <code>using static</code> 讓我們可以直接 <code>PI</code> 或 <code>Pow</code> 使用 <code>Math.PI</code> 與 <code>Math.Pow</code>。</p>
<blockquote>
<p>Q : 為什麼 <code>using static</code> 對 FP 重要 ?</p>
</blockquote>
<p>在 OOP，我們必須建立 object instance，然後才能用 method，主要是因為 OOP 的 instance method 會以 Imperative 與 Side Effect 方式使用 data，也就是 field，因此不同的 object instance 就有不同的 field，正就是 OOP 的 Encapsulation : data 與 logic 合一。</p>
<p>但因為 FP 是 data 與 logic 分家，logic 會以 static method 實現，也沒有 field，因此就不須建立 object instance，因此類似 <code>Math</code> 這種 instance variable 在 FP 就顯得沒有意義且多餘，因為 static method 都是 Pure Function，根本不需要 instance variable。</p>
<p><strong>Immutable Type</strong></p>
<p>第 5 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> Radius &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="keyword">double</span> radius</span>) </span>=&gt; Radius = radius;</span><br></pre></td></tr></table></figure>
<p>C# 目前的缺點就是沒有 <code>直接</code> 支援  Immutable 自訂型別，C# 6 透過宣告 getter-only 的 auto-property，compiler 會自動建立 <code>readonly</code> 的 field，且只能透過 constructor 設定其值，達到 <code>No State Mutation</code> 的要求。</p>
<p><strong>Expression Body</strong></p>
<p>第 6 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> Circumference =&gt; PI * <span class="number">2</span> * Radius;</span><br></pre></td></tr></table></figure>
<p>Property 可直接使用 Expression Body 語法。</p>
<blockquote>
<p>Q : 為什麼 Expression Body 對 FP 重要 ?</p>
</blockquote>
<p>因為 FP 很習慣寫 <code>小 property</code> 與 <code>小 function</code>，最後再靠 Function Composition 與 Function Pipeleine 組合起來，為了這種只有一行的 <code>小 function</code> ，還要加上 <code>{}</code>，除了浪費行數，也不符合 FP 的 Lambda 極簡風。</p>
<p>C# 6 一開始只有在 Property 與 Method 支援 Expression Body，但 C# 7 可以在 Constructor、Destructor、Getter 與 Setter 全面使用 Expression Body。</p>
<p><strong>Local Function</strong></p>
<p>12 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Square</span>(<span class="params"><span class="keyword">double</span> d</span>) </span>=&gt; Pow(d, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> PI * Square(Radius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Local Function 使我們在 Method 內可直接建立 function。</p>
<blockquote>
<p>Q : 為什麼 Local Function 對 FP 重要 ?</p>
</blockquote>
<p>由於 FP 常常需要建立 <code>小 function</code>，最後再 compose 或 pipeline，C# 7 之前只能宣告 <code>Func</code> 型別變數並配合 Lambda，但 <code>Func</code> 寫法可讀性實在不高，這也使的 C# 族群不太願意抽 <code>小 function</code>。</p>
<p>但 Local Function 的可讀性就很高，也符合一般 function 的 syntax，讓我們更願意抽 <code>小 function</code> 來 compose。</p>
<p><strong>Better Tuple</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> (<span class="keyword">double</span> Circumference, <span class="keyword">double</span> Area) Stats =&gt; (Circumference, Area);</span><br></pre></td></tr></table></figure>
<p>為了回傳 Tuple 外，還可以對 element 指定有意義的名字，讓 client 使用 Tuple 時有 Intellisense 支援。</p>
<blockquote>
<p>Q : 為什麼 Tuple 對 FP 重要 ?</p>
</blockquote>
<p>因為 FP 會在 Function Composition 與 Function Pipeline 時，拆很多小 function 實現 Dataflow，而這些 <code>小 function</code> 在傳遞資料時，就會使用 Tuple，但為這種只使用一次的 data 定義自訂型別，又會造成自訂型別滿天飛的問題，但若使用 Tuple 就可避免此問題。</p>
<h2 id="C#_如何實現_Function_?">C# 如何實現 Function ?</h2><hr>
<p>這裡的 Function 是所謂的 Mathematical Function，也就是 Pure Function。</p>
<p><strong>Static Method</strong></p>
<p>由於 Pure Function 要求 output 只與 input 有關，也就是 Pure Function 沒有 Side Effect，因此會直接使用 Static Method，如 <code>System.Math</code> 一樣，且還可搭配 C# 6 的 <code>using static</code>，讓程式碼更精簡。</p>
<p><strong>Delegate</strong></p>
<p>FP 要求 <code>Function as Data</code>，也就是 Pure Function 會以參數方式傳進其他 function，C# 1.0 function 包成 Delegate 後，以 Delegate 形式傳進其它 function。</p>
<p>Delegate 要求兩個步驟 :</p>
<ul>
<li>宣告 Delegate 型別</li>
<li>實作符合 Delegate 型別的 function</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">System</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">int</span> Comparison&lt;T&gt; (T x, Y x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>Delegate</code> 宣告 <code>Comparison</code> 型別。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = </span><br><span class="line">    Enumerable</span><br><span class="line">        .Range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">        .Select(i =&gt; i * <span class="number">3</span>)</span><br><span class="line">        .ToList();</span><br><span class="line"></span><br><span class="line">Comparison&lt;<span class="keyword">int</span>&gt; alphabetically = </span><br><span class="line">    (<span class="number">1</span>, r) =&gt; l.ToString().CompareTo(r.ToString());</span><br><span class="line"></span><br><span class="line">list.Sort(alphabetically);</span><br></pre></td></tr></table></figure>
<p>第 7 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparison&lt;<span class="keyword">int</span>&gt; alphabetically = </span><br><span class="line">    (<span class="number">1</span>, r) =&gt; l.ToString().CompareTo(r.ToString());</span><br></pre></td></tr></table></figure>
<p>根據 <code>Comparison</code> delegate 型別定義 <code>alphabetically</code> 變數，以 Lambda 描述 function。</p>
<blockquote>
<p>若實作不符合 Delegate 定義，compiler 就會報錯，所以 Delegate 也被稱為 Type-Safe Function Pointer。</p>
</blockquote>
<p>第 10 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.Sort(alphabetically);</span><br></pre></td></tr></table></figure>
<p>將 <code>alphabetically</code> delegate 傳入 <code>List.Sort()</code>。</p>
<p><strong>Func &amp; Action</strong></p>
<p>Delegate 讓我們實現 <code>Function as Data</code>，但對於只使用一次的 Anonymous Delegate 型別，到處宣告 Delegate 就類似 interface 一樣，造成檔案爆炸。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delegate</span> Greeting <span class="title">Greeter</span>(<span class="params">Person p</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>其實相當於</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;Person, Greeting&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>.NET Framework 3 之後，以 Func 與 Action 取代 Custom Delegate</p>
</blockquote>
<p><strong>Lambda</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = </span><br><span class="line">    Enumerable</span><br><span class="line">        .Range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">        .Select(i =&gt; i * <span class="number">3</span>)</span><br><span class="line">        .ToList();</span><br><span class="line"></span><br><span class="line">list.Sort((<span class="number">1</span>, r) =&gt; l.ToString().CompareTo(r.ToString();</span><br></pre></td></tr></table></figure>
<p>不用再宣告 <code>Comparison&lt;T&gt;</code> Delegate，也不用建立 <code>Comparison&lt;T&gt;</code> 的實作，直接以 Lambda 傳入 <code>List.Sort()</code>。</p>
<blockquote>
<p>寫 Lambda 時，不用寫型別，compiler 會自動使用 Type Inference 導出參數型別，且會將 Lambda 轉型成 Delegate 型別，判斷是不是符合 <code>List.Sort()</code> 要求</p>
<p>因此 Lamba 雖然寫起來像 <code>弱型別</code>，但絲毫不會影響原本 Delegate 強型別的特性，這就是 Type Inference 強大之處</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> days = Enum.GetValues(<span class="keyword">typeof</span>(DayOfWeek)).Cast&lt;DayOfWeek&gt;();</span><br><span class="line"><span class="comment">// =&gt; [Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday]</span></span><br><span class="line"></span><br><span class="line"><span class="function">IEnumerable&lt;DayOfWeek&gt; <span class="title">daysStartingWith</span>(<span class="params"><span class="keyword">string</span> pattern</span>)</span><br><span class="line">	</span>=&gt; days.Where(d =&gt; d.ToString().StartsWith(pattern));</span><br><span class="line"></span><br><span class="line">daysStartingWith(<span class="string">"S"</span>)</span><br><span class="line"><span class="comment">// =&gt; [Sunday, Saturday]</span></span><br></pre></td></tr></table></figure>
<p>不只 JavaScript 有 Closure，事實上 C# 也是有 Closure。</p>
<p> <code>daysStartingWith()</code> 會回傳 function，但傳入的參數 <code>S</code> 會以 Closure 方式存在於回傳的 function。</p>
<p><strong>Dictionary</strong></p>
<p>既然 Pure Function 只與 input 有關，我們甚至可以使用 <code>查表法</code> 的方式實作 function :</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> frenchFor = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">bool</span>, <span class="keyword">string</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">true</span>]  = <span class="string">"Vari"</span>,</span><br><span class="line">    [<span class="keyword">false</span>] = <span class="string">"Faux"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">frenchFor[<span class="keyword">true</span>];</span><br></pre></td></tr></table></figure>
<p>C# 6 提供了新的 Dictionary 初始化語法，甚至可以使用 <code>true</code> 與 <code>false</code> 當 key。</p>
<blockquote>
<p>實務上有兩種需求很適合使用 Dictionary</p>
<ol>
<li>沒有邏輯可言的 data 轉換</li>
<li>花時間的運算</li>
</ol>
</blockquote>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>FP 的 function 指的是 Mathematical Function，也就是 Pure Function，而不是 Programming Function</li>
<li>FP 屬於 Paradigm 層次，不是 framework 也不是程式語言，只要語言能支援 First-Class Function，就能以 FP 風格實現，若能支援 Immutable 與 Type Inference 更佳</li>
<li>C# 目前已經支援大部分的 FP 功能，隨著 C# 8 的發佈，FP 支援將更為完整</li>
</ul>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://www.mathsisfun.com" target="_blank" rel="external">Math is Fun</a>, <a href="https://www.mathsisfun.com/sets/domain-range-codomain.html" target="_blank" rel="external">Domain, Range and Codomain</a><br>Enrico Buonanno, <a href="https://www.manning.com/books/functional-programming-in-c-sharp" target="_blank" rel="external">Functional Programming in C#</a></p>
]]></content>
    <summary type="html">
    <![CDATA[以大家的老朋友 C# 談 FP]]>
    
    </summary>
    
      <category term="C#" scheme="https://oomusou.io/tags/C/"/>
    
      <category term="FP" scheme="https://oomusou.io/tags/FP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Refactoring to LINQ => ForEach]]></title>
    <link href="https://oomusou.io/linq/foreach/"/>
    <id>https://oomusou.io/linq/foreach/</id>
    <published>2018-08-04T12:23:43.000Z</published>
    <updated>2018-08-04T11:34:25.640Z</updated>
    <content type="html"><![CDATA[<p>LINQ 是 C# 3 實現 FP 重要里程碑，提供大量的 Operator，讓我們以 Pure Function 將 data 以 Dataflow 與 Pipeline 方式實現。本系列將先以 Imperative 實作，然後再重構成 FP，最後再重構成 LINQ Operator，並參考 LINQ source code 的實現方式。</p>
<p>首先從最基本的 <code>ForEach</code> Operator 談起。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>.NET Core 2.1<br>C# 7.2<br>Rider 2018.1.4</p>
<h2 id="User_Story">User Story</h2><hr>
<p>在 List 中有一堆名字，想要在 console 顯示每個名字。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> names = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Ben"</span>,</span><br><span class="line">                <span class="string">"Jafar"</span>,</span><br><span class="line">                <span class="string">"Matt"</span>,</span><br><span class="line">                <span class="string">"Priya"</span>,</span><br><span class="line">                <span class="string">"Brian"</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Imperative_:_for">Imperative : for</h2><hr>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> names = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Ben"</span>,</span><br><span class="line">                <span class="string">"Jafar"</span>,</span><br><span class="line">                <span class="string">"Matt"</span>,</span><br><span class="line">                <span class="string">"Priya"</span>,</span><br><span class="line">                <span class="string">"Brian"</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> counter = <span class="number">0</span>; counter &lt; names.Count; counter++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(names[counter]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>19 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> counter = <span class="number">0</span>; counter &lt; names.Count; counter++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(names[counter]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最直覺的方式 (其實應該說被制約的方式)， 就是透過 List 的 Indexer 將 List 的 item 取出來，並透過 <code>for</code> loop 去執行 <code>Console.WriteLine()</code>。</p>
<h2 id="Imperative_:_foreach">Imperative : foreach</h2><hr>
<p><img src="/images/linq/foreach/foreach000.png" alt="foreach000"></p>
<p>此時 Rider 已經提出警告，建議改用 <code>foreach</code></p>
<p><img src="/images/linq/foreach/foreach001.png" alt="foreach001"></p>
<ol>
<li>按熱鍵 <code>⌥ + ↩</code>，選擇 <code>Convert to foreach</code></li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> names = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Ben"</span>,</span><br><span class="line">                <span class="string">"Jafar"</span>,</span><br><span class="line">                <span class="string">"Matt"</span>,</span><br><span class="line">                <span class="string">"Priya"</span>,</span><br><span class="line">                <span class="string">"Brian"</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> name <span class="keyword">in</span> names)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>19 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> name <span class="keyword">in</span> names)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重構成 <code>foreach</code> 後，就不必使用 <code>counter</code> 變數，也不用考慮 <code>counter++</code> 寫錯，<code>for</code> loop 的 counter 控制，是常見的 bug 來源，所以重構成 <code>foreach</code> 絕對比 <code>for</code> 來得好。</p>
<p>且 <code>foreach</code> 的語意也比 <code>for</code> 清楚 ，因為不用看到 counter 實作細節。</p>
<h2 id="FP_:_Higher_Order_Function">FP : Higher Order Function</h2><hr>
<p>實務上這種 <code>foreach</code> 天天都要用到，但用 <code>foreach</code> 這種 statement 寫法，重複使用能力為 0，就每天都要不斷的寫 <code>foreach</code>。</p>
<p>若我們能將 <code>foreach</code> 抽成 <code>ForEach()</code> Higher Order Function，我們就能不斷 reuse <code>ForEach()</code>，只要將不同的商業邏輯以 function 傳進 <code>ForEach()</code> 即可。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> names = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Ben"</span>,</span><br><span class="line">                <span class="string">"Jafar"</span>,</span><br><span class="line">                <span class="string">"Matt"</span>,</span><br><span class="line">                <span class="string">"Priya"</span>,</span><br><span class="line">                <span class="string">"Brian"</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            names.MyForEach(name =&gt; Console.WriteLine(name));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> MyForEach&lt;T&gt;(<span class="keyword">this</span> List&lt;T&gt; list, Action&lt;T&gt; action)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> iter <span class="keyword">in</span> list)</span><br><span class="line">            &#123;</span><br><span class="line">                action(iter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>22 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> MyForEach&lt;T&gt;(<span class="keyword">this</span> List&lt;T&gt; list, Action&lt;T&gt; action)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> iter <span class="keyword">in</span> list)</span><br><span class="line">    &#123;</span><br><span class="line">        action(iter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己以 <code>MyForEach()</code> 實作出 <code>foreach</code> 的 Higher Order Function 版本。</p>
<p>第 9 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.MyForEach(name =&gt; Console.WriteLine(name));</span><br></pre></td></tr></table></figure>
<p>原來的 <code>foreach</code> statement 重構成 <code>MyForEach()</code> Higher Order Function 版本，只要將 <code>Console.WriteLine()</code> 改用 Lambda 傳入 <code>MyForEach()</code> 即可，如此 <code>foreach</code> 就能被 reuse 了。</p>
<p>不過 C# 在此可能感受不到 FP 所謂的 Dataflow 與 Pipeline，就語意而言，只能說我們為 List 寫了一個新 method : <code>MyForEach()</code> ，也就是 C# 所謂的 Extension Method，這符合傳統 C# 的 OOP 思維。</p>
<p>他山之石可以攻錯，我們來看看 F# 語法。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"Ben"</span>; <span class="string">"Jafar"</span>; <span class="string">"Matt"</span>; <span class="string">"Priya"</span>; <span class="string">"Brian"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> MyForEach action list = </span><br><span class="line">    <span class="keyword">for</span> iter <span class="keyword">in</span> list <span class="keyword">do</span></span><br><span class="line">        action iter</span><br><span class="line">names </span><br><span class="line">|&gt; MyForEach (printfn <span class="string">"%A "</span>)</span><br></pre></td></tr></table></figure>
<p><code>names</code> 為 List，<code>myForEach()</code> 為自己實作的 <code>ForEach()</code> Higher Order function，若不懂 F# 語法先略過細節沒關係。</p>
<p><code>|&gt;</code> 為 pipeline，所以可以明顯看出其語意為 <code>names</code> data 以 Dataflow 與 Pipeline 方式傳給 <code>myForEach()</code> 執行 <code>printfn()</code>。</p>
<p>但 C# 並沒有特別提供 <code>|&gt;</code> 這種 pipeline 符號，而是繼續使用 OOP 的 <code>.</code> 。</p>
<p><code>.</code> 雖然方便，但心裡要知道，這裡的 <code>.</code> 並不是 OOP 的 method，而是 FP 的 Dataflow 與 Pipeline，只是也使用了 <code>.</code> 為符號，其本質是 F# 的 <code>|&gt;</code>，<code>.</code> 算是 <code>|&gt;</code> 的 syntax sugar。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> MyForEach&lt;T&gt;(<span class="keyword">this</span> List&lt;T&gt; list, Action&lt;T&gt; action)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> iter <span class="keyword">in</span> list)</span><br><span class="line">    &#123;</span><br><span class="line">        action(iter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再舉例另外一個例子證明 <code>.</code> 並非 OOP 的 method，而是 FP 的 Pipeline。</p>
<p>我們實現 <code>MyForEach()</code> 時，並不是寫在 <code>List</code> class 內，而是透過 static method + this 參數成為 Extenstion Method，也就是<code>List</code> data 與  <code>MyForEach()</code> logic 是徹底分離，而非如 OOP 將 data 與 logic 寫在 <code>List</code> class 內，也再次證明 Extension Method 是 C# 實踐 Pipeline 的手法，而 <code>.</code> 只是 syntax sugar，其本質是 FP 的 Pipeline。</p>
<h2 id="IEnumrable">IEnumrable</h2><hr>
<p><img src="/images/linq/foreach/foreach002.png" alt="foreach002"></p>
<p>當初我們只是想為了 List 重構，所以 Extension Method 的型別只用了 List，Rider 提出建議：<code>List&lt;T&gt; 其實可以重構成 IEnumerable&lt;T&gt;</code>，如此 <code>MyForEach()</code> 重複使用能力更高。</p>
<p><img src="/images/linq/foreach/foreach003.png" alt="foreach003"></p>
<ol>
<li>將 cursor 放在 <code>List</code> 上，按熱鍵 <code>⌥ + ↩</code>，選擇 <code>Make parameter type IEnumerable&lt;T&gt;</code></li>
</ol>
<p><img src="/images/linq/foreach/foreach005.png" alt="foreach005"></p>
<ol>
<li>將 <code>List&lt;T&gt;</code> 重構成 <code>IEnumerable&lt;T&gt;</code>。</li>
</ol>
<h2 id="Method_Group">Method Group</h2><hr>
<p><img src="/images/linq/foreach/foreach008.png" alt="foreach008"></p>
<p>Rider 建議將 Lambda 重構成 Method Group。</p>
<p><code>MyForEach()</code> 後接 Lambda 天經地義，但若 function 的型別定義的很清楚，讓 compiler 可以找到正確 signature 的 Overloading method，則不用寫 Lambda，傳入 method 名稱即可，這就是 Method Group，會讓 FP 寫法更加精簡。</p>
<p><code>MyForEach()</code> 很明確定義了 <code>Action&lt;T&gt;</code>，就只有一個 input 參數的 function，因此 compiler 有足夠的資訊找到 <code>Console.WriteLine()</code> 正確的 Overloading 版本，因此適合重構成 Method Group。</p>
<p><img src="/images/linq/foreach/foreach004.png" alt="foreach003"></p>
<ol>
<li>將 cursor 放在 <code>WriteLine</code> 上，按熱鍵 <code>⌥ + ↩</code>，選擇 <code>Replace with method group</code></li>
</ol>
<p><img src="/images/linq/foreach/foreach006.png" alt="foreach006"></p>
<ol>
<li>只要傳入 Method 名稱即可，不用寫 Lambda</li>
</ol>
<h2 id="Using_static">Using static</h2><hr>
<p>其實目前的 <code>Console.WriteLine</code> 已經非常精簡，可讀性也高，但 C# 6 提供了 <code>using static</code>，可以讓你寫出更 FP 風格的 code。</p>
<p><img src="/images/linq/foreach/foreach007.png" alt="foreach007"></p>
<ol>
<li>將 cursor 放在 <code>Console</code> 上，按熱鍵 <code>⌥ + ↩</code>，選擇 <code>Import static members</code></li>
</ol>
<p><img src="/images/linq/foreach/foreach009.png" alt="foreach009"></p>
<ol>
<li>將 <code>System.Console</code> 使用 <code>using static</code></li>
<li><code>MyForEach()</code> 只要傳入 <code>WriteLine</code> 即可，更像是 function</li>
</ol>
<h2 id="LINQ_:_ForEach">LINQ : ForEach</h2><hr>
<p>其實 <code>ForEach()</code> 這種很普遍的東西，在 LINQ 早已內建，我們改用 LINQ 版本。</p>
<p><img src="/images/linq/foreach/foreach010.png" alt="foreach010"></p>
<ol>
<li>直接使用 LINQ 的 <code>ForEach()</code>，將自己寫的 <code>MyForEach()</code> 刪除</li>
</ol>
<h2 id="LINQ_如何實踐_?">LINQ 如何實踐 ?</h2><hr>
<p><img src="/images/linq/foreach/foreach011.png" alt="foreach011"></p>
<p>我們來看看 LINQ 的 source code 如何實踐 <code>ForEach()</code> ?</p>
<p>一開始對 <code>action</code> 進行判斷，若沒有則拋出 exception。</p>
<p><code>action</code> 也搭配 <code>for</code> 進行，跟我們使用 <code>foreach</code> 類似。</p>
<blockquote>
<p>Q : 為什麼 <code>ForEach()</code> 是在 <code>List</code> class ? 而不是以 Extension Method 實現 ?</p>
</blockquote>
<p>這的確是 LINQ 設計上的好問題，LINQ 並沒有選擇將 <code>ForEach()</code> 以 Extension Method 對 <code>IEnumerable</code> 實作，而是直接寫在 <code>List</code> class 內。</p>
<p>這個設計也使得我們要使用 <code>ForEach()</code> 時，一定得 <code>ToList()</code> 成 List 才能使用。</p>
<p>為了使用上方便，我還是會在自己的 library 為 <code>IEnumerable</code> 加上 <code>ForEach()</code> Extension Method，這樣就不需 <code>ToList()</code> 了。</p>
<h2 id="使用時機">使用時機</h2><hr>
<p><code>ForEach()</code> 表面上看起來是 <code>foreach</code> statement 的 syntax sugar，但事實上 <code>ForEach()</code> 在 FP 的意義並非如此。</p>
<p>FP 將 data 以 Dataflow 與 Pipeline 方式處理，因此提供了眾多 operator，而 operator 則必須搭配 pure function，不能有 Side Effect。但 Side effect 總要有人處理，<code>ForEach()</code> 就是讓你統一處理 Side Effect 之處。</p>
<p>與 Imperative 寫法的差異是 : Imperative 總是不斷的在處理 Side Effect，因此造成結果難以預測、難以測試，bug 就是由此展開；但  FP 對於 data 處理堅持採用 Dataflow 與 Pipeline，不使用 Side Effect，因此對 data 處理是可預測且容易測試，直到最後 data 處理完，才不得已使用 <code>ForEach()</code> 處理 Side Effect。</p>
<p>如 <code>Console.WriteLine()</code> 就是 I/O，就是 Side Effect，這是無法避免的，最後使用 <code>ForEach()</code> 統一解決。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li><code>.</code> 與 Extension Method 是 C# 的 syntax sugar，其本質就是 FP 的 data 與 logic 分離與 Pipeline</li>
<li>Method Group 讓 FP 寫法會更為精簡，也是 C# 很重要的發明</li>
<li>FP 的 operator 主要在處理 Dataflow 與 Pipeline，應該使用 pure function，但 <code>ForEach()</code> 是少數讓你處理 Side Effect 的 operator，應該將 side effect 集中在 <code>ForEach()</code> 處理</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/AppSettingsJson" target="_blank" rel="external">GitHub</a> 上找到</p>
<h2 id="Reference">Reference</h2><hr>
<p><a href="http://reactivex.io" target="_blank" rel="external">ReactiveX</a>, <a href="http://reactivex.io/learnrx/" target="_blank" rel="external">Functional Programming in JavaScript</a></p>
]]></content>
    <summary type="html">
    <![CDATA[以重構角度探討 LINQ]]>
    
    </summary>
    
      <category term="C#" scheme="https://oomusou.io/tags/C/"/>
    
      <category term="LINQ" scheme="https://oomusou.io/tags/LINQ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 SonarQube 顯示 .NET Core 專案 Code Coverage ? (Docker)]]></title>
    <link href="https://oomusou.io/sonarqube/code-coverage/"/>
    <id>https://oomusou.io/sonarqube/code-coverage/</id>
    <published>2018-08-02T12:23:43.000Z</published>
    <updated>2018-08-02T03:03:59.962Z</updated>
    <content type="html"><![CDATA[<p>SonarQube 除了能檢查 C# 品質外，還可以當成 dashboard 使用，讓整個團隊有統一入口關注專案的 Code Coverage。</p>
<p>SonarQube 支援 OpenCover 與 dotCover 兩種格式，本文將以 NUnit + Coverlet + OpenCover 介紹。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>Docker for Mac 18.06.0-ce-mac70 (26399)<br>.NET Core 2.1<br>SonarQube 7.1<br>SonarScanner 4.3.1.1372<br>NUnit 3.10.1<br>Coverlet 2.1.1<br>Rider 2018.1.3</p>
<h2 id="Coverlet">Coverlet</h2><hr>
<p><img src="/images/sonarqube/code-coverage/coverage000.png" alt="coverage000"></p>
<p>在 NUnit 專案加入 Coverlet package，這是個基於 .NET Core，且能跨平台計算 Code Coverage 的 package。</p>
<blockquote>
<p>OpenCover 與 dotCover 算 .NET 生態圈兩大最有名的 package，但目前都只能跑在 Windows 平台，Coverlet 算目前跨平台最佳 solution</p>
</blockquote>
<h2 id="Dockerfile">Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FROM</span> microsoft/dotnet</span><br><span class="line"></span><br><span class="line"><span class="built_in">ENV</span> SCANNER_VERSION=<span class="number">4.3</span>.<span class="number">1.1372</span></span><br><span class="line"><span class="built_in">ENV</span> SCANNER_HOME=/opt/scanner</span><br><span class="line"></span><br><span class="line"><span class="built_in">WORKDIR</span> <span class="bash">/app</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash">apt-get update </span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y wget</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y unzip</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y openjdk-<span class="number">8</span>-jre</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">wget -q https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/<span class="variable">$SCANNER_VERSION</span>/sonar-scanner-msbuild-<span class="variable">$SCANNER_VERSION</span>-netcoreapp2.<span class="number">0</span>.zip -O /opt/sonar-scanner-msbuild.zip</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">mkdir -p <span class="variable">$SCANNER_HOME</span></span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">unzip /opt/sonar-scanner-msbuild.zip <span class="operator">-d</span> <span class="variable">$SCANNER_HOME</span></span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">rm /opt/sonar-scanner-msbuild.zip</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">chmod <span class="number">775</span> <span class="variable">$SCANNER_HOME</span>/ -R</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">COPY</span> <span class="bash">./ ./</span><br><span class="line"></span><span class="built_in">ENTRYPOINT</span> <span class="bash">[<span class="string">"./scanner.sh"</span>]</span></span><br></pre></td></tr></table></figure>
<p>因為要在 .NET Core container 安裝 SonarScanner，所以要對 .NET Core 客製化 image。</p>
<p>第 1 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FROM</span> microsoft/dotnet</span><br></pre></td></tr></table></figure>
<p>使用 <code>FROM</code> 設定所使用的基底 image。</p>
<p>使用 Microsoft 官方的 <code>microsoft/dotnet</code> image。</p>
<p>第 3 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ENV</span> SCANNER_VERSION=<span class="number">4.3</span>.<span class="number">1.1372</span></span><br><span class="line"><span class="built_in">ENV</span> SCANNER_HOME=/opt/scanner</span><br></pre></td></tr></table></figure>
<p>使用 <code>ENV</code> 設定 Dockerfile 的環境變數。</p>
<p><code>SCANNER_VERSION</code> : 因為 SonarScanner 的下載路徑，會與版本有關，所以特別設定成變數。</p>
<p><code>SCANNER_HOME</code> : 設定 SonarScanner 所安裝的目錄。</p>
<p>第 6 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WORKDIR</span> <span class="bash">/app</span></span><br></pre></td></tr></table></figure>
<p>設定 container 的工作目錄，也就是預設目錄都會在 <code>/app</code> 下。</p>
<p>第 8 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">apt-get update </span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y wget</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y unzip</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y openjdk-<span class="number">8</span>-jre</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>RUN</code> 執行 CLI 指令。</p>
<ul>
<li>使用 <code>wget</code> 下載 SonarScanner</li>
<li>使用 <code>unzip</code> 對 zip 解壓縮</li>
<li><code>SonarScanner</code> 會使用 Java 執行，需要安裝 Java Runtime</li>
</ul>
<p>12 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">wget -q https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/<span class="variable">$SCANNER_VERSION</span>/sonar-scanner-msbuild-<span class="variable">$SCANNER_VERSION</span>-netcoreapp2.<span class="number">0</span>.zip -O /opt/sonar-scanner-msbuild.zip</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>wget</code> 下載 SonarScanner 壓縮檔，並下載到 <code>/opt</code> 目錄下。</p>
<p>13 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">mkdir -p <span class="variable">$SCANNER_HOME</span></span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">unzip /opt/sonar-scanner-msbuild.zip <span class="operator">-d</span> <span class="variable">$SCANNER_HOME</span></span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">rm /opt/sonar-scanner-msbuild.zip</span></span><br></pre></td></tr></table></figure>
<p>建立 <code>/opt/scanner</code> 目錄，將 SonarScanner 壓縮檔解壓縮放到 <code>/opt/scanner</code> 目錄下，解壓縮完刪除 SonarScanner 壓縮檔。</p>
<p>16 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">chmod <span class="number">775</span> <span class="variable">$SCANNER_HOME</span>/ -R</span></span><br></pre></td></tr></table></figure>
<p>將 SonarScanner 目錄所有檔案賦予執行權力。</p>
<p>18 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">COPY</span> <span class="bash">./ ./</span></span><br></pre></td></tr></table></figure>
<p>將目前 solution 下所有檔案複製到 container 內，也就是 <code>/app</code> 目錄下。</p>
<p>19 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ENTRYPOINT</span> <span class="bash">[<span class="string">"./scanner.sh"</span>]</span></span><br></pre></td></tr></table></figure>
<p>最後會執行專案目錄下的 <code>./scanner.sh</code>，負責執行 SonarScanner 檢查。</p>
<h2 id="Docker-compose-yml">Docker-compose.yml</h2><hr>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version: &#34;3&#34;&#10;&#10;services:&#10;  net-core:&#10;    build: .&#10;    container_name: MyCore&#10;    volumes:&#10;      - &#34;$&#123;HOST_DIR&#125;:/code/&#34;&#10;    networks:&#10;      - netcore&#10;    depends_on:&#10;      - sonarqube&#10;&#10;  sonarqube:&#10;    image: sonarqube:latest&#10;    container_name: MySonarQube&#10;    ports:&#10;      - 9000:9000&#10;      - 9002:9002&#10;    networks:&#10;      netcore:&#10;        ipv4_address: 172.16.238.10&#10;     &#10;networks:&#10;  netcore:&#10;    ipam: &#10;      driver: default&#10;      config:&#10;        - subnet: 172.16.238.0/24</span><br></pre></td></tr></table></figure>
<p>設定 .NET Core 與 SonarQube 兩個 container 同時啟動。</p>
<p>第 4 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net-core:&#10;    build: .</span><br></pre></td></tr></table></figure>
<p>使用 <code>build</code> 將同目錄下的 <code>Dockerfile</code> build 成 image，也就是剛才的 <code>Dockerfile</code>。</p>
<p>第 6 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: MyCore</span><br></pre></td></tr></table></figure>
<p>使用 <code>container_name</code> 設定 .NET Core 的 container 名稱。</p>
<p>第 7 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volumes:&#10;  - &#34;$&#123;HOST_DIR&#125;:/code/&#34;</span><br></pre></td></tr></table></figure>
<p>使用 <code>volumes</code> 設定 host 與 container 的共用目錄，<code>:</code> 左方為 host 目錄，右方為 container 目錄。</p>
<p>目的是能在 .NET Core container 內抓到 host 的 project。</p>
<p>第 9 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networks:&#10;  - netcore</span><br></pre></td></tr></table></figure>
<p>使用 <code>networks</code> 設定 .NET Core 與 SonarQube 共用 <code>netcore</code> 內部網路。</p>
<p>11 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">depends_on:&#10;  - sonarqube</span><br></pre></td></tr></table></figure>
<p>.NET Core container 相依於 SonarQube container。</p>
<p>14 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sonarqube:&#10;  image: sonarqube:latest</span><br></pre></td></tr></table></figure>
<p>使用 <code>image</code> 設定 container 所使用的 image。</p>
<p>16 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: MySonarQube</span><br></pre></td></tr></table></figure>
<p>使用 <code>container_name</code> 設定 SonarQube 的 container 名稱。</p>
<p>17 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ports:&#10;  - 9000:9000&#10;  - 9002:9002</span><br></pre></td></tr></table></figure>
<p>使用 <code>ports</code> 設定 host 與 container 所 mapping 的 port，<code>:</code> 左側為 host port，右側為 container port。</p>
<p>為了能在 host 以瀏覽器連上 SonarQube，要將 host 的 9000 與 9002 兩個 port 給 host。</p>
<p>20 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networks:&#10;  netcore:&#10;    ipv4_address: 172.16.238.10</span><br></pre></td></tr></table></figure>
<p>使用 <code>network</code> 設定使用 <code>netcore</code> 網路，並設定其 IP 為 <code>172.16.238.10</code>。</p>
<blockquote>
<p>一般來說，我們不必為 container 設定固定 IP，只要使用 container 名稱就可彼此溝通，但稍後 SonarScanner 必須使用固定 IP 才能連上 SonarQube，所以在此特別要設定固定 IP</p>
</blockquote>
<p>24 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networks:&#10;  netcore:&#10;    ipam: &#10;      driver: default&#10;      config:&#10;        - subnet: 172.16.238.0/24</span><br></pre></td></tr></table></figure>
<p>設定 <code>netcore</code> 網路。</p>
<h2 id="-env">.env</h2><hr>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOST_DIR=~/Code/CSharp</span><br></pre></td></tr></table></figure>
<p>將 <code>HOST_DIR</code> 以環境變數設定，為 host 與 .NET Core container 所共享的目錄。</p>
<h2 id="scanner-sh">scanner.sh</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span></span><br><span class="line">sleep <span class="number">35</span></span><br><span class="line"><span class="built_in">cd</span> ./ClassLib.Test</span><br><span class="line">dotnet <span class="built_in">test</span> /p:CollectCoverage=<span class="literal">true</span> /p:CoverletOutputFormat=opencover </span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">dotnet /opt/scanner/SonarScanner.MSBuild.dll begin /k:core2 /n:Core2 /v:<span class="number">1.0</span> /d:sonar.login=admin /d:sonar.password=admin /d:sonar.host.url=http://<span class="number">172.16</span>.<span class="number">238.10</span>:<span class="number">9000</span> /d:sonar.cs.opencover.reportsPaths=/app/ClassLib.Test/coverage.opencover.xml /d:sonar.coverage.exclusions=**/Program.cs</span><br><span class="line">dotnet build</span><br><span class="line">dotnet /opt/scanner/SonarScanner.MSBuild.dll end /d:sonar.login=admin /d:sonar.password=admin</span><br></pre></td></tr></table></figure>
<p>使用 SonarScanner 檢查 .NET Core 專案，<code>scanner.sh</code> 會放在專案根目錄。</p>
<p>第 2 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>主要是要等 SonarQube 啟動完成，比較好的方式是使用 Health Check 明確得知 SonarQube 已經啟動完成。</p>
<p>這裡暫時先 sleep 30 秒，等 SonarQube 先啟動，.NET Core 才開始執行 SonarScanner。</p>
<p>這裡還有改善的空間，也可以自行調整 sleep 時間。</p>
<p>第 4 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet <span class="built_in">test</span> /p:CollectCoverage=<span class="literal">true</span> /p:CoverletOutputFormat=opencover</span><br></pre></td></tr></table></figure>
<p>執行 NUnit 單元測試。</p>
<ul>
<li><strong>/p:CollectCoverage=true</strong> : 命令 Coverlet 計算 Code Coverage</li>
<li><strong>/p:CoverletOutputFormat=opencover</strong> : 命令 Coverlet 以 OpenCover 格式產出</li>
</ul>
<p>第 6 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet /opt/scanner/SonarScanner.MSBuild.dll begin /k:core2 /n:Core2 /v:<span class="number">1.0</span> /d:sonar.login=admin /d:sonar.password=admin /d:sonar.host.url=http://<span class="number">172.16</span>.<span class="number">238.10</span>:<span class="number">9000</span> /d:sonar.cs.opencover.reportsPaths=/app/ClassLib.Test/coverage.opencover.xml /d:sonar.coverage.exclusions=**/Program.cs</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet</code> 執行 <code>SonarScanner.MSBuild.dll</code>，一開始以 <code>begin</code> 開頭：</p>
<ul>
<li><strong>/k</strong> : SonarQube 對專案的 key，內部將以此 key 作為辨別，必須唯一</li>
<li><strong>/n</strong> : 在 SonarQube 網頁上顯示的專案名稱</li>
<li><strong>/v</strong> : 在 SonarQube 網頁上顯示的版本編號</li>
<li><strong>/d:sonar.login</strong> : 指定 SonarQube 帳號</li>
<li><strong>/d:sonar.password</strong> : 指定 SonarQube 密碼</li>
<li><strong>/d:sonar.host.url</strong> : 指定 SonarQube server IP 與 port</li>
<li><strong>/d:sonar.cs.opencover.reportsPaths</strong> : 設定 OpenCover 格式的 XML 檔案位置</li>
<li><strong>/d:sonar.coverage.exclusions</strong> : 設定 SonarQube 排除 Code Coverage 計算的檔案</li>
</ul>
<blockquote>
<p>目前 SonarQube 設定 exclusions 的 regex 有些 bug，可能無法如文件那般設定 regex，假如遇到這個 bug，就先用最原始的方式指定 exclusions</p>
</blockquote>
<p>第 7 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet build</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet build</code> 編譯專案。</p>
<blockquote>
<p>Script 語言不用編譯，可以直接使用 SonarQube Scanner 就可以檢查，但 C# 需要編譯，因此必須 dotnet build</p>
</blockquote>
<p>第 8 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet /opt/scanner/SonarScanner.MSBuild.dll end /d:sonar.login=admin /d:sonar.password=admin</span><br></pre></td></tr></table></figure>
<p>最後需加上 <code>end</code>，scanner 正式將 <code>dotnet build</code> 檢查出的結果寫入 SonarQube project</p>
<ul>
<li>仍必須指定 SonarQube 的帳號密碼</li>
</ul>
<h2 id="執行_SonarScanner">執行 SonarScanner</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SonarScanner $ docker-compose up --build</span><br></pre></td></tr></table></figure>
<p>啟動 .NET Core 與 SonarQube container，並且自動執行 SonarScanner。</p>
<ul>
<li><strong>–build</strong> : 重新建立 .NET Core 自訂 image，若有任何修改，將重新包進 image，確保 <code>docker-compose</code> 是最新的 image</li>
</ul>
<p><img src="/images/sonarqube/code-coverage/coverage001.png" alt="core000"></p>
<p><img src="/images/sonarqube/code-coverage/coverage002.png" alt="coverage002"></p>
<ol>
<li>Coverlet 計算出 Code Coverage，並且產生 <code>coverage.opencover.xml</code></li>
</ol>
<p><img src="/images/sonarqube/code-coverage/coverage003.png" alt="coverage003"></p>
<ol>
<li>在 host 以 <code>http://localhost:9000</code> ，將可看到 SonarQube 的檢查結果，並且正確顯示 Code Coverage</li>
</ol>
<h2 id="結束_Container">結束 Container</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose down</span><br></pre></td></tr></table></figure>
<p><img src="/images/sonarqube/code-coverage/coverage004.png" alt="core003"></p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>由於 SonarScanner 已經被包在 Dockerfile 內，host 就不用再安裝 SonarScanner</li>
<li>沒有將 .NET Core 安裝在 SonarQube container 內，而是分別使用 .NET Core container 與 SonarQube container，符合 Microservice 精神</li>
<li>Coverlet 為目前唯一的 .NET Core 跨平台 Code Coverage 解決方案，並且可以產出 OpenCover 格式 XML</li>
<li>只要執行 <code>docker-compose up --build</code>，就會執行 NUnit 單元測試與 Coverlet 計算 Code Coverage，且 SonarScanner 也會自動進行檢查</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/sonarscanner" target="_blank" rel="external">GitHub</a> 上找到</p>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://github.com/tonerdo" target="_blank" rel="external">Tonerdo</a>, <a href="https://github.com/tonerdo/coverlet" target="_blank" rel="external">Coverlet</a><br><a href="https://tattoocoder.com" target="_blank" rel="external">Shryne Boyer</a>, <a href="https://tattoocoder.com/cross-platform-code-coverage-arrives-for-net-core/" target="_blank" rel="external">Cross platform code coverage arrives for .NET Core</a><br><a href="https://docs.sonarqube.org" target="_blank" rel="external">SonarQube</a>, <a href="https://docs.sonarqube.org/pages/viewpage.action?pageId=6389770" target="_blank" rel="external">Code Coverage Result Import (C#, VB.NET)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[SonarQube 也能顯示 Code Coverage]]>
    
    </summary>
    
      <category term=".NET Core" scheme="https://oomusou.io/tags/NET-Core/"/>
    
      <category term="Coverlet" scheme="https://oomusou.io/tags/Coverlet/"/>
    
      <category term="NUnit" scheme="https://oomusou.io/tags/NUnit/"/>
    
      <category term="SonarQube" scheme="https://oomusou.io/tags/SonarQube/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何讀取 JSON 格式設定檔 ?]]></title>
    <link href="https://oomusou.io/netcore/json-config/"/>
    <id>https://oomusou.io/netcore/json-config/</id>
    <published>2018-07-31T13:23:43.000Z</published>
    <updated>2018-07-31T15:37:22.515Z</updated>
    <content type="html"><![CDATA[<p>在實務上不少資訊我們不想寫死在 code 中，會以 config 形式由 client 設定，目前最主流的 config 就屬 JSON 格式，.NET 也提供了 <code>ConfigurationBuilder</code> ，讓我們輕易的讀取 JSON 格式的 config 檔。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>.NET Core 2.1<br>C# 7.2<br>Rider 2018.1.3</p>
<h2 id="安裝_Package">安裝 Package</h2><hr>
<p><img src="/images/netcore/json-config/config000.png" alt="config000"></p>
<p>要另外安裝 3 個 package :</p>
<ul>
<li><code>Microsoft.Extensions.Configuration</code></li>
<li><code>Microsoft.Extensions.Configuration.FileExtensions</code></li>
<li><code>Microsoft.Extensions.Configuration.Json</code> </li>
</ul>
<h2 id="ConfigurationBuilder">ConfigurationBuilder</h2><hr>
<p><strong>Config.json</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"Name"</span>: <span class="string">"Sam"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假設 <code>config.json</code> 放在 project 的根目錄下，想要讀取 key 為 <code>Name</code> 的 value。</p>
<p><strong>Program.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> currentDirectory = Directory.GetCurrentDirectory();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> config =</span><br><span class="line">                <span class="keyword">new</span> ConfigurationBuilder()</span><br><span class="line">                    .SetBasePath(currentDirectory)</span><br><span class="line">                    .AddJsonFile(<span class="string">"config.json"</span>)</span><br><span class="line">                    .Build();</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(config[<span class="string">"Name"</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentDirectory = Directory.GetCurrentDirectory();</span><br></pre></td></tr></table></figure>
<p>使用 <code>Directory.GetCurrentDirectory()</code> 讀取目前 project 的根目錄。</p>
<p>14 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ConfigurationBuilder()</span><br><span class="line">    .SetBasePath(currentDirectory)</span><br></pre></td></tr></table></figure>
<p>建立 <code>ConfigurationBuilder</code>，並由 <code>SetBasePath()</code> 設定其 working directory。</p>
<p>16 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.AddJsonFile(<span class="string">"config.json"</span>)</span><br></pre></td></tr></table></figure>
<p>由 <code>AddJsonFile()</code> 設定 config 檔案。</p>
<p>17 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.Build();</span><br></pre></td></tr></table></figure>
<p>最後由 <code>Build()</code> 建立 <code>config</code> 物件。</p>
<p>19 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(config[<span class="string">"Name"</span>]);</span><br></pre></td></tr></table></figure>
<p>由於 <code>IConfiguration</code> 有定義  indexer，因此我們可以 <code>Name</code> 當 key 直接存取。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>使用 <code>ConfigurationBuilder</code> 讓我們可以很簡單地讀取 JSON 格式的 config 檔</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/AppSettingsJson" target="_blank" rel="external">GitHub</a> 上找到</p>
]]></content>
    <summary type="html">
    <![CDATA[使用 Configuration Package]]>
    
    </summary>
    
      <category term=".NET Core" scheme="https://oomusou.io/tags/NET-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 SonarQube 檢查 .NET Core 專案 ? (Docker)]]></title>
    <link href="https://oomusou.io/sonarqube/netcore-docker/"/>
    <id>https://oomusou.io/sonarqube/netcore-docker/</id>
    <published>2018-07-31T12:23:43.000Z</published>
    <updated>2018-08-02T02:48:16.469Z</updated>
    <content type="html"><![CDATA[<p>SonarQube 是一套 <code>程式碼品質檢查工具</code>，可以幫我們檢查 C# 的 bugs、 vulenrability、code smell 與 duplication。</p>
<p>本文使用 Docker Compose，並同時啟動 .NET Core 與 SonarQube 兩個 container，自動對 .NET 專案進行檢查。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>Docker for Mac 18.06.0-ce-mac70 (26399)<br>.NET Core 2.1<br>SonarQube 7.1<br>SonarScanner 4.3.1.1372<br>Rider 2018.1.3</p>
<h2 id="Dockerfile">Dockerfile</h2><hr>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FROM</span> microsoft/dotnet</span><br><span class="line"></span><br><span class="line"><span class="built_in">ENV</span> SCANNER_VERSION=<span class="number">4.3</span>.<span class="number">1.1372</span></span><br><span class="line"><span class="built_in">ENV</span> SCANNER_HOME=/opt/scanner</span><br><span class="line"></span><br><span class="line"><span class="built_in">WORKDIR</span> <span class="bash">/app</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash">apt-get update </span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y wget</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y unzip</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y openjdk-<span class="number">8</span>-jre</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">wget -q https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/<span class="variable">$SCANNER_VERSION</span>/sonar-scanner-msbuild-<span class="variable">$SCANNER_VERSION</span>-netcoreapp2.<span class="number">0</span>.zip -O /opt/sonar-scanner-msbuild.zip</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">mkdir -p <span class="variable">$SCANNER_HOME</span></span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">unzip /opt/sonar-scanner-msbuild.zip <span class="operator">-d</span> <span class="variable">$SCANNER_HOME</span></span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">rm /opt/sonar-scanner-msbuild.zip</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">chmod <span class="number">775</span> <span class="variable">$SCANNER_HOME</span>/ -R</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">COPY</span> <span class="bash">./ ./</span><br><span class="line"></span><span class="built_in">ENTRYPOINT</span> <span class="bash">[<span class="string">"./scanner.sh"</span>]</span></span><br></pre></td></tr></table></figure>
<p>因為要在 .NET Core container 安裝 SonarScanner，所以要對 .NET Core 客製化 image。</p>
<p>第 1 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FROM</span> microsoft/dotnet</span><br></pre></td></tr></table></figure>
<p>使用 <code>FROM</code> 設定所使用的基底 image。</p>
<p>使用 Microsoft 官方的 <code>microsoft/dotnet</code> image。</p>
<p>第 3 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ENV</span> SCANNER_VERSION=<span class="number">4.3</span>.<span class="number">1.1372</span></span><br><span class="line"><span class="built_in">ENV</span> SCANNER_HOME=/opt/scanner</span><br></pre></td></tr></table></figure>
<p>使用 <code>ENV</code> 設定 Dockerfile 的環境變數。</p>
<p><code>SCANNER_VERSION</code> : 因為 SonarScanner 的下載路徑，會與版本有關，所以特別設定成變數。</p>
<p><code>SCANNER_HOME</code> : 設定 SonarScanner 所安裝的目錄。</p>
<p>第 6 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WORKDIR</span> <span class="bash">/app</span></span><br></pre></td></tr></table></figure>
<p>設定 container 的工作目錄，也就是預設目錄都會在 <code>/app</code> 下。</p>
<p>第 8 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">apt-get update </span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y wget</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y unzip</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y openjdk-<span class="number">8</span>-jre</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>RUN</code> 執行 CLI 指令。</p>
<ul>
<li>使用 <code>wget</code> 下載 SonarScanner</li>
<li>使用 <code>unzip</code> 對 zip 解壓縮</li>
<li><code>SonarScanner</code> 會使用 Java 執行，需要安裝 Java Runtime</li>
</ul>
<p>12 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">wget -q https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/<span class="variable">$SCANNER_VERSION</span>/sonar-scanner-msbuild-<span class="variable">$SCANNER_VERSION</span>-netcoreapp2.<span class="number">0</span>.zip -O /opt/sonar-scanner-msbuild.zip</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>wget</code> 下載 SonarScanner 壓縮檔，並下載到 <code>/opt</code> 目錄下。</p>
<p>13 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">mkdir -p <span class="variable">$SCANNER_HOME</span></span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">unzip /opt/sonar-scanner-msbuild.zip <span class="operator">-d</span> <span class="variable">$SCANNER_HOME</span></span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">rm /opt/sonar-scanner-msbuild.zip</span></span><br></pre></td></tr></table></figure>
<p>建立 <code>/opt/scanner</code> 目錄，將 SonarScanner 壓縮檔解壓縮放到 <code>/opt/scanner</code> 目錄下，解壓縮完刪除 SonarScanner 壓縮檔。</p>
<p>16 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">chmod <span class="number">775</span> <span class="variable">$SCANNER_HOME</span>/ -R</span></span><br></pre></td></tr></table></figure>
<p>將 SonarScanner 目錄所有檔案賦予執行權力。</p>
<p>18 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">COPY</span> <span class="bash">./ ./</span></span><br></pre></td></tr></table></figure>
<p>將目前 solution 下所有檔案複製到 container 內，也就是 <code>/app</code> 目錄下。</p>
<p>19 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ENTRYPOINT</span> <span class="bash">[<span class="string">"./scanner.sh"</span>]</span></span><br></pre></td></tr></table></figure>
<p>最後會執行專案目錄下的 <code>./scanner.sh</code>，負責執行 SonarScanner 檢查。</p>
<h2 id="Docker-compose-yml">Docker-compose.yml</h2><hr>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version: &#34;3&#34;&#10;&#10;services:&#10;  net-core:&#10;    build: .&#10;    container_name: MyCore&#10;    volumes:&#10;      - &#34;$&#123;HOST_DIR&#125;:/code/&#34;&#10;    networks:&#10;      - netcore&#10;    depends_on:&#10;      - sonarqube&#10;&#10;  sonarqube:&#10;    image: sonarqube:latest&#10;    container_name: MySonarQube&#10;    ports:&#10;      - 9000:9000&#10;      - 9002:9002&#10;    networks:&#10;      netcore:&#10;        ipv4_address: 172.16.238.10&#10;     &#10;networks:&#10;  netcore:&#10;    ipam: &#10;      driver: default&#10;      config:&#10;        - subnet: 172.16.238.0/24</span><br></pre></td></tr></table></figure>
<p>設定 .NET Core 與 SonarQube 兩個 container 同時啟動。</p>
<p>第 4 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net-core:&#10;    build: .</span><br></pre></td></tr></table></figure>
<p>使用 <code>build</code> 將同目錄下的 <code>Dockerfile</code> build 成 image，也就是剛才的 <code>Dockerfile</code>。</p>
<p>第 6 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: MyCore</span><br></pre></td></tr></table></figure>
<p>使用 <code>container_name</code> 設定 .NET Core 的 container 名稱。</p>
<p>第 7 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volumes:&#10;  - &#34;$&#123;HOST_DIR&#125;:/code/&#34;</span><br></pre></td></tr></table></figure>
<p>使用 <code>volumes</code> 設定 host 與 container 的共用目錄，<code>:</code> 左方為 host 目錄，右方為 container 目錄。</p>
<p>目的是能在 .NET Core container 內抓到 host 的 project。</p>
<p>第 9 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networks:&#10;  - netcore</span><br></pre></td></tr></table></figure>
<p>使用 <code>networks</code> 設定 .NET Core 與 SonarQube 共用 <code>netcore</code> 內部網路。</p>
<p>11 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">depends_on:&#10;  - sonarqube</span><br></pre></td></tr></table></figure>
<p>.NET Core container 相依於 SonarQube container。</p>
<p>14 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sonarqube:&#10;  image: sonarqube:latest</span><br></pre></td></tr></table></figure>
<p>使用 <code>image</code> 設定 container 所使用的 image。</p>
<p>16 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: MySonarQube</span><br></pre></td></tr></table></figure>
<p>使用 <code>container_name</code> 設定 SonarQube 的 container 名稱。</p>
<p>17 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ports:&#10;  - 9000:9000&#10;  - 9002:9002</span><br></pre></td></tr></table></figure>
<p>使用 <code>ports</code> 設定 host 與 container 所 mapping 的 port，<code>:</code> 左側為 host port，右側為 container port。</p>
<p>為了能在 host 以瀏覽器連上 SonarQube，要將 host 的 9000 與 9002 兩個 port 給 host。</p>
<p>20 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networks:&#10;  netcore:&#10;    ipv4_address: 172.16.238.10</span><br></pre></td></tr></table></figure>
<p>使用 <code>network</code> 設定使用 <code>netcore</code> 網路，並設定其 IP 為 <code>172.16.238.10</code>。</p>
<blockquote>
<p>一般來說，我們不必為 container 設定固定 IP，只要使用 container 名稱就可彼此溝通，但稍後 SonarScanner 必須使用固定 IP 才能連上 SonarQube，所以在此特別要設定固定 IP</p>
</blockquote>
<p>24 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networks:&#10;  netcore:&#10;    ipam: &#10;      driver: default&#10;      config:&#10;        - subnet: 172.16.238.0/24</span><br></pre></td></tr></table></figure>
<p>設定 <code>netcore</code> 網路。</p>
<h2 id="-env">.env</h2><hr>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOST_DIR=~/Code/CSharp</span><br></pre></td></tr></table></figure>
<p>將 <code>HOST_DIR</code> 以環境變數設定，為 host 與 .NET Core container 所共享的目錄。</p>
<h2 id="scanner-sh">scanner.sh</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span></span><br><span class="line">sleep <span class="number">30</span></span><br><span class="line">dotnet /opt/scanner/SonarScanner.MSBuild.dll begin /k:core2 /n:Core2 /v:<span class="number">1.0</span> /d:sonar.login=admin /d:sonar.password=admin /d:sonar.host.url=http://<span class="number">172.16</span>.<span class="number">238.10</span>:<span class="number">9000</span></span><br><span class="line">dotnet build</span><br><span class="line">dotnet /opt/scanner/SonarScanner.MSBuild.dll end /d:sonar.login=admin /d:sonar.password=admin</span><br></pre></td></tr></table></figure>
<p>使用 SonarScanner 檢查 .NET Core 專案，<code>scanner.sh</code> 會放在專案根目錄。</p>
<p>第 2 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>主要是要等 SonarQube 啟動完成，比較好的方式是使用 Health Check 明確得知 SonarQube 已經啟動完成。</p>
<p>這裡暫時先 sleep 30 秒，等 SonarQube 先啟動，.NET Core 才開始執行 SonarScanner。</p>
<p>這裡還有改善的空間，也可以自行調整 sleep 時間。</p>
<p>第 3 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet /opt/scanner/SonarScanner.MSBuild.dll begin /k:core2 /n:Core2 /v:<span class="number">1.0</span> /d:sonar.login=admin /d:sonar.password=admin /d:sonar.host.url=http://<span class="number">172.16</span>.<span class="number">238.10</span>:<span class="number">9000</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet</code> 執行 <code>SonarScanner.MSBuild.dll</code>，一開始以 <code>begin</code> 開頭：</p>
<ul>
<li><strong>/k</strong> : SonarQube 對專案的 key，內部將以此 key 作為辨別，必須唯一</li>
<li><strong>/n</strong> : 在 SonarQube 網頁上顯示的專案名稱</li>
<li><strong>/v</strong> : 在 SonarQube 網頁上顯示的版本編號</li>
<li><strong>/d:sonar.login</strong> : 指定 SonarQube 帳號</li>
<li><strong>/d:sonar.password</strong> : 指定 SonarQube 密碼</li>
<li><strong>/d:sonar.host.url</strong> : 指定 SonarQube server IP 與 port</li>
</ul>
<p>第 4 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet build</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet build</code> 編譯專案。</p>
<blockquote>
<p>Script 語言不用編譯，可以直接使用 SonarQube Scanner 就可以檢查，但 C# 需要編譯，因此必須 dotnet build</p>
</blockquote>
<p>第 5 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet /opt/scanner/SonarScanner.MSBuild.dll end /d:sonar.login=admin /d:sonar.password=admin</span><br></pre></td></tr></table></figure>
<p>最後需加上 <code>end</code>，scanner 正式將 <code>dotnet build</code> 檢查出的結果寫入 SonarQube project</p>
<ul>
<li>仍必須指定 SonarQube 的帳號密碼</li>
</ul>
<h2 id="執行_SonarScanner">執行 SonarScanner</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SonarScanner $ docker-compose up --build</span><br></pre></td></tr></table></figure>
<p>啟動 .NET Core 與 SonarQube container，並且自動執行 SonarScanner。</p>
<ul>
<li><strong>–build</strong> : 重新建立 .NET Core 自訂 image，若有任何修改，將重新包進 image，確保 <code>docker-compose</code> 是最新的 image</li>
</ul>
<p><img src="/images/sonarqube/netcore-docker/core000.png" alt="core000"></p>
<p><img src="/images/sonarqube/netcore-docker/core002.png" alt="core002"></p>
<ol>
<li>在 host 以 <code>http://localhost:9000</code> ，將可看到 SonarQube 的檢查結果</li>
</ol>
<h2 id="結束_Container">結束 Container</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose down</span><br></pre></td></tr></table></figure>
<p><img src="/images/sonarqube/netcore-docker/core003.png" alt="core003"></p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>由於 SonarScanner 已經被包在 Dockerfile 內，host 就不用再安裝 SonarScanner</li>
<li>沒有將 .NET Core 安裝在 SonarQube container 內，而是分別使用 .NET Core container 與 SonarQube container，符合 Microservice 精神</li>
<li>只要執行 <code>docker-compose up --build</code>，SonarScanner 就會自動啟動進行檢查</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/sonarscanner" target="_blank" rel="external">GitHub</a> 上找到</p>
]]></content>
    <summary type="html">
    <![CDATA[完全使用 Docker 版本 SonarQube]]>
    
    </summary>
    
      <category term=".NET Core" scheme="https://oomusou.io/tags/NET-Core/"/>
    
      <category term="Docker" scheme="https://oomusou.io/tags/Docker/"/>
    
      <category term="SonarQube" scheme="https://oomusou.io/tags/SonarQube/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 Parallel Desktop 使用 Docker for Mac ?]]></title>
    <link href="https://oomusou.io/docker/parallel-docker/"/>
    <id>https://oomusou.io/docker/parallel-docker/</id>
    <published>2018-07-29T12:23:43.000Z</published>
    <updated>2018-07-29T08:00:56.762Z</updated>
    <content type="html"><![CDATA[<p>雖然平時以 macOS 作為開發主力，偶爾還是會需要在 Parallel Desktop 使用 Windows，此時若要使用 Docker，雖然也能在 Parallel Destop 內跑 Docker for Windows，不過由於是 VM 中的 VM，Docker 並不穩定，比較建議的方式是 Windows 搭配 Docker for Mac 使用。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>Docker for Mac 18.06.0-ce-mac70 (26399)<br>PostgreSQL 10.4<br>Parallel Desktop 13 Pro 13.3.2 (43368)<br>Windows 10 Pro 1803 17134.191<br>Rider 2018.1.3 </p>
<h2 id="Docker_for_Mac">Docker for Mac</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up <span class="operator">-d</span></span><br></pre></td></tr></table></figure>
<p>在 macOS 以 <code>docker-compose</code> 啟動 PostgreSQL container，且 port 為 <code>1234</code>。</p>
<p><img src="/images/docker/parallel-docker/parallel000.png" alt="parallel000"></p>
<p>由於將來 Parallel Desktop 內的 Windows 將連到 macOS 的 PostgreSQL container，目前已知其 port 為 <code>1234</code> ，但 IP 是多少呢 ?</p>
<h2 id="Parallel_Desktop_Network">Parallel Desktop Network</h2><hr>
<p><img src="/images/docker/parallel-docker/parallel001.png" alt="parallel001"></p>
<p>Parallel Desktop 預設的 network 是以 <code>Shared Network</code> 方式。</p>
<p><img src="/images/docker/parallel-docker/parallel002.png" alt="parallel002"></p>
<p>什麼是 <code>Shared Network</code> 呢 ?</p>
<p>上圖中的 Mac 有 <code>192.168.0.20</code> 與  <code>10.211.55.10</code> 兩個 <code>IP</code> 。</p>
<p>而 Windows 的 IP 則為 <code>10.211.55.20</code>。</p>
<p>簡單的說相當於 Mac 有兩張網卡，一張網卡為 <code>192.168.0.20</code>，而另一張網卡為 <code>10.211.55.10</code>，而 Windows 的 <code>10.211.55.20</code> 與  Mac 的 <code>10.211.55.10</code> 為同一個網段，可彼此互通，然後再透過 <code>192.168.0.20</code> 這張網卡連上 internet。</p>
<p><img src="/images/docker/parallel-docker/parallel003.png" alt="parallel003"></p>
<p>我們可發現 Parallel Desktop 自帶 DHCP，且 IP 從 <code>10.211.55.1</code> 開始到 <code>10.211.55.254</code>。</p>
<p><img src="/images/docker/parallel-docker/parallel004.png" alt="parallel004"></p>
<p>當 Parallel Desktop 啟動後，實際在 macOS 下 <code>ifconfig</code> 觀察，會發現多了 <code>vinc0</code> 這張網卡，其 IP 為 <code>10.211.55.2</code>。</p>
<p>也就是說若要從 Parallel Desktop 的 Windows 連到 PostgreSQL container，IP 就是 <code>10.211.55.2</code>，port 為 <code>1234</code>。</p>
<h2 id="Windows">Windows</h2><hr>
<p><img src="/images/docker/parallel-docker/parallel005.png" alt="parallel005"></p>
<ol>
<li>在 Windows 內的 Rider 能夠以 <code>10.211.55.2 : 1234</code> 連到 Docker for Mac 的 PostgreSQL container</li>
</ol>
<h2 id="Conclusion">Conclusion</h2><ul>
<li>Parallel Desktop 都會穩定以 <code>10.211.55.2</code> 當成 macOS 的 IP，所以任何 Docker container 都可以跑在 macOS，然後 Windows 再以 <code>10.211.55.2</code> 連上即可，這樣就不需要執行 Docker for Windows 了</li>
</ul>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://www.parallels.com" target="_blank" rel="external">Parallels</a>, <a href="https://kb.parallels.com/en/4948" target="_blank" rel="external">Which networking mode (Bridged, Shared or Host-Only) should I use for the virtual machine?</a></p>
]]></content>
    <summary type="html">
    <![CDATA[不必再與 Docker for Windows 搏鬥]]>
    
    </summary>
    
      <category term="Docker" scheme="https://oomusou.io/tags/Docker/"/>
    
      <category term="Parallel Desktop" scheme="https://oomusou.io/tags/Parallel-Desktop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使 GitHub Blog 升級成 https ?]]></title>
    <link href="https://oomusou.io/hexo/https/"/>
    <id>https://oomusou.io/hexo/https/</id>
    <published>2018-07-28T12:23:43.000Z</published>
    <updated>2018-07-28T08:14:52.791Z</updated>
    <content type="html"><![CDATA[<p>當 Chrome 在 68 版後會將沒有 https 網站標上 <code>不安全</code> 字樣，讓 blog 升級成 https 已經不能避免的課題，若你是使用 Hexo 且放在 GitHub，則可參考本文的方式。</p>
<a id="more"></a>
<h2 id="GoDaddy">GoDaddy</h2><hr>
<p><img src="/images/hexo/https/https000.png" alt="https000"></p>
<ol>
<li>到 GoDaddy 去設定自己的 domain，按 <code>DNS</code></li>
</ol>
<p><img src="/images/hexo/https/https001.png" alt="https001"></p>
<ol>
<li>原本 GitHub pages domain 是兩組 <code>192</code> 開頭的 ip，改成這 4 組 ip。</li>
</ol>
<blockquote>
<p>不會馬上生效，要等 1 小時以上</p>
</blockquote>
<h2 id="Hexo">Hexo</h2><hr>
<p><strong>_config.yml</strong></p>
<p><img src="/images/hexo/https/https002.png" alt="https002"></p>
<p>在 Hexo 根目錄的 <code>_config.yml</code> 下，將 <code>url</code> 改成 <code>https</code>。</p>
<p>重新 <code>hexo clean</code>、<code>hero generate</code> 與 <code>hexo deploy</code>。</p>
<h2 id="GitHub">GitHub</h2><hr>
<p><img src="/images/hexo/https/https003.png" alt="https003"></p>
<ol>
<li>進入 repository 的 <code>Settings</code></li>
</ol>
<p><img src="/images/hexo/https/https004.png" alt="https004"></p>
<ol>
<li>將 <code>Enforce HTTPS</code> 打勾</li>
</ol>
<blockquote>
<p>若不能打勾，有可能 GoDaddy 的設定還沒生效，或者 Hexo 還沒上傳重新編譯過的 <code>https</code> 版本</p>
</blockquote>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>由於 GitHub 的支援，要讓 blog 支援 https 已經非常簡單了</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[GitHub 現在已經內建支援 https]]>
    
    </summary>
    
      <category term="GitHub" scheme="https://oomusou.io/tags/GitHub/"/>
    
      <category term="Hexo" scheme="https://oomusou.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 Docker 安裝 PostgreSQL ?]]></title>
    <link href="https://oomusou.io/docker/postgres/"/>
    <id>https://oomusou.io/docker/postgres/</id>
    <published>2018-07-24T22:23:43.000Z</published>
    <updated>2018-07-31T01:50:15.231Z</updated>
    <content type="html"><![CDATA[<p>若要在 Mac 使用 PostgreSQL，最簡單的方式就是使用 Docker 。本文分別使用 <code>docker run</code> 與 <code>docker-compose</code> 兩種方式。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>Docker for Mac 18.03.1-ce-mac65 (24312)<br>PostgreSQL 10.3</p>
<h2 id="使用_docker_run">使用 docker run</h2><hr>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">run</span> --name MyPostgres -<span class="keyword">d</span> -p 5432:5432 -v ~/Postgres:/<span class="keyword">var</span>/lib/postgresql/data -<span class="keyword">e</span> POSTGRES_DB=eflab -<span class="keyword">e</span> POSTGRES_USER=admin -<span class="keyword">e</span> POSTGRES_PASSWORD='12345' postgres:latest</span><br></pre></td></tr></table></figure>
<p>使用 <code>docker run</code> 由 image 建立 container，當 Docker 發現本機沒有 image，會自動從 Docker Hub 下載。</p>
<p><code>—name</code>：替 container 取一個人能夠識別的名字 <code>MyPostgres</code> (若省略，Docker 會自動以亂數建立 )<br><code>-d</code> : <code>d</code>etach，建立 container 後，就脫離目前 process</p>
<p><code>-v</code> : <code>v</code>olume，PostgresSQL 新增的資料會寫在 container 內的 <code>/var/lib/postgresql/data</code> 目錄，會改 mapping 到 host 的 <code>~/Postgres</code>，如此 container 刪除後，資料仍然會留在 host </p>
<p><code>-p</code> : <code>p</code>ort mapping，host 與 container post 的對應，格式為 host port : container port<br><code>-e</code> : <code>e</code>nvironment，設定 PostgreSQL 所需要的環境變數</p>
<ul>
<li><code>POSTGRES_DB</code> : database 名稱</li>
<li><code>POSTGRES_USER</code> : 帳號</li>
<li><code>POSTGRES_PASSWORD</code> : 密碼</li>
</ul>
<p><code>postgress:latest</code> : image 名稱，其中 <code>latest</code> 為最新版的 image</p>
<p><img src="/images/docker/postgres/post000.png" alt="post000"></p>
<h2 id="使用_Docker-Compose">使用 Docker-Compose</h2><hr>
<p><code>docker run</code> 方式雖然直接，但需要搭配一堆參數才能執行，若能將這些參數先寫在文字檔內，只要下 <code>docker-compose up -d</code> 就可執行 container。</p>
<p><code>-d</code> : <code>d</code>etach，建立 container 後，就脫離目前 process</p>
<h3 id="Docker-compose-yml">Docker-compose.yml</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version: &#34;3&#34;&#10;&#10;services:&#10;  postgres:&#10;    image: postgres:latest&#10;    container_name: MyPostgres&#10;    volumes:&#10;      - $&#123;HOST_DIR&#125;:/var/lib/postgresql/data&#10;    expose:&#10;      - 5432&#10;    ports:&#10;      - $&#123;POSTGRES_PORT&#125;:5432&#10;    environment:&#10;      - POSTGRES_DB=$&#123;POSTGRES_DB&#125;&#10;      - POSTGRES_USER=$&#123;POSTGRES_USER&#125;&#10;      - POSTGRES_PASSWORD=$&#123;POSTGRES_PASSWORD&#125;</span><br></pre></td></tr></table></figure>
<p>第 1 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version: &#34;3&#34;</span><br></pre></td></tr></table></figure>
<p>使用 <code>version</code> 設定 <code>docker-compose.yml</code> 格式的版本。</p>
<p>因為 <code>docker-compose.yml</code> 的格式版本與 Docker 版本息息相關，若你要使用新版的 Docker 所提供的功能，在 <code>docker-compose.yml</code> 的版本就必須下的更細，如 <code>3.3</code>，在此只使用了 <code>docker-compose.yml</code> 基本功能而已，使用 <code>3</code> 即可。</p>
<p>第 3 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services:&#10;  postgres:</span><br></pre></td></tr></table></figure>
<p>使用 <code>services</code> 設定有哪些 service 要一起跑。</p>
<p><code>Docker-compose.yml</code> 理論上可以同時描述多個 service，也就是多個 container，如 .NET Core + PostgreSQL + Nginx + Redis 同時啟動，但本文只想使用 PostgreSQL 而已，因此僅建立  <code>postgres</code> service。</p>
<p>第 4 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postgres:&#10;  image: postgres:latest</span><br></pre></td></tr></table></figure>
<p>設定 <code>postgres</code> service，此名稱可自行建立。</p>
<ul>
<li><strong>image</strong> :  設定使用的 image。</li>
</ul>
<blockquote>
<p><code>latest</code> 表示最新版的 <code>postgres</code></p>
</blockquote>
<p>第 6 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: MyPostgres</span><br></pre></td></tr></table></figure>
<p>使用 <code>container_name</code> 設定 container 名稱。</p>
<blockquote>
<p>相當於 <code>docker run</code> 的 <code>--name</code></p>
</blockquote>
<p>第 7 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volumes:&#10;  - $&#123;POSTGRES_HOST_DIR&#125;:/var/lib/postgresql/data</span><br></pre></td></tr></table></figure>
<p>使用 <code>volumes</code> 設定 host 與 container 所對應的目錄，將來 PostgreSQL 所寫入資料，將寫入 host 目錄。</p>
<p><code>:</code> 左側為 host 目錄，右側為 container 內目錄。</p>
<blockquote>
<p>相當於 <code>docker run</code> 的 <code>-v</code></p>
</blockquote>
<p><code>POSTGRES_HOST_DIR</code> 將在 <code>.env</code> 中設定。</p>
<p>第 9 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expose:&#10;  - 5432</span><br></pre></td></tr></table></figure>
<p>使用 <code>expose</code> 設定 container 的 port。</p>
<p>第 11 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ports:&#10;  - $&#123;POSTGRES_PORT&#125;:5432</span><br></pre></td></tr></table></figure>
<p>使用 <code>ports</code> 設定 host 與 container 所 mapping 的 port。</p>
<p><code>:</code> 左側為 host 的 port，右側為 container 的 port。</p>
<blockquote>
<p>相當於 <code>docker run</code> 的 <code>-p</code></p>
</blockquote>
<p><code>POSTGRES_PORT</code> 將在 <code>.env</code> 中設定。</p>
<p>13 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">environment:&#10;    - POSTGRES_DB=$&#123;POSTGRES_DB&#125;&#10;    - POSTGRES_USER=$&#123;POSTGRES_USER&#125;&#10;    - POSTGRES_PASSWORD=$&#123;POSTGRES_PASSWORD&#125;</span><br></pre></td></tr></table></figure>
<p>設定 PostgreSQL 的 database、user 與 password，此為 PostgreSQL 所需要的環境變數。</p>
<blockquote>
<p>相當於 <code>docker run</code> 的 <code>-e</code></p>
</blockquote>
<p><code>POSTGRES_DB</code>、<code>POSTGRES_USER</code> 與 <code>POSTGRES_PASSWORD</code> 將在 <code>.env</code> 中設定。</p>
<h3 id="-env">.env</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">HOST_DIR=<span class="value">~/Postgres</span></span></span><br><span class="line"><span class="setting">POSTGRES_PORT=<span class="value"><span class="number">1234</span></span></span></span><br><span class="line"><span class="setting">POSTGRES_DB=<span class="value">eflab</span></span></span><br><span class="line"><span class="setting">POSTGRES_USER=<span class="value">admin</span></span></span><br><span class="line"><span class="setting">POSTGRES_PASSWORD=<span class="value"><span class="number">12345</span></span></span></span><br></pre></td></tr></table></figure>
<p>此為 <code>Docker-compose.yml</code> 所設定的環境變數，被獨立在 <code>.env</code> 中，可單獨設定，不用修改 <code>Docker-compose.yml</code>。</p>
<h3 id="Docker-compose_up">Docker-compose up</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up <span class="operator">-d</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>docker-compose up</code> 啟動 PostgreSQL。</p>
<p><code>-d</code> : <code>d</code>etach，建立 container 後，就脫離目前 process</p>
<p><img src="/images/docker/postgres/post001.png" alt="post001"></p>
<h3 id="Docker-compose_down">Docker-compose down</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>docker-compose down</span><br></pre></td></tr></table></figure>
<p>使用 <code>docker-compose down</code> 結束 PostgreSQL，並且刪除 container。</p>
<p><img src="/images/docker/postgres/post002.png" alt="post002"></p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>要在 Mac 使用 PostgreSQL，最簡單的方式就是使用 Docker</li>
<li><code>docker-run</code> 與 <code>Docker-Compose</code> 都可以啟動 PostgreSQL，實務上建議使用 <code>Docker-Compose</code>，將變數寫在 <code>.env</code> 中，這樣可使用 <code>docker-compose up -d</code> 就可啟動 PostgreSQL，<code>docker-compose down</code> 就可結束 PostgreSQL，不用再擔心參數問題</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/PostgresDocker" target="_blank" rel="external">GitHub</a> 上找到</p>
]]></content>
    <summary type="html">
    <![CDATA[在 Mac 最簡單使用 PostgreSQL 方式就是使用 Docker]]>
    
    </summary>
    
      <category term="Docker" scheme="https://oomusou.io/tags/Docker/"/>
    
      <category term="PostgreSQL" scheme="https://oomusou.io/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入探討 C# 之 Extension Method]]></title>
    <link href="https://oomusou.io/csharp/extension-method/"/>
    <id>https://oomusou.io/csharp/extension-method/</id>
    <published>2018-07-22T12:23:43.000Z</published>
    <updated>2018-07-22T10:52:27.838Z</updated>
    <content type="html"><![CDATA[<p>C# 3 的 Extension Method 是很了不起的發明，讓我們在不修改原本 source code 的前提下，就能為 class 增加新 method，實現開放封閉原則，尤其對於 .NET Framework 或 package 的擴展特別有效。</p>
<p>事實上 Extension Method 在 Functional Programming 下另有妙用，讓我們輕易實現 Function Composition。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>.NET Core 2.1<br>C# 7.2<br>Rider 2018.1.3</p>
<h2 id="Extension_Method">Extension Method</h2><hr>
<p>首先來看 Extension Method 最標準的應用。</p>
<p><strong>Program.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Enumerable</span><br><span class="line">                .Range(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">                .Select(x =&gt; x * <span class="number">2</span>)</span><br><span class="line">                .ToList()</span><br><span class="line">                .ForEach(x =&gt; Console.WriteLine(x.ToString()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先使用 <code>Enumerable.Range()</code> 產生 <code>1, 2, 3</code>，再使用 <code>Select()</code> 變成 <code>2, 4, 6</code>，最後使用 <code>ForEach()</code> 印出來。</p>
<p>但中間出現了一個很詭異的 <code>ToList()</code>。</p>
<p>原因是因為 <code>IEnumerable</code> 沒有 <code>ForEach()</code>，只有 <code>List</code> 才有 <code>ForEach()</code>，因此我們必須先 <code>ToList()</code>。</p>
<p>但就語意來說，這是很怪的，<code>IEnumerable</code> 自帶 <code>Aggregate()</code>，為什麼卻沒有提供更常用的 <code>ForEach()</code> 呢 ?</p>
<p>既然 .NET Framework 沒有，我們就來替 <code>IEnumerable</code> 打造一個 <code>ForEach()</code> 吧。</p>
<p><strong>Extensions.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Extensions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">void</span> ForEach&lt;T&gt;(<span class="keyword">this</span> IEnumerable&lt;T&gt; source, Action&lt;T&gt; action)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (T element <span class="keyword">in</span> source)</span><br><span class="line">                action(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ForEach()</code> 第一個參數為 <code>this IEnumerable&lt;T&gt;</code>，注意特別加了 <code>this</code>，表示我們要為 <code>IEnumerable</code> 提供 <code>ForEach()</code> Extension Method。</p>
<p>且 Extension Method 必須都為 static method。</p>
<p><strong>Program.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Enumerable</span><br><span class="line">                .Range(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">                .Select(x =&gt; x * <span class="number">2</span>)</span><br><span class="line">                .ForEach(x =&gt; Console.WriteLine(x.ToString()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之後我們就能將奇怪的 <code>ToList()</code> 拿掉了，這樣的語意是不是更好呢 ?</p>
<blockquote>
<p>Extension Method 讓我們對 .NET Framework 或 package 加以擴充，用起來好像是內建的method 一樣，只要做兩件事情 :</p>
<ol>
<li>使用 static method</li>
<li>第一個參數為該 class 或 interface 型別，並加上 <code>this</code> 修飾</li>
</ol>
</blockquote>
<h2 id="Function_Composition">Function Composition</h2><hr>
<p>Function Composition 是 FP 的招牌菜，強調藉由眾多的小 functional 組合成大 function，而非傳統 imperative 寫法，總是寫出數百行的 method，且這些 method 幾乎是量身定做，不只重複使用的機會很低，且因為行數過多很難維護，也難以單元測試。</p>
<p><strong>Program.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> ConsoleApp.Email;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> john = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>);</span><br><span class="line">            <span class="function"><span class="keyword">string</span> <span class="title">EmailFor</span>(<span class="params">Person person</span>) </span>=&gt; AppendDomain(AbbreviateName(person));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> email = EmailFor(john);</span><br><span class="line">            </span><br><span class="line">            Console.WriteLine(email);</span><br><span class="line">            <span class="comment">// jodo@gmail.com</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EmailFor()</code> 能根據 user 的 <code>姓</code> 與 <code>名</code> 自動產生 email。</p>
<p>11 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">EmailFor</span>(<span class="params">Person person</span>) </span>=&gt; AppendDomain(AbbreviateName(person));</span><br></pre></td></tr></table></figure>
<p><code>EmailFor()</code> 為 C# 7 的 Local Function，藉由 <code>AbbreviateName()</code> 與 <code>AppendDomain()</code> 組合出新的 <code>EmailFor()</code>，這也就是所謂的 Function Composition : <code>h = fog = f(g)</code>，其中 <code>g</code> 就是 <code>AbbreviateName()</code>，而 <code>f</code> 就是 <code>AppendDomain()</code>。</p>
<p>這種數學式的 Function Composition 雖然重複使用性極高，但並不容易閱讀，程式碼必須 <code>由右而左</code>，違反一般人 <code>由左至右</code> 的閱讀習慣，因此想改用 Function Pipeline 方式變成 <code>由左至右</code>。</p>
<p><strong>Email.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Email</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">AbbreviateName</span>(<span class="params"><span class="keyword">this</span> Person person</span>)</span><br><span class="line">            </span>=&gt; Abbreviate(person.FirstName) + Abbreviate(person.LastName);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">AppendDomain</span>(<span class="params"><span class="keyword">this</span> <span class="keyword">string</span> localPart</span>) </span>=&gt; $<span class="string">"&#123;localPart&#125;@gmail.com"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">Abbreviate</span>(<span class="params"><span class="keyword">string</span> s</span>) </span>=&gt; s.Substring(<span class="number">0</span>, <span class="number">2</span>).ToLower();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>將 <code>AbbreviateName()</code> 與 <code>AppendDomain()</code> 的第一個參數都改加上 <code>this</code>，搖身一變成為 Extension Method。</p>
<p><strong>Program.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> ConsoleApp.Email;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> email = </span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>)</span><br><span class="line">                    .AbbreviateName()</span><br><span class="line">                    .AppendDomain();</span><br><span class="line">            </span><br><span class="line">            Console.WriteLine(email);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>則原本的 <code>EmailFor()</code> Local Function 就不需要了，只要將 <code>Person</code> new 後，直接如 LINQ 般去 <code>AbbreviateName()</code> 與 <code>AppendDomain()</code>，這種風格維持了 <code>由左至右</code> 的閱讀習慣，非常清楚。</p>
<blockquote>
<p>只要將第一個參數加上 <code>this</code> 修飾成為 Extenstion Method 後，就可由 Function Composition 改成 Function Pipeline 風格</p>
</blockquote>
<h2 id="Refactoring">Refactoring</h2><hr>
<p>若 Legacy code 只用了 Function Composition，可以使用 Rider 幫我們重構成 Function Pipeline。</p>
<p><img src="/images/csharp/extension-method/em000.png" alt="em000"></p>
<p>Legacy code 並沒有使用 Extension Method。</p>
<p><img src="/images/csharp/extension-method/em001.png" alt="em001"></p>
<ol>
<li>將 cursor 放在 method 上</li>
<li>按熱鍵 <code>⌃ + T</code>，選擇 <code>Convert Static Method to Extension</code></li>
</ol>
<p><img src="/images/csharp/extension-method/em002.png" alt="em002"></p>
<ul>
<li>Rider 自動幫我們將第一個參數加上 <code>this</code></li>
</ul>
<p><img src="/images/csharp/extension-method/em003.png" alt="em003"></p>
<ol>
<li>使用端會重構成 Function Pipeline</li>
</ol>
<p><img src="/images/csharp/extension-method/em004.png" alt="em004"></p>
<p><code>EmailFor</code> 與 <code>john</code> 可以進一步 Inline 掉。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>Function Composition 與 Function Pipeline 講的是同一件事情，只是 Function Composition 偏數學，採用 <code>由右至左</code>，而 Function Pipeline 偏閱讀習慣，採用 <code>由左至右</code></li>
<li>Funciton Compostion 與 Function Pipeline 是 FP 極關鍵部分，以前總以為 C# 沒有支援，因此無法使用 C# 寫 FP，有了 Extension Method，C# 就能很輕鬆的實踐 FP</li>
<li>Rider 支援 <code>Convert static method to Extension</code>，讓我們快速重構成 Extension Method，再加上 <code>Inline Method</code> 與 <code>Inline Variable</code>，最後就會重構出 Function Pipeline</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/CSharpFunctionComposition" target="_blank" rel="external">GitHub</a> 與 <a href="https://github.com/oomusou/CSharpExtensionMethod" target="_blank" rel="external">GitHub</a> 上找到</p>
<h2 id="Reference">Reference</h2><hr>
<p>Enrico Buonanno, <a href="https://www.manning.com/books/functional-programming-in-c-sharp" target="_blank" rel="external">Functional Programming in C#</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Extension Method 是 C# 的獨門招式]]>
    
    </summary>
    
      <category term="C#" scheme="https://oomusou.io/tags/C/"/>
    
      <category term="Refactoring" scheme="https://oomusou.io/tags/Refactoring/"/>
    
      <category term="Rider" scheme="https://oomusou.io/tags/Rider/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 Rider 使用 Vim ?]]></title>
    <link href="https://oomusou.io/rider/vim/"/>
    <id>https://oomusou.io/rider/vim/</id>
    <published>2018-07-21T12:23:43.000Z</published>
    <updated>2018-07-21T15:34:18.592Z</updated>
    <content type="html"><![CDATA[<p>Vim 是一個歷史悠久的編輯器，完全使用鍵盤操作，就算你使用 IDE，但其 <code>鍵盤操作</code> 的精神卻可以保留下來，讓你在開發時完全不需要摸到滑鼠與觸控板，而使用鍵盤全速開發。</p>
<p>在 Rider 只要安裝以下三個套件，就能順利在 Rider 使用 Vim，也適用於其他 JetBrains 產品。</p>
<a id="more"></a>
<h2 id="Verison">Verison</h2><hr>
<p>macOS High Sierra 10.13.6<br>Rider 2018.1.3</p>
<h2 id="IdeaVim">IdeaVim</h2><hr>
<p><img src="/images/rider/vim/extension003.png" alt="extension003"></p>
<p>由 JetBrains 自己所開發的 Vim 套件，讓你可以在 JetBrains 使用 Vim 熱鍵。</p>
<h2 id="Relative_Line_Numbers">Relative Line Numbers</h2><hr>
<p><img src="/images/rider/vim/extension004.png" alt="extension004"></p>
<p>Vim 的重要精神就是不用選取就可操作，所以必須知道目前 cursor 的相對行數。</p>
<p><img src="/images/rider/vim/extension005.png" alt="extension005"></p>
<p>裝了之後除了原本的 <code>行數</code>，還多了一排 <code>相對行數</code>。</p>
<h2 id="IdeaVimExtension">IdeaVimExtension</h2><hr>
<p><img src="/images/rider/vim/extension000.png" alt="extension000"></p>
<p>實務上在寫 <code>註解</code> 或單元測試的 <code>method 名稱</code> 時，有可能會使用中文，此時若切換回 Vim 的 Normal Mode，又必須重新切回 <code>英文輸入法</code> 才能下指令，非常不方便。</p>
<p>IdeaVimExtension 能在切換到 Normal Mode 時，自動切換到回 <code>英文輸入法</code>。</p>
<h3 id="編輯_-ideavimrc">編輯 .ideavimrc</h3><p>Rider 的 Vim 預設會執行 home directory 的 <code>.ideavimrc</code>，須在此啟動 IdeaVimExtension。</p>
<p><strong>.ideavimrc</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> keep-<span class="keyword">english</span>-<span class="operator">in</span>-<span class="keyword">normal</span></span><br></pre></td></tr></table></figure>
<p>在 <code>.ideavimrc</code> 加上這一行</p>
<p><img src="/images/rider/vim/extension002.png" alt="extension002"></p>
<p>再次重新啟動 Rider 後，當切換到 Normal Mode 時，就都會是 <code>英文輸入法</code> 。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>此技巧在 JetBrains 其他工具也適用</li>
<li>Rider 重構 + Vim 編輯，讓我們同時享受 IDE 與 Editor 的優點，等於是倚天劍 + 屠龍刀</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[完全使用鍵盤高速寫 code]]>
    
    </summary>
    
      <category term="Rider" scheme="https://oomusou.io/tags/Rider/"/>
    
      <category term="Vim" scheme="https://oomusou.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rider Refactoring 之 Extract Local Function]]></title>
    <link href="https://oomusou.io/rider/extract-local-function/"/>
    <id>https://oomusou.io/rider/extract-local-function/</id>
    <published>2018-07-21T12:23:43.000Z</published>
    <updated>2018-07-21T15:04:49.607Z</updated>
    <content type="html"><![CDATA[<p>Local Function 是 C# 7 支援 FP 的重要功能，除了比 C# 3 的 Func 與 Action 可讀性高，速度也更快，因此建議全面使用 Local Function 取代 Func 與 Action。</p>
<p>透過 Rider，我們也可將 legacy code 快速重構成有 FP 風格的 Local Function。<br><a id="more"></a></p>
<h2 id="Version">Version</h2><p>macOS High Sierra 10.13.6<br>.NET Core 2.1<br>Rider 2018.1.3</p>
<h2 id="重構前">重構前</h2><hr>
<p><strong>Program.cs</strong></p>
<p><img src="/images/rider/extract-local-function/local000.png" alt="local000"></p>
<ol>
<li>傳統我們在寫 LINQ 時，會將 Lambda 寫在 <code>Where()</code> 內，若能將 Lambda 抽成 Local Function，則可讀性更高</li>
</ol>
<h2 id="Introduce_Variable">Introduce Variable</h2><hr>
<p><strong>Program.cs</strong></p>
<p><img src="/images/rider/extract-local-function/local001.png" alt="local001"></p>
<ol>
<li>選擇要抽的 Lambda</li>
</ol>
<p><img src="/images/rider/extract-local-function/local002.png" alt="local002"></p>
<ol>
<li>按熱鍵 <code>⌃ + T</code>，選擇 <code>Introduce Variable</code></li>
</ol>
<p><img src="/images/rider/extract-local-function/local004.png" alt="local002"></p>
<ol>
<li>Rider 會自動抽出 Func，不過卻也建議你改用 Local Function</li>
</ol>
<blockquote>
<p>Q : 為什麼 Rider 不直接抽成 Local Function ?</p>
</blockquote>
<p><img src="/images/rider/extract-local-function/local003.png" alt="local003"></p>
<p>因為 Local Function 屬於 C# 7 支援的新功能，只有當你選擇 C# 7 以上時，才會建議使用 Local Function。</p>
<h2 id="To_Local_Function">To Local Function</h2><hr>
<p><img src="/images/rider/extract-local-function/local005.png" alt="local005"></p>
<ol>
<li>將 cursor 放在 <code>predicate</code> 上</li>
<li>按熱鍵 <code>⌥ + ↩</code>，選擇 <code>To local function</code> </li>
</ol>
<p><img src="/images/rider/extract-local-function/local006.png" alt="local006"></p>
<p>Rider 會將 Local Function 轉型成 Func，這是不需要的，Rider 也已經反灰提示這是多餘的。</p>
<ol>
<li>將 cursor 放在反灰之處</li>
<li>按熱鍵 <code>⌥ + ↩</code>，選擇 <code>Remove redundant code in file</code> </li>
</ol>
<h2 id="Rename_Variable">Rename Variable</h2><hr>
<p><img src="/images/rider/extract-local-function/local007.png" alt="local007"></p>
<p>Rider 預設抽出的 Local Function 名稱都是 <code>Predicate</code>，可讀性不高，需要進一步重構</p>
<ol>
<li>將 cursor 放在 <code>Predicate</code> 上</li>
<li>按熱鍵 <code>⌥ + ↩</code>，選擇 <code>Rename</code> </li>
</ol>
<p><img src="/images/rider/extract-local-function/local008.png" alt="local008"></p>
<ol>
<li>重新命名為 <code>IsOdd</code></li>
</ol>
<h2 id="重構後">重構後</h2><hr>
<p><img src="/images/rider/extract-local-function/local009.png" alt="local009"></p>
<p>如此的程式碼，可讀性就很高。</p>
<ol>
<li><code>original</code> 陣列經過 <code>Where()</code> ，再經過 <code>ForEach()</code>，這正是 FP 所謂的 Function Pipeline</li>
<li><code>Where(IsOdd)</code> 可以明顯看出要 where 的是 <code>奇數</code>，<code>ForEach(WriteLine)</code> 可以看出 writeline 要 foreach，而 <code>WriteLine()</code> 與 <code>IsOdd()</code> 又各自是小小的 Local Function 構成，這正是 FP 所謂的 Function Composition</li>
</ol>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>要抽成 Local Function，直覺會想使用 Rider 的 <code>Extract Method</code>，但因為在 FP 觀念中，Function 就是 First-Class Value，所以在 Rider 要使用 <code>Introduce Variable</code>，而不是 <code>Extract Method</code></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[重構成 C# 7 的 Local Function]]>
    
    </summary>
    
      <category term="Refactoring" scheme="https://oomusou.io/tags/Refactoring/"/>
    
      <category term="Rider" scheme="https://oomusou.io/tags/Rider/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 .NET Core 使用 NUnit 與 NSubstitute ?]]></title>
    <link href="https://oomusou.io/nunit/setup/"/>
    <id>https://oomusou.io/nunit/setup/</id>
    <published>2018-07-10T13:23:43.000Z</published>
    <updated>2018-07-10T03:12:04.938Z</updated>
    <content type="html"><![CDATA[<p>在 <code>單元測試的藝術</code> 一書中，使用的是 <code>NUnit</code> 與 <code>NSubstitute</code>，但 .NET Core SDK 預設只提供 <code>MSTest</code> 與 <code>xUnit</code>，該如何在 .NET Core 使用我們熟悉的 <code>NUnit</code> 與 <code>NSubstitute</code> 呢 ?</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.4<br>.NET Core 2.1<br>NUnit 3.10.1<br>NSubstitute 3.1.0<br>Rider 2018.1.3</p>
<h2 id="Symptons">Symptons</h2><hr>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet <span class="keyword">new</span> -l</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>-l</strong> : <code>l</code>ist ，使用 <code>dotnet new</code> 加上 <code>-l</code> 參數，將列出目前系統所安裝的所有 project template。</li>
</ul>
<p><img src="/images/nunit/setup/setup000.png" alt="nunit000"></p>
<p>.NET Core SDK 預設只提供 <code>MSTest</code> 與 <code>xUnit</code> 的 project template。</p>
<p><img src="/images/nunit/setup/setup001.png" alt="nunit001"></p>
<ul>
<li>因為 .NET Core SDK 只有 <code>MSTest</code> 與 <code>XUnit</code>，因此 Rider 也只支援 <code>MSTest</code> 與 <code>xUnit</code></li>
</ul>
<h2 id="NUnit">NUnit</h2><hr>
<p><img src="/images/nunit/setup/setup002.png" alt="nunit002"></p>
<p>事實上在 .NET Core 官網的 <a href="https://github.com/dotnet/templating/wiki/Available-templates-for-dotnet-new" target="_blank" rel="external">Available templates for dotnet new</a>，還準備了不少其他 project template 可供下載，其中也包含了 <code>NUnit</code>。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet new -<span class="tag">i</span> <span class="string">"NUnit3.DotNetNew.Template::*"</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/nunit/setup/setup003.png" alt="nunit003"></p>
<p><img src="/images/nunit/setup/setup004.png" alt="nunit004"></p>
<ol>
<li>安裝完就會出現 <code>NUnit 3</code> project template</li>
</ol>
<p><img src="/images/nunit/setup/setup005.png" alt="nunit005"></p>
<ol>
<li>安裝完後，Rider 也會出現 <code>NUnit 3 Test Project</code></li>
</ol>
<h2 id="Project_Reference">Project Reference</h2><hr>
<p>將 Class Library 的 project reference 加到 Unit Test 專案。</p>
<p><img src="/images/nunit/setup/setup007.png" alt="nunit007"></p>
<ol>
<li>選擇 Unit Test 專案</li>
<li>按滑鼠右鍵選擇 <code>Add</code></li>
<li>選擇 <code>Add Reference</code></li>
</ol>
<p><img src="/images/nunit/setup/setup008.png" alt="nunit008"></p>
<ol>
<li>選擇 <code>ClassLib</code></li>
<li>按 <code>OK</code> 繼續</li>
</ol>
<h2 id="NSubstitute">NSubstitute</h2><hr>
<p>除了 <code>NUnit</code> 外，單元測試另外一個要角就是 <code>NSubstitute</code>，這要另外安裝。</p>
<p><img src="/images/nunit/setup/setup009.png" alt="nunit009"></p>
<ol>
<li>選擇 Unit Test 專案</li>
<li>按滑鼠右鍵選擇 <code>Manage NuGet Packages</code></li>
</ol>
<p><img src="/images/nunit/setup/setup006.png" alt="nunit006"></p>
<ol>
<li>在 NuGet 下輸入 <code>NSubstitute</code></li>
<li>選擇 <code>NSubstitute</code></li>
<li>在 Unit Test 專案下安裝 <code>NSubstitute</code></li>
</ol>
<h2 id="Parallel_Test">Parallel Test</h2><hr>
<p><code>NUnit</code> 預設並不是以 parallel 進行單元測試，而是以 sequential 方式，也就是 <code>一個單元測試執行完，才會進行下一個單元測試</code>，而不是每個單元測試平行執行。</p>
<p>這種方式雖然安全，但有幾個缺點：</p>
<ol>
<li>執行速度較慢，沒有完全發揮多核心 CPU 的優勢</li>
<li>Jenkins 會以 parallel 方式執行單元測試，因此每個單元測試之間不能相依，讓本機與 Jenkins 環境相同</li>
</ol>
<p><strong>AssemblyInfo.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> NUnit.Framework;</span><br><span class="line"></span><br><span class="line">[assembly:Parallelizable(ParallelScope.All)]</span><br></pre></td></tr></table></figure>
<p>在 Unit Test 專案下新增 <code>AssemblyInfo.cs</code>，對整個 Unit Test assembly 增加 <code>NUnit</code> 的 <code>Parallelizable</code> attribute，如此每個 test method 都會以 parallel 方式執行單元測試。</p>
<p><img src="/images/nunit/setup/setup010.png" alt="nunit010"></p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>.NET Core SDK 預設沒有支援 <code>NUnit</code>，但只要自行透過 <code>dotnet new -i</code>，即可安裝 <code>NUnit</code> project template</li>
<li><code>NSubstitute</code> 以 NuGet package 形式存在，必須另外安裝</li>
<li><code>NUnit</code> 預設以 sequential 方式執行 Unit Test，不僅沒發揮多核心 CPU 威力，也與 Jenkins 執行環境不同，建議在 Unit Test 專案增加 <code>AssemblyInfo.cs</code>，對整個 Unit Test assembly 增加 <code>Parallelizable(ParallelScope.All)</code> attribute，如此才會以 parallel 方式執行單元測試，也能提早發現 test method 彼此相依可能造成的問題</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/NUnitCore" target="_blank" rel="external">GitHub</a> 上找到</p>
]]></content>
    <summary type="html">
    <![CDATA[需要另外安裝 NUnit Project Template]]>
    
    </summary>
    
      <category term=".NET Core" scheme="https://oomusou.io/tags/NET-Core/"/>
    
      <category term="NSubstitute" scheme="https://oomusou.io/tags/NSubstitute/"/>
    
      <category term="NUnit" scheme="https://oomusou.io/tags/NUnit/"/>
    
  </entry>
  
</feed>
