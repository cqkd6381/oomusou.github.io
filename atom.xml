<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[點燈坊]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="https://oomusou.io/"/>
  <updated>2018-08-04T11:00:52.704Z</updated>
  <id>https://oomusou.io/</id>
  
  <author>
    <name><![CDATA[真 OO無双]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Refactoring to LINQ => ForEach]]></title>
    <link href="https://oomusou.io/linq/foreach/"/>
    <id>https://oomusou.io/linq/foreach/</id>
    <published>2018-08-04T12:23:43.000Z</published>
    <updated>2018-08-04T11:00:52.704Z</updated>
    <content type="html"><![CDATA[<p>LINQ 是 C# 3 實現 FP 重要里程碑，提供大量的 Operator，讓我們以 Pure Function 將 data 以 Dataflow 與 Pipeline 方式實現。本系列將先以 Imperative 實作，然後再重構成 FP，最後再重構成 LINQ Operator，並參考 LINQ source code 的實現方式。</p>
<p>首先從最基本的 <code>ForEach</code> Operator 談起。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>.NET Core 2.1<br>C# 7.2<br>Rider 2018.1.4</p>
<h2 id="User_Story">User Story</h2><hr>
<p>在 List 中有一堆名字，想要在 console 顯示每個名字。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> names = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Ben"</span>,</span><br><span class="line">                <span class="string">"Jafar"</span>,</span><br><span class="line">                <span class="string">"Matt"</span>,</span><br><span class="line">                <span class="string">"Priya"</span>,</span><br><span class="line">                <span class="string">"Brian"</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Imperative_:_for">Imperative : for</h2><hr>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> names = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Ben"</span>,</span><br><span class="line">                <span class="string">"Jafar"</span>,</span><br><span class="line">                <span class="string">"Matt"</span>,</span><br><span class="line">                <span class="string">"Priya"</span>,</span><br><span class="line">                <span class="string">"Brian"</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> counter = <span class="number">0</span>; counter &lt; names.Count; counter++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(names[counter]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>19 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> counter = <span class="number">0</span>; counter &lt; names.Count; counter++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(names[counter]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最直覺的方式 (其實應該說被制約的方式)， 就是透過 List 的 Indexer 將 List 的 item 取出來，並透過 <code>for</code> loop 去執行 <code>Console.WriteLine()</code>。</p>
<h2 id="Imperative_:_foreach">Imperative : foreach</h2><hr>
<p><img src="/images/linq/foreach/foreach000.png" alt="foreach000"></p>
<p>此時 Rider 已經提出警告，建議改用 <code>foreach</code></p>
<p><img src="/images/linq/foreach/foreach001.png" alt="foreach001"></p>
<ol>
<li>按熱鍵 <code>⌥ + ↩</code>，選擇 <code>Convert to foreach</code></li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> names = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Ben"</span>,</span><br><span class="line">                <span class="string">"Jafar"</span>,</span><br><span class="line">                <span class="string">"Matt"</span>,</span><br><span class="line">                <span class="string">"Priya"</span>,</span><br><span class="line">                <span class="string">"Brian"</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> name <span class="keyword">in</span> names)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>19 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> name <span class="keyword">in</span> names)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重構成 <code>foreach</code> 後，就不必使用 <code>counter</code> 變數，也不用考慮 <code>counter++</code> 寫錯，<code>for</code> loop 的 counter 控制，是常見的 bug 來源，所以重構成 <code>foreach</code> 絕對比 <code>for</code> 來得好。</p>
<p>且 <code>foreach</code> 的語意也比 <code>for</code> 清楚 ，因為不用看到 counter 實作細節。</p>
<h2 id="FP_:_Higher_Order_Function">FP : Higher Order Function</h2><hr>
<p>實務上這種 <code>foreach</code> 天天都要用到，但用 <code>foreach</code> 這種 statement 寫法，重複使用能力為 0，就每天都要不斷的寫 <code>foreach</code>。</p>
<p>若我們能將 <code>foreach</code> 抽成 <code>ForEach()</code> Higher Order Function，我們就能不斷 reuse <code>ForEach()</code>，只要將不同的商業邏輯以 function 傳進 <code>ForEach()</code> 即可。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> names = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Ben"</span>,</span><br><span class="line">                <span class="string">"Jafar"</span>,</span><br><span class="line">                <span class="string">"Matt"</span>,</span><br><span class="line">                <span class="string">"Priya"</span>,</span><br><span class="line">                <span class="string">"Brian"</span></span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            names.MyForEach(name =&gt; Console.WriteLine(name));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> MyForEach&lt;T&gt;(<span class="keyword">this</span> List&lt;T&gt; list, Action&lt;T&gt; action)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> iter <span class="keyword">in</span> list)</span><br><span class="line">            &#123;</span><br><span class="line">                action(iter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>22 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> MyForEach&lt;T&gt;(<span class="keyword">this</span> List&lt;T&gt; list, Action&lt;T&gt; action)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> iter <span class="keyword">in</span> list)</span><br><span class="line">    &#123;</span><br><span class="line">        action(iter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己以 <code>MyForEach()</code> 實作出 <code>foreach</code> 的 Higher Order Function 版本。</p>
<p>第 9 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.MyForEach(name =&gt; Console.WriteLine(name));</span><br></pre></td></tr></table></figure>
<p>原來的 <code>foreach</code> statement 重構成 <code>MyForEach()</code> Higher Order Function 版本，只要將 <code>Console.WriteLine()</code> 改用 Lambda 傳入 <code>MyForEach()</code> 即可，如此 <code>foreach</code> 就能被 reuse 了。</p>
<p>不過 C# 在此可能感受不到 FP 所謂的 Dataflow 與 Pipeline，就語意而言，只能說我們為 List 寫了一個新 method : <code>MyForEach()</code> ，也就是 C# 所謂的 Extension Method，這符合傳統 C# 的 OOP 思維。</p>
<p>他山之石可以攻錯，我們來看看 F# 語法。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"Ben"</span>; <span class="string">"Jafar"</span>; <span class="string">"Matt"</span>; <span class="string">"Priya"</span>; <span class="string">"Brian"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> MyForEach action list = </span><br><span class="line">    <span class="keyword">for</span> iter <span class="keyword">in</span> list <span class="keyword">do</span></span><br><span class="line">        action iter</span><br><span class="line">names </span><br><span class="line">|&gt; MyForEach (printfn <span class="string">"%A "</span>)</span><br></pre></td></tr></table></figure>
<p><code>names</code> 為 List，<code>myForEach()</code> 為自己實作的 <code>ForEach()</code> Higher Order function，若不懂 F# 語法先略過細節沒關係。</p>
<p><code>|&gt;</code> 為 pipeline，所以可以明顯看出其語意為 <code>names</code> data 以 Dataflow 與 Pipeline 方式傳給 <code>myForEach()</code> 執行 <code>printfn()</code>。</p>
<p>但 C# 並沒有特別提供 <code>|&gt;</code> 這種 pipeline 符號，而是繼續使用 OOP 的 <code>.</code> 。</p>
<p><code>.</code> 雖然方便，但心裡要知道，這裡的 <code>.</code> 並不是 OOP 的 method，而是 FP 的 Dataflow 與 Pipeline，只是也使用了 <code>.</code> 為符號，其本質是 F# 的 <code>|&gt;</code>，<code>.</code> 算是 <code>|&gt;</code> 的 syntax sugar。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> MyForEach&lt;T&gt;(<span class="keyword">this</span> List&lt;T&gt; list, Action&lt;T&gt; action)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> iter <span class="keyword">in</span> list)</span><br><span class="line">    &#123;</span><br><span class="line">        action(iter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再舉例另外一個例子證明 <code>.</code> 並非 OOP 的 method，而是 FP 的 Pipeline。</p>
<p>我們實現 <code>MyForEach()</code> 時，並不是寫在 <code>List</code> class 內，而是透過 static method + this 參數成為 Extenstion Method，也就是<code>List</code> data 與  <code>MyForEach()</code> logic 是徹底分離，而非如 OOP 將 data 與 logic 寫在 <code>List</code> class 內，也再次證明 Extension Method 是 C# 實踐 Pipeline 的手法，而 <code>.</code> 只是 syntax sugar，其本質是 FP 的 Pipeline。</p>
<h2 id="IEnumrable">IEnumrable</h2><hr>
<p><img src="/images/linq/foreach/foreach002.png" alt="foreach002"></p>
<p>當初我們只是想為了 List 重構，所以 Extension Method 的型別只用了 List，Rider 提出建議：<code>List&lt;T&gt; 其實可以重構成 IEnumerable&lt;T&gt;</code>，如此 <code>MyForEach()</code> 重複使用能力更高。</p>
<p><img src="/images/linq/foreach/foreach003.png" alt="foreach003"></p>
<ol>
<li>將 cursor 放在 <code>List</code> 上，按熱鍵 <code>⌥ + ↩</code>，選擇 <code>Make parameter type IEnumerable&lt;T&gt;</code></li>
</ol>
<p><img src="/images/linq/foreach/foreach005.png" alt="foreach005"></p>
<ol>
<li>將 <code>List&lt;T&gt;</code> 重構成 <code>IEnumerable&lt;T&gt;</code>。</li>
</ol>
<h2 id="Method_Group">Method Group</h2><hr>
<p><img src="/images/linq/foreach/foreach008.png" alt="foreach008"></p>
<p>Rider 建議將 Lambda 重構成 Method Group。</p>
<p><code>MyForEach()</code> 後接 Lambda 天經地義，但若 function 的型別定義的很清楚，讓 compiler 可以找到正確 signature 的 Overloading method，則不用寫 Lambda，傳入 method 名稱即可，這就是 Method Group，會讓 FP 寫法更加精簡。</p>
<p><code>MyForEach()</code> 很明確定義了 <code>Action&lt;T&gt;</code>，就只有一個 input 參數的 function，因此 compiler 有足夠的資訊找到 <code>Console.WriteLine()</code> 正確的 Overloading 版本，因此適合重構成 Method Group。</p>
<p><img src="/images/linq/foreach/foreach004.png" alt="foreach003"></p>
<ol>
<li>將 cursor 放在 <code>WriteLine</code> 上，按熱鍵 <code>⌥ + ↩</code>，選擇 <code>Replace with method group</code></li>
</ol>
<p><img src="/images/linq/foreach/foreach006.png" alt="foreach006"></p>
<ol>
<li>只要傳入 Method 名稱即可，不用寫 Lambda</li>
</ol>
<h2 id="Using_static">Using static</h2><hr>
<p>其實目前的 <code>Console.WriteLine</code> 已經非常精簡，可讀性也高，但 C# 6 提供了 <code>using static</code>，可以讓你寫出更 FP 風格的 code。</p>
<p><img src="/images/linq/foreach/foreach007.png" alt="foreach007"></p>
<ol>
<li>將 cursor 放在 <code>Console</code> 上，按熱鍵 <code>⌥ + ↩</code>，選擇 <code>Import static members</code></li>
</ol>
<p><img src="/images/linq/foreach/foreach009.png" alt="foreach009"></p>
<ol>
<li>將 <code>System.Console</code> 使用 <code>using static</code></li>
<li><code>MyForEach()</code> 只要傳入 <code>WriteLine</code> 即可，更像是 function</li>
</ol>
<h2 id="LINQ_:_ForEach">LINQ : ForEach</h2><hr>
<p>其實 <code>ForEach()</code> 這種很普遍的東西，在 LINQ 早已內建，我們改用 LINQ 版本。</p>
<p><img src="/images/linq/foreach/foreach010.png" alt="foreach010"></p>
<ol>
<li>直接使用 LINQ 的 <code>ForEach()</code>，將自己寫的 <code>MyForEach()</code> 刪除</li>
</ol>
<h2 id="LINQ_如何實踐_?">LINQ 如何實踐 ?</h2><hr>
<p><img src="/images/linq/foreach/foreach011.png" alt="foreach011"></p>
<p>我們來看看 LINQ 的 source code 如何實踐 <code>ForEach()</code> ?</p>
<p>一開始對 <code>action</code> 進行判斷，若沒有則拋出 exception。</p>
<p><code>action</code> 也搭配 <code>for</code> 進行，跟我們使用 <code>foreach</code> 類似。</p>
<blockquote>
<p>Q : 為什麼 <code>ForEach()</code> 是在 <code>List</code> class ? 而不是以 Extension Method 實現 ?</p>
</blockquote>
<p>這的確是 LINQ 設計上的好問題，LINQ 並沒有選擇將 <code>ForEach()</code> 以 Extension Method 對 <code>IEnumerable</code> 實作，而是直接寫在 <code>List</code> class 內。</p>
<p>這個設計也使得我們要使用 <code>ForEach()</code> 時，一定得 <code>ToList()</code> 成 List 才能使用。</p>
<p>為了使用上方便，我還是會在自己的 library 為 <code>IEnumerable</code> 加上 <code>ForEach()</code> Extension Method，這樣就不需 <code>ToList()</code> 了。</p>
<h2 id="使用時機">使用時機</h2><hr>
<p><code>ForEach()</code> 表面上看起來是 <code>foreach</code> statement 的 syntax sugar，但事實上 <code>ForEach()</code> 在 FP 的意義並非如此。</p>
<p>FP 將 data 以 Dataflow 與 Pipeline 方式處理，因此提供了眾多 operator，而 operator 則必須搭配 pure function，不能有 Side Effect。但 Side effect 總要有人處理，<code>ForEach()</code> 就是讓你統一處理 Side Effect 之處。</p>
<p>與 Imperative 寫法的差異是 : Imperative 總是不斷的在處理 Side Effect，因此造成結果難以預測、難以測試，bug 就是由此展開；但  FP 對於 data 處理堅持採用 Dataflow 與 Pipeline，不使用 Side Effect，因此對 data 處理是可預測且容易測試，直到最後 data 處理完，才不得已使用 <code>ForEach()</code> 處理 Side Effect。</p>
<p>如 <code>Console.WriteLine()</code> 就是 I/O，就是 Side Effect，這是無法避免的，最後使用 <code>ForEach()</code> 統一解決。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li><code>.</code> 與 Extension Method 是 C# 的 syntax sugar，其本質就是 FP 的 data 與 logic 分離與 Pipeline</li>
<li>Method Group 讓 FP 寫法會更為精簡，也是 C# 很重要的發明</li>
<li>FP 的 operator 主要在處理 Dataflow 與 Pipeline，應該使用 pure function，但 <code>ForEach()</code> 是少數讓你處理 Side Effect 的 operator，應該將 side effect 集中在 <code>ForEach()</code> 處理</li>
</ul>
<h2 id="Reference">Reference</h2><hr>
<p><a href="http://reactivex.io" target="_blank" rel="external">ReactiveX</a>, <a href="http://reactivex.io/learnrx/" target="_blank" rel="external">Functional Programming in JavaScript</a></p>
]]></content>
    <summary type="html">
    <![CDATA[以重構角度探討 LINQ]]>
    
    </summary>
    
      <category term="C#" scheme="https://oomusou.io/tags/C/"/>
    
      <category term="LINQ" scheme="https://oomusou.io/tags/LINQ/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 SonarQube 顯示 .NET Core 專案 Code Coverage ? (Docker)]]></title>
    <link href="https://oomusou.io/sonarqube/code-coverage/"/>
    <id>https://oomusou.io/sonarqube/code-coverage/</id>
    <published>2018-08-02T12:23:43.000Z</published>
    <updated>2018-08-02T03:03:59.962Z</updated>
    <content type="html"><![CDATA[<p>SonarQube 除了能檢查 C# 品質外，還可以當成 dashboard 使用，讓整個團隊有統一入口關注專案的 Code Coverage。</p>
<p>SonarQube 支援 OpenCover 與 dotCover 兩種格式，本文將以 NUnit + Coverlet + OpenCover 介紹。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>Docker for Mac 18.06.0-ce-mac70 (26399)<br>.NET Core 2.1<br>SonarQube 7.1<br>SonarScanner 4.3.1.1372<br>NUnit 3.10.1<br>Coverlet 2.1.1<br>Rider 2018.1.3</p>
<h2 id="Coverlet">Coverlet</h2><hr>
<p><img src="/images/sonarqube/code-coverage/coverage000.png" alt="coverage000"></p>
<p>在 NUnit 專案加入 Coverlet package，這是個基於 .NET Core，且能跨平台計算 Code Coverage 的 package。</p>
<blockquote>
<p>OpenCover 與 dotCover 算 .NET 生態圈兩大最有名的 package，但目前都只能跑在 Windows 平台，Coverlet 算目前跨平台最佳 solution</p>
</blockquote>
<h2 id="Dockerfile">Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FROM</span> microsoft/dotnet</span><br><span class="line"></span><br><span class="line"><span class="built_in">ENV</span> SCANNER_VERSION=<span class="number">4.3</span>.<span class="number">1.1372</span></span><br><span class="line"><span class="built_in">ENV</span> SCANNER_HOME=/opt/scanner</span><br><span class="line"></span><br><span class="line"><span class="built_in">WORKDIR</span> <span class="bash">/app</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash">apt-get update </span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y wget</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y unzip</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y openjdk-<span class="number">8</span>-jre</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">wget -q https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/<span class="variable">$SCANNER_VERSION</span>/sonar-scanner-msbuild-<span class="variable">$SCANNER_VERSION</span>-netcoreapp2.<span class="number">0</span>.zip -O /opt/sonar-scanner-msbuild.zip</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">mkdir -p <span class="variable">$SCANNER_HOME</span></span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">unzip /opt/sonar-scanner-msbuild.zip <span class="operator">-d</span> <span class="variable">$SCANNER_HOME</span></span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">rm /opt/sonar-scanner-msbuild.zip</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">chmod <span class="number">775</span> <span class="variable">$SCANNER_HOME</span>/ -R</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">COPY</span> <span class="bash">./ ./</span><br><span class="line"></span><span class="built_in">ENTRYPOINT</span> <span class="bash">[<span class="string">"./scanner.sh"</span>]</span></span><br></pre></td></tr></table></figure>
<p>因為要在 .NET Core container 安裝 SonarScanner，所以要對 .NET Core 客製化 image。</p>
<p>第 1 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FROM</span> microsoft/dotnet</span><br></pre></td></tr></table></figure>
<p>使用 <code>FROM</code> 設定所使用的基底 image。</p>
<p>使用 Microsoft 官方的 <code>microsoft/dotnet</code> image。</p>
<p>第 3 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ENV</span> SCANNER_VERSION=<span class="number">4.3</span>.<span class="number">1.1372</span></span><br><span class="line"><span class="built_in">ENV</span> SCANNER_HOME=/opt/scanner</span><br></pre></td></tr></table></figure>
<p>使用 <code>ENV</code> 設定 Dockerfile 的環境變數。</p>
<p><code>SCANNER_VERSION</code> : 因為 SonarScanner 的下載路徑，會與版本有關，所以特別設定成變數。</p>
<p><code>SCANNER_HOME</code> : 設定 SonarScanner 所安裝的目錄。</p>
<p>第 6 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WORKDIR</span> <span class="bash">/app</span></span><br></pre></td></tr></table></figure>
<p>設定 container 的工作目錄，也就是預設目錄都會在 <code>/app</code> 下。</p>
<p>第 8 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">apt-get update </span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y wget</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y unzip</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y openjdk-<span class="number">8</span>-jre</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>RUN</code> 執行 CLI 指令。</p>
<ul>
<li>使用 <code>wget</code> 下載 SonarScanner</li>
<li>使用 <code>unzip</code> 對 zip 解壓縮</li>
<li><code>SonarScanner</code> 會使用 Java 執行，需要安裝 Java Runtime</li>
</ul>
<p>12 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">wget -q https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/<span class="variable">$SCANNER_VERSION</span>/sonar-scanner-msbuild-<span class="variable">$SCANNER_VERSION</span>-netcoreapp2.<span class="number">0</span>.zip -O /opt/sonar-scanner-msbuild.zip</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>wget</code> 下載 SonarScanner 壓縮檔，並下載到 <code>/opt</code> 目錄下。</p>
<p>13 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">mkdir -p <span class="variable">$SCANNER_HOME</span></span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">unzip /opt/sonar-scanner-msbuild.zip <span class="operator">-d</span> <span class="variable">$SCANNER_HOME</span></span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">rm /opt/sonar-scanner-msbuild.zip</span></span><br></pre></td></tr></table></figure>
<p>建立 <code>/opt/scanner</code> 目錄，將 SonarScanner 壓縮檔解壓縮放到 <code>/opt/scanner</code> 目錄下，解壓縮完刪除 SonarScanner 壓縮檔。</p>
<p>16 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">chmod <span class="number">775</span> <span class="variable">$SCANNER_HOME</span>/ -R</span></span><br></pre></td></tr></table></figure>
<p>將 SonarScanner 目錄所有檔案賦予執行權力。</p>
<p>18 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">COPY</span> <span class="bash">./ ./</span></span><br></pre></td></tr></table></figure>
<p>將目前 solution 下所有檔案複製到 container 內，也就是 <code>/app</code> 目錄下。</p>
<p>19 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ENTRYPOINT</span> <span class="bash">[<span class="string">"./scanner.sh"</span>]</span></span><br></pre></td></tr></table></figure>
<p>最後會執行專案目錄下的 <code>./scanner.sh</code>，負責執行 SonarScanner 檢查。</p>
<h2 id="Docker-compose-yml">Docker-compose.yml</h2><hr>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version: &#34;3&#34;&#10;&#10;services:&#10;  net-core:&#10;    build: .&#10;    container_name: MyCore&#10;    volumes:&#10;      - &#34;$&#123;HOST_DIR&#125;:/code/&#34;&#10;    networks:&#10;      - netcore&#10;    depends_on:&#10;      - sonarqube&#10;&#10;  sonarqube:&#10;    image: sonarqube:latest&#10;    container_name: MySonarQube&#10;    ports:&#10;      - 9000:9000&#10;      - 9002:9002&#10;    networks:&#10;      netcore:&#10;        ipv4_address: 172.16.238.10&#10;     &#10;networks:&#10;  netcore:&#10;    ipam: &#10;      driver: default&#10;      config:&#10;        - subnet: 172.16.238.0/24</span><br></pre></td></tr></table></figure>
<p>設定 .NET Core 與 SonarQube 兩個 container 同時啟動。</p>
<p>第 4 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net-core:&#10;    build: .</span><br></pre></td></tr></table></figure>
<p>使用 <code>build</code> 將同目錄下的 <code>Dockerfile</code> build 成 image，也就是剛才的 <code>Dockerfile</code>。</p>
<p>第 6 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: MyCore</span><br></pre></td></tr></table></figure>
<p>使用 <code>container_name</code> 設定 .NET Core 的 container 名稱。</p>
<p>第 7 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volumes:&#10;  - &#34;$&#123;HOST_DIR&#125;:/code/&#34;</span><br></pre></td></tr></table></figure>
<p>使用 <code>volumes</code> 設定 host 與 container 的共用目錄，<code>:</code> 左方為 host 目錄，右方為 container 目錄。</p>
<p>目的是能在 .NET Core container 內抓到 host 的 project。</p>
<p>第 9 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networks:&#10;  - netcore</span><br></pre></td></tr></table></figure>
<p>使用 <code>networks</code> 設定 .NET Core 與 SonarQube 共用 <code>netcore</code> 內部網路。</p>
<p>11 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">depends_on:&#10;  - sonarqube</span><br></pre></td></tr></table></figure>
<p>.NET Core container 相依於 SonarQube container。</p>
<p>14 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sonarqube:&#10;  image: sonarqube:latest</span><br></pre></td></tr></table></figure>
<p>使用 <code>image</code> 設定 container 所使用的 image。</p>
<p>16 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: MySonarQube</span><br></pre></td></tr></table></figure>
<p>使用 <code>container_name</code> 設定 SonarQube 的 container 名稱。</p>
<p>17 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ports:&#10;  - 9000:9000&#10;  - 9002:9002</span><br></pre></td></tr></table></figure>
<p>使用 <code>ports</code> 設定 host 與 container 所 mapping 的 port，<code>:</code> 左側為 host port，右側為 container port。</p>
<p>為了能在 host 以瀏覽器連上 SonarQube，要將 host 的 9000 與 9002 兩個 port 給 host。</p>
<p>20 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networks:&#10;  netcore:&#10;    ipv4_address: 172.16.238.10</span><br></pre></td></tr></table></figure>
<p>使用 <code>network</code> 設定使用 <code>netcore</code> 網路，並設定其 IP 為 <code>172.16.238.10</code>。</p>
<blockquote>
<p>一般來說，我們不必為 container 設定固定 IP，只要使用 container 名稱就可彼此溝通，但稍後 SonarScanner 必須使用固定 IP 才能連上 SonarQube，所以在此特別要設定固定 IP</p>
</blockquote>
<p>24 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networks:&#10;  netcore:&#10;    ipam: &#10;      driver: default&#10;      config:&#10;        - subnet: 172.16.238.0/24</span><br></pre></td></tr></table></figure>
<p>設定 <code>netcore</code> 網路。</p>
<h2 id="-env">.env</h2><hr>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOST_DIR=~/Code/CSharp</span><br></pre></td></tr></table></figure>
<p>將 <code>HOST_DIR</code> 以環境變數設定，為 host 與 .NET Core container 所共享的目錄。</p>
<h2 id="scanner-sh">scanner.sh</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span></span><br><span class="line">sleep <span class="number">35</span></span><br><span class="line"><span class="built_in">cd</span> ./ClassLib.Test</span><br><span class="line">dotnet <span class="built_in">test</span> /p:CollectCoverage=<span class="literal">true</span> /p:CoverletOutputFormat=opencover </span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">dotnet /opt/scanner/SonarScanner.MSBuild.dll begin /k:core2 /n:Core2 /v:<span class="number">1.0</span> /d:sonar.login=admin /d:sonar.password=admin /d:sonar.host.url=http://<span class="number">172.16</span>.<span class="number">238.10</span>:<span class="number">9000</span> /d:sonar.cs.opencover.reportsPaths=/app/ClassLib.Test/coverage.opencover.xml /d:sonar.coverage.exclusions=**/Program.cs</span><br><span class="line">dotnet build</span><br><span class="line">dotnet /opt/scanner/SonarScanner.MSBuild.dll end /d:sonar.login=admin /d:sonar.password=admin</span><br></pre></td></tr></table></figure>
<p>使用 SonarScanner 檢查 .NET Core 專案，<code>scanner.sh</code> 會放在專案根目錄。</p>
<p>第 2 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>主要是要等 SonarQube 啟動完成，比較好的方式是使用 Health Check 明確得知 SonarQube 已經啟動完成。</p>
<p>這裡暫時先 sleep 30 秒，等 SonarQube 先啟動，.NET Core 才開始執行 SonarScanner。</p>
<p>這裡還有改善的空間，也可以自行調整 sleep 時間。</p>
<p>第 4 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet <span class="built_in">test</span> /p:CollectCoverage=<span class="literal">true</span> /p:CoverletOutputFormat=opencover</span><br></pre></td></tr></table></figure>
<p>執行 NUnit 單元測試。</p>
<ul>
<li><strong>/p:CollectCoverage=true</strong> : 命令 Coverlet 計算 Code Coverage</li>
<li><strong>/p:CoverletOutputFormat=opencover</strong> : 命令 Coverlet 以 OpenCover 格式產出</li>
</ul>
<p>第 6 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet /opt/scanner/SonarScanner.MSBuild.dll begin /k:core2 /n:Core2 /v:<span class="number">1.0</span> /d:sonar.login=admin /d:sonar.password=admin /d:sonar.host.url=http://<span class="number">172.16</span>.<span class="number">238.10</span>:<span class="number">9000</span> /d:sonar.cs.opencover.reportsPaths=/app/ClassLib.Test/coverage.opencover.xml /d:sonar.coverage.exclusions=**/Program.cs</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet</code> 執行 <code>SonarScanner.MSBuild.dll</code>，一開始以 <code>begin</code> 開頭：</p>
<ul>
<li><strong>/k</strong> : SonarQube 對專案的 key，內部將以此 key 作為辨別，必須唯一</li>
<li><strong>/n</strong> : 在 SonarQube 網頁上顯示的專案名稱</li>
<li><strong>/v</strong> : 在 SonarQube 網頁上顯示的版本編號</li>
<li><strong>/d:sonar.login</strong> : 指定 SonarQube 帳號</li>
<li><strong>/d:sonar.password</strong> : 指定 SonarQube 密碼</li>
<li><strong>/d:sonar.host.url</strong> : 指定 SonarQube server IP 與 port</li>
<li><strong>/d:sonar.cs.opencover.reportsPaths</strong> : 設定 OpenCover 格式的 XML 檔案位置</li>
<li><strong>/d:sonar.coverage.exclusions</strong> : 設定 SonarQube 排除 Code Coverage 計算的檔案</li>
</ul>
<blockquote>
<p>目前 SonarQube 設定 exclusions 的 regex 有些 bug，可能無法如文件那般設定 regex，假如遇到這個 bug，就先用最原始的方式指定 exclusions</p>
</blockquote>
<p>第 7 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet build</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet build</code> 編譯專案。</p>
<blockquote>
<p>Script 語言不用編譯，可以直接使用 SonarQube Scanner 就可以檢查，但 C# 需要編譯，因此必須 dotnet build</p>
</blockquote>
<p>第 8 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet /opt/scanner/SonarScanner.MSBuild.dll end /d:sonar.login=admin /d:sonar.password=admin</span><br></pre></td></tr></table></figure>
<p>最後需加上 <code>end</code>，scanner 正式將 <code>dotnet build</code> 檢查出的結果寫入 SonarQube project</p>
<ul>
<li>仍必須指定 SonarQube 的帳號密碼</li>
</ul>
<h2 id="執行_SonarScanner">執行 SonarScanner</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SonarScanner $ docker-compose up --build</span><br></pre></td></tr></table></figure>
<p>啟動 .NET Core 與 SonarQube container，並且自動執行 SonarScanner。</p>
<ul>
<li><strong>–build</strong> : 重新建立 .NET Core 自訂 image，若有任何修改，將重新包進 image，確保 <code>docker-compose</code> 是最新的 image</li>
</ul>
<p><img src="/images/sonarqube/code-coverage/coverage001.png" alt="core000"></p>
<p><img src="/images/sonarqube/code-coverage/coverage002.png" alt="coverage002"></p>
<ol>
<li>Coverlet 計算出 Code Coverage，並且產生 <code>coverage.opencover.xml</code></li>
</ol>
<p><img src="/images/sonarqube/code-coverage/coverage003.png" alt="coverage003"></p>
<ol>
<li>在 host 以 <code>http://localhost:9000</code> ，將可看到 SonarQube 的檢查結果，並且正確顯示 Code Coverage</li>
</ol>
<h2 id="結束_Container">結束 Container</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose down</span><br></pre></td></tr></table></figure>
<p><img src="/images/sonarqube/code-coverage/coverage004.png" alt="core003"></p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>由於 SonarScanner 已經被包在 Dockerfile 內，host 就不用再安裝 SonarScanner</li>
<li>沒有將 .NET Core 安裝在 SonarQube container 內，而是分別使用 .NET Core container 與 SonarQube container，符合 Microservice 精神</li>
<li>Coverlet 為目前唯一的 .NET Core 跨平台 Code Coverage 解決方案，並且可以產出 OpenCover 格式 XML</li>
<li>只要執行 <code>docker-compose up --build</code>，就會執行 NUnit 單元測試與 Coverlet 計算 Code Coverage，且 SonarScanner 也會自動進行檢查</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/sonarscanner" target="_blank" rel="external">GitHub</a> 上找到</p>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://github.com/tonerdo" target="_blank" rel="external">Tonerdo</a>, <a href="https://github.com/tonerdo/coverlet" target="_blank" rel="external">Coverlet</a><br><a href="https://tattoocoder.com" target="_blank" rel="external">Shryne Boyer</a>, <a href="https://tattoocoder.com/cross-platform-code-coverage-arrives-for-net-core/" target="_blank" rel="external">Cross platform code coverage arrives for .NET Core</a><br><a href="https://docs.sonarqube.org" target="_blank" rel="external">SonarQube</a>, <a href="https://docs.sonarqube.org/pages/viewpage.action?pageId=6389770" target="_blank" rel="external">Code Coverage Result Import (C#, VB.NET)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[SonarQube 也能顯示 Code Coverage]]>
    
    </summary>
    
      <category term=".NET Core" scheme="https://oomusou.io/tags/NET-Core/"/>
    
      <category term="Coverlet" scheme="https://oomusou.io/tags/Coverlet/"/>
    
      <category term="NUnit" scheme="https://oomusou.io/tags/NUnit/"/>
    
      <category term="SonarQube" scheme="https://oomusou.io/tags/SonarQube/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何讀取 JSON 格式設定檔 ?]]></title>
    <link href="https://oomusou.io/netcore/json-config/"/>
    <id>https://oomusou.io/netcore/json-config/</id>
    <published>2018-07-31T13:23:43.000Z</published>
    <updated>2018-07-31T15:37:22.515Z</updated>
    <content type="html"><![CDATA[<p>在實務上不少資訊我們不想寫死在 code 中，會以 config 形式由 client 設定，目前最主流的 config 就屬 JSON 格式，.NET 也提供了 <code>ConfigurationBuilder</code> ，讓我們輕易的讀取 JSON 格式的 config 檔。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>.NET Core 2.1<br>C# 7.2<br>Rider 2018.1.3</p>
<h2 id="安裝_Package">安裝 Package</h2><hr>
<p><img src="/images/netcore/json-config/config000.png" alt="config000"></p>
<p>要另外安裝 3 個 package :</p>
<ul>
<li><code>Microsoft.Extensions.Configuration</code></li>
<li><code>Microsoft.Extensions.Configuration.FileExtensions</code></li>
<li><code>Microsoft.Extensions.Configuration.Json</code> </li>
</ul>
<h2 id="ConfigurationBuilder">ConfigurationBuilder</h2><hr>
<p><strong>Config.json</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"Name"</span>: <span class="string">"Sam"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假設 <code>config.json</code> 放在 project 的根目錄下，想要讀取 key 為 <code>Name</code> 的 value。</p>
<p><strong>Program.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> currentDirectory = Directory.GetCurrentDirectory();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> config =</span><br><span class="line">                <span class="keyword">new</span> ConfigurationBuilder()</span><br><span class="line">                    .SetBasePath(currentDirectory)</span><br><span class="line">                    .AddJsonFile(<span class="string">"config.json"</span>)</span><br><span class="line">                    .Build();</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(config[<span class="string">"Name"</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> currentDirectory = Directory.GetCurrentDirectory();</span><br></pre></td></tr></table></figure>
<p>使用 <code>Directory.GetCurrentDirectory()</code> 讀取目前 project 的根目錄。</p>
<p>14 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ConfigurationBuilder()</span><br><span class="line">    .SetBasePath(currentDirectory)</span><br></pre></td></tr></table></figure>
<p>建立 <code>ConfigurationBuilder</code>，並由 <code>SetBasePath()</code> 設定其 working directory。</p>
<p>16 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.AddJsonFile(<span class="string">"config.json"</span>)</span><br></pre></td></tr></table></figure>
<p>由 <code>AddJsonFile()</code> 設定 config 檔案。</p>
<p>17 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.Build();</span><br></pre></td></tr></table></figure>
<p>最後由 <code>Build()</code> 建立 <code>config</code> 物件。</p>
<p>19 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(config[<span class="string">"Name"</span>]);</span><br></pre></td></tr></table></figure>
<p>由於 <code>IConfiguration</code> 有定義  indexer，因此我們可以 <code>Name</code> 當 key 直接存取。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>使用 <code>ConfigurationBuilder</code> 讓我們可以很簡單地讀取 JSON 格式的 config 檔</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/AppSettingsJson" target="_blank" rel="external">GitHub</a> 上找到</p>
]]></content>
    <summary type="html">
    <![CDATA[使用 Configuration Package]]>
    
    </summary>
    
      <category term=".NET Core" scheme="https://oomusou.io/tags/NET-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 SonarQube 檢查 .NET Core 專案 ? (Docker)]]></title>
    <link href="https://oomusou.io/sonarqube/netcore-docker/"/>
    <id>https://oomusou.io/sonarqube/netcore-docker/</id>
    <published>2018-07-31T12:23:43.000Z</published>
    <updated>2018-08-02T02:48:16.469Z</updated>
    <content type="html"><![CDATA[<p>SonarQube 是一套 <code>程式碼品質檢查工具</code>，可以幫我們檢查 C# 的 bugs、 vulenrability、code smell 與 duplication。</p>
<p>本文使用 Docker Compose，並同時啟動 .NET Core 與 SonarQube 兩個 container，自動對 .NET 專案進行檢查。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>Docker for Mac 18.06.0-ce-mac70 (26399)<br>.NET Core 2.1<br>SonarQube 7.1<br>SonarScanner 4.3.1.1372<br>Rider 2018.1.3</p>
<h2 id="Dockerfile">Dockerfile</h2><hr>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FROM</span> microsoft/dotnet</span><br><span class="line"></span><br><span class="line"><span class="built_in">ENV</span> SCANNER_VERSION=<span class="number">4.3</span>.<span class="number">1.1372</span></span><br><span class="line"><span class="built_in">ENV</span> SCANNER_HOME=/opt/scanner</span><br><span class="line"></span><br><span class="line"><span class="built_in">WORKDIR</span> <span class="bash">/app</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash">apt-get update </span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y wget</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y unzip</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y openjdk-<span class="number">8</span>-jre</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">wget -q https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/<span class="variable">$SCANNER_VERSION</span>/sonar-scanner-msbuild-<span class="variable">$SCANNER_VERSION</span>-netcoreapp2.<span class="number">0</span>.zip -O /opt/sonar-scanner-msbuild.zip</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">mkdir -p <span class="variable">$SCANNER_HOME</span></span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">unzip /opt/sonar-scanner-msbuild.zip <span class="operator">-d</span> <span class="variable">$SCANNER_HOME</span></span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">rm /opt/sonar-scanner-msbuild.zip</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">chmod <span class="number">775</span> <span class="variable">$SCANNER_HOME</span>/ -R</span><br><span class="line"></span></span><br><span class="line"><span class="built_in">COPY</span> <span class="bash">./ ./</span><br><span class="line"></span><span class="built_in">ENTRYPOINT</span> <span class="bash">[<span class="string">"./scanner.sh"</span>]</span></span><br></pre></td></tr></table></figure>
<p>因為要在 .NET Core container 安裝 SonarScanner，所以要對 .NET Core 客製化 image。</p>
<p>第 1 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FROM</span> microsoft/dotnet</span><br></pre></td></tr></table></figure>
<p>使用 <code>FROM</code> 設定所使用的基底 image。</p>
<p>使用 Microsoft 官方的 <code>microsoft/dotnet</code> image。</p>
<p>第 3 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ENV</span> SCANNER_VERSION=<span class="number">4.3</span>.<span class="number">1.1372</span></span><br><span class="line"><span class="built_in">ENV</span> SCANNER_HOME=/opt/scanner</span><br></pre></td></tr></table></figure>
<p>使用 <code>ENV</code> 設定 Dockerfile 的環境變數。</p>
<p><code>SCANNER_VERSION</code> : 因為 SonarScanner 的下載路徑，會與版本有關，所以特別設定成變數。</p>
<p><code>SCANNER_HOME</code> : 設定 SonarScanner 所安裝的目錄。</p>
<p>第 6 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WORKDIR</span> <span class="bash">/app</span></span><br></pre></td></tr></table></figure>
<p>設定 container 的工作目錄，也就是預設目錄都會在 <code>/app</code> 下。</p>
<p>第 8 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">apt-get update </span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y wget</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y unzip</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y openjdk-<span class="number">8</span>-jre</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>RUN</code> 執行 CLI 指令。</p>
<ul>
<li>使用 <code>wget</code> 下載 SonarScanner</li>
<li>使用 <code>unzip</code> 對 zip 解壓縮</li>
<li><code>SonarScanner</code> 會使用 Java 執行，需要安裝 Java Runtime</li>
</ul>
<p>12 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">wget -q https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/<span class="variable">$SCANNER_VERSION</span>/sonar-scanner-msbuild-<span class="variable">$SCANNER_VERSION</span>-netcoreapp2.<span class="number">0</span>.zip -O /opt/sonar-scanner-msbuild.zip</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>wget</code> 下載 SonarScanner 壓縮檔，並下載到 <code>/opt</code> 目錄下。</p>
<p>13 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">mkdir -p <span class="variable">$SCANNER_HOME</span></span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">unzip /opt/sonar-scanner-msbuild.zip <span class="operator">-d</span> <span class="variable">$SCANNER_HOME</span></span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">rm /opt/sonar-scanner-msbuild.zip</span></span><br></pre></td></tr></table></figure>
<p>建立 <code>/opt/scanner</code> 目錄，將 SonarScanner 壓縮檔解壓縮放到 <code>/opt/scanner</code> 目錄下，解壓縮完刪除 SonarScanner 壓縮檔。</p>
<p>16 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RUN</span> <span class="bash">chmod <span class="number">775</span> <span class="variable">$SCANNER_HOME</span>/ -R</span></span><br></pre></td></tr></table></figure>
<p>將 SonarScanner 目錄所有檔案賦予執行權力。</p>
<p>18 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">COPY</span> <span class="bash">./ ./</span></span><br></pre></td></tr></table></figure>
<p>將目前 solution 下所有檔案複製到 container 內，也就是 <code>/app</code> 目錄下。</p>
<p>19 行</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ENTRYPOINT</span> <span class="bash">[<span class="string">"./scanner.sh"</span>]</span></span><br></pre></td></tr></table></figure>
<p>最後會執行專案目錄下的 <code>./scanner.sh</code>，負責執行 SonarScanner 檢查。</p>
<h2 id="Docker-compose-yml">Docker-compose.yml</h2><hr>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version: &#34;3&#34;&#10;&#10;services:&#10;  net-core:&#10;    build: .&#10;    container_name: MyCore&#10;    volumes:&#10;      - &#34;$&#123;HOST_DIR&#125;:/code/&#34;&#10;    networks:&#10;      - netcore&#10;    depends_on:&#10;      - sonarqube&#10;&#10;  sonarqube:&#10;    image: sonarqube:latest&#10;    container_name: MySonarQube&#10;    ports:&#10;      - 9000:9000&#10;      - 9002:9002&#10;    networks:&#10;      netcore:&#10;        ipv4_address: 172.16.238.10&#10;     &#10;networks:&#10;  netcore:&#10;    ipam: &#10;      driver: default&#10;      config:&#10;        - subnet: 172.16.238.0/24</span><br></pre></td></tr></table></figure>
<p>設定 .NET Core 與 SonarQube 兩個 container 同時啟動。</p>
<p>第 4 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net-core:&#10;    build: .</span><br></pre></td></tr></table></figure>
<p>使用 <code>build</code> 將同目錄下的 <code>Dockerfile</code> build 成 image，也就是剛才的 <code>Dockerfile</code>。</p>
<p>第 6 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: MyCore</span><br></pre></td></tr></table></figure>
<p>使用 <code>container_name</code> 設定 .NET Core 的 container 名稱。</p>
<p>第 7 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volumes:&#10;  - &#34;$&#123;HOST_DIR&#125;:/code/&#34;</span><br></pre></td></tr></table></figure>
<p>使用 <code>volumes</code> 設定 host 與 container 的共用目錄，<code>:</code> 左方為 host 目錄，右方為 container 目錄。</p>
<p>目的是能在 .NET Core container 內抓到 host 的 project。</p>
<p>第 9 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networks:&#10;  - netcore</span><br></pre></td></tr></table></figure>
<p>使用 <code>networks</code> 設定 .NET Core 與 SonarQube 共用 <code>netcore</code> 內部網路。</p>
<p>11 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">depends_on:&#10;  - sonarqube</span><br></pre></td></tr></table></figure>
<p>.NET Core container 相依於 SonarQube container。</p>
<p>14 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sonarqube:&#10;  image: sonarqube:latest</span><br></pre></td></tr></table></figure>
<p>使用 <code>image</code> 設定 container 所使用的 image。</p>
<p>16 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: MySonarQube</span><br></pre></td></tr></table></figure>
<p>使用 <code>container_name</code> 設定 SonarQube 的 container 名稱。</p>
<p>17 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ports:&#10;  - 9000:9000&#10;  - 9002:9002</span><br></pre></td></tr></table></figure>
<p>使用 <code>ports</code> 設定 host 與 container 所 mapping 的 port，<code>:</code> 左側為 host port，右側為 container port。</p>
<p>為了能在 host 以瀏覽器連上 SonarQube，要將 host 的 9000 與 9002 兩個 port 給 host。</p>
<p>20 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networks:&#10;  netcore:&#10;    ipv4_address: 172.16.238.10</span><br></pre></td></tr></table></figure>
<p>使用 <code>network</code> 設定使用 <code>netcore</code> 網路，並設定其 IP 為 <code>172.16.238.10</code>。</p>
<blockquote>
<p>一般來說，我們不必為 container 設定固定 IP，只要使用 container 名稱就可彼此溝通，但稍後 SonarScanner 必須使用固定 IP 才能連上 SonarQube，所以在此特別要設定固定 IP</p>
</blockquote>
<p>24 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">networks:&#10;  netcore:&#10;    ipam: &#10;      driver: default&#10;      config:&#10;        - subnet: 172.16.238.0/24</span><br></pre></td></tr></table></figure>
<p>設定 <code>netcore</code> 網路。</p>
<h2 id="-env">.env</h2><hr>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOST_DIR=~/Code/CSharp</span><br></pre></td></tr></table></figure>
<p>將 <code>HOST_DIR</code> 以環境變數設定，為 host 與 .NET Core container 所共享的目錄。</p>
<h2 id="scanner-sh">scanner.sh</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#! /bin/bash</span></span><br><span class="line">sleep <span class="number">30</span></span><br><span class="line">dotnet /opt/scanner/SonarScanner.MSBuild.dll begin /k:core2 /n:Core2 /v:<span class="number">1.0</span> /d:sonar.login=admin /d:sonar.password=admin /d:sonar.host.url=http://<span class="number">172.16</span>.<span class="number">238.10</span>:<span class="number">9000</span></span><br><span class="line">dotnet build</span><br><span class="line">dotnet /opt/scanner/SonarScanner.MSBuild.dll end /d:sonar.login=admin /d:sonar.password=admin</span><br></pre></td></tr></table></figure>
<p>使用 SonarScanner 檢查 .NET Core 專案，<code>scanner.sh</code> 會放在專案根目錄。</p>
<p>第 2 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sleep <span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>主要是要等 SonarQube 啟動完成，比較好的方式是使用 Health Check 明確得知 SonarQube 已經啟動完成。</p>
<p>這裡暫時先 sleep 30 秒，等 SonarQube 先啟動，.NET Core 才開始執行 SonarScanner。</p>
<p>這裡還有改善的空間，也可以自行調整 sleep 時間。</p>
<p>第 3 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet /opt/scanner/SonarScanner.MSBuild.dll begin /k:core2 /n:Core2 /v:<span class="number">1.0</span> /d:sonar.login=admin /d:sonar.password=admin /d:sonar.host.url=http://<span class="number">172.16</span>.<span class="number">238.10</span>:<span class="number">9000</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet</code> 執行 <code>SonarScanner.MSBuild.dll</code>，一開始以 <code>begin</code> 開頭：</p>
<ul>
<li><strong>/k</strong> : SonarQube 對專案的 key，內部將以此 key 作為辨別，必須唯一</li>
<li><strong>/n</strong> : 在 SonarQube 網頁上顯示的專案名稱</li>
<li><strong>/v</strong> : 在 SonarQube 網頁上顯示的版本編號</li>
<li><strong>/d:sonar.login</strong> : 指定 SonarQube 帳號</li>
<li><strong>/d:sonar.password</strong> : 指定 SonarQube 密碼</li>
<li><strong>/d:sonar.host.url</strong> : 指定 SonarQube server IP 與 port</li>
</ul>
<p>第 4 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet build</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet build</code> 編譯專案。</p>
<blockquote>
<p>Script 語言不用編譯，可以直接使用 SonarQube Scanner 就可以檢查，但 C# 需要編譯，因此必須 dotnet build</p>
</blockquote>
<p>第 5 行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet /opt/scanner/SonarScanner.MSBuild.dll end /d:sonar.login=admin /d:sonar.password=admin</span><br></pre></td></tr></table></figure>
<p>最後需加上 <code>end</code>，scanner 正式將 <code>dotnet build</code> 檢查出的結果寫入 SonarQube project</p>
<ul>
<li>仍必須指定 SonarQube 的帳號密碼</li>
</ul>
<h2 id="執行_SonarScanner">執行 SonarScanner</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SonarScanner $ docker-compose up --build</span><br></pre></td></tr></table></figure>
<p>啟動 .NET Core 與 SonarQube container，並且自動執行 SonarScanner。</p>
<ul>
<li><strong>–build</strong> : 重新建立 .NET Core 自訂 image，若有任何修改，將重新包進 image，確保 <code>docker-compose</code> 是最新的 image</li>
</ul>
<p><img src="/images/sonarqube/netcore-docker/core000.png" alt="core000"></p>
<p><img src="/images/sonarqube/netcore-docker/core002.png" alt="core002"></p>
<ol>
<li>在 host 以 <code>http://localhost:9000</code> ，將可看到 SonarQube 的檢查結果</li>
</ol>
<h2 id="結束_Container">結束 Container</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose down</span><br></pre></td></tr></table></figure>
<p><img src="/images/sonarqube/netcore-docker/core003.png" alt="core003"></p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>由於 SonarScanner 已經被包在 Dockerfile 內，host 就不用再安裝 SonarScanner</li>
<li>沒有將 .NET Core 安裝在 SonarQube container 內，而是分別使用 .NET Core container 與 SonarQube container，符合 Microservice 精神</li>
<li>只要執行 <code>docker-compose up --build</code>，SonarScanner 就會自動啟動進行檢查</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/sonarscanner" target="_blank" rel="external">GitHub</a> 上找到</p>
]]></content>
    <summary type="html">
    <![CDATA[完全使用 Docker 版本 SonarQube]]>
    
    </summary>
    
      <category term=".NET Core" scheme="https://oomusou.io/tags/NET-Core/"/>
    
      <category term="Docker" scheme="https://oomusou.io/tags/Docker/"/>
    
      <category term="SonarQube" scheme="https://oomusou.io/tags/SonarQube/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 Parallel Desktop 使用 Docker for Mac ?]]></title>
    <link href="https://oomusou.io/docker/parallel-docker/"/>
    <id>https://oomusou.io/docker/parallel-docker/</id>
    <published>2018-07-29T12:23:43.000Z</published>
    <updated>2018-07-29T08:00:56.762Z</updated>
    <content type="html"><![CDATA[<p>雖然平時以 macOS 作為開發主力，偶爾還是會需要在 Parallel Desktop 使用 Windows，此時若要使用 Docker，雖然也能在 Parallel Destop 內跑 Docker for Windows，不過由於是 VM 中的 VM，Docker 並不穩定，比較建議的方式是 Windows 搭配 Docker for Mac 使用。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>Docker for Mac 18.06.0-ce-mac70 (26399)<br>PostgreSQL 10.4<br>Parallel Desktop 13 Pro 13.3.2 (43368)<br>Windows 10 Pro 1803 17134.191<br>Rider 2018.1.3 </p>
<h2 id="Docker_for_Mac">Docker for Mac</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up <span class="operator">-d</span></span><br></pre></td></tr></table></figure>
<p>在 macOS 以 <code>docker-compose</code> 啟動 PostgreSQL container，且 port 為 <code>1234</code>。</p>
<p><img src="/images/docker/parallel-docker/parallel000.png" alt="parallel000"></p>
<p>由於將來 Parallel Desktop 內的 Windows 將連到 macOS 的 PostgreSQL container，目前已知其 port 為 <code>1234</code> ，但 IP 是多少呢 ?</p>
<h2 id="Parallel_Desktop_Network">Parallel Desktop Network</h2><hr>
<p><img src="/images/docker/parallel-docker/parallel001.png" alt="parallel001"></p>
<p>Parallel Desktop 預設的 network 是以 <code>Shared Network</code> 方式。</p>
<p><img src="/images/docker/parallel-docker/parallel002.png" alt="parallel002"></p>
<p>什麼是 <code>Shared Network</code> 呢 ?</p>
<p>上圖中的 Mac 有 <code>192.168.0.20</code> 與  <code>10.211.55.10</code> 兩個 <code>IP</code> 。</p>
<p>而 Windows 的 IP 則為 <code>10.211.55.20</code>。</p>
<p>簡單的說相當於 Mac 有兩張網卡，一張網卡為 <code>192.168.0.20</code>，而另一張網卡為 <code>10.211.55.10</code>，而 Windows 的 <code>10.211.55.20</code> 與  Mac 的 <code>10.211.55.10</code> 為同一個網段，可彼此互通，然後再透過 <code>192.168.0.20</code> 這張網卡連上 internet。</p>
<p><img src="/images/docker/parallel-docker/parallel003.png" alt="parallel003"></p>
<p>我們可發現 Parallel Desktop 自帶 DHCP，且 IP 從 <code>10.211.55.1</code> 開始到 <code>10.211.55.254</code>。</p>
<p><img src="/images/docker/parallel-docker/parallel004.png" alt="parallel004"></p>
<p>當 Parallel Desktop 啟動後，實際在 macOS 下 <code>ifconfig</code> 觀察，會發現多了 <code>vinc0</code> 這張網卡，其 IP 為 <code>10.211.55.2</code>。</p>
<p>也就是說若要從 Parallel Desktop 的 Windows 連到 PostgreSQL container，IP 就是 <code>10.211.55.2</code>，port 為 <code>1234</code>。</p>
<h2 id="Windows">Windows</h2><hr>
<p><img src="/images/docker/parallel-docker/parallel005.png" alt="parallel005"></p>
<ol>
<li>在 Windows 內的 Rider 能夠以 <code>10.211.55.2 : 1234</code> 連到 Docker for Mac 的 PostgreSQL container</li>
</ol>
<h2 id="Conclusion">Conclusion</h2><ul>
<li>Parallel Desktop 都會穩定以 <code>10.211.55.2</code> 當成 macOS 的 IP，所以任何 Docker container 都可以跑在 macOS，然後 Windows 再以 <code>10.211.55.2</code> 連上即可，這樣就不需要執行 Docker for Windows 了</li>
</ul>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://www.parallels.com" target="_blank" rel="external">Parallels</a>, <a href="https://kb.parallels.com/en/4948" target="_blank" rel="external">Which networking mode (Bridged, Shared or Host-Only) should I use for the virtual machine?</a></p>
]]></content>
    <summary type="html">
    <![CDATA[不必再與 Docker for Windows 搏鬥]]>
    
    </summary>
    
      <category term="Docker" scheme="https://oomusou.io/tags/Docker/"/>
    
      <category term="Parallel Desktop" scheme="https://oomusou.io/tags/Parallel-Desktop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使 GitHub Blog 升級成 https ?]]></title>
    <link href="https://oomusou.io/hexo/https/"/>
    <id>https://oomusou.io/hexo/https/</id>
    <published>2018-07-28T12:23:43.000Z</published>
    <updated>2018-07-28T08:14:52.791Z</updated>
    <content type="html"><![CDATA[<p>當 Chrome 在 68 版後會將沒有 https 網站標上 <code>不安全</code> 字樣，讓 blog 升級成 https 已經不能避免的課題，若你是使用 Hexo 且放在 GitHub，則可參考本文的方式。</p>
<a id="more"></a>
<h2 id="GoDaddy">GoDaddy</h2><hr>
<p><img src="/images/hexo/https/https000.png" alt="https000"></p>
<ol>
<li>到 GoDaddy 去設定自己的 domain，按 <code>DNS</code></li>
</ol>
<p><img src="/images/hexo/https/https001.png" alt="https001"></p>
<ol>
<li>原本 GitHub pages domain 是兩組 <code>192</code> 開頭的 ip，改成這 4 組 ip。</li>
</ol>
<blockquote>
<p>不會馬上生效，要等 1 小時以上</p>
</blockquote>
<h2 id="Hexo">Hexo</h2><hr>
<p><strong>_config.yml</strong></p>
<p><img src="/images/hexo/https/https002.png" alt="https002"></p>
<p>在 Hexo 根目錄的 <code>_config.yml</code> 下，將 <code>url</code> 改成 <code>https</code>。</p>
<p>重新 <code>hexo clean</code>、<code>hero generate</code> 與 <code>hexo deploy</code>。</p>
<h2 id="GitHub">GitHub</h2><hr>
<p><img src="/images/hexo/https/https003.png" alt="https003"></p>
<ol>
<li>進入 repository 的 <code>Settings</code></li>
</ol>
<p><img src="/images/hexo/https/https004.png" alt="https004"></p>
<ol>
<li>將 <code>Enforce HTTPS</code> 打勾</li>
</ol>
<blockquote>
<p>若不能打勾，有可能 GoDaddy 的設定還沒生效，或者 Hexo 還沒上傳重新編譯過的 <code>https</code> 版本</p>
</blockquote>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>由於 GitHub 的支援，要讓 blog 支援 https 已經非常簡單了</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[GitHub 現在已經內建支援 https]]>
    
    </summary>
    
      <category term="GitHub" scheme="https://oomusou.io/tags/GitHub/"/>
    
      <category term="Hexo" scheme="https://oomusou.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 Docker 安裝 PostgreSQL ?]]></title>
    <link href="https://oomusou.io/docker/postgres/"/>
    <id>https://oomusou.io/docker/postgres/</id>
    <published>2018-07-24T22:23:43.000Z</published>
    <updated>2018-07-31T01:50:15.231Z</updated>
    <content type="html"><![CDATA[<p>若要在 Mac 使用 PostgreSQL，最簡單的方式就是使用 Docker 。本文分別使用 <code>docker run</code> 與 <code>docker-compose</code> 兩種方式。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>Docker for Mac 18.03.1-ce-mac65 (24312)<br>PostgreSQL 10.3</p>
<h2 id="使用_docker_run">使用 docker run</h2><hr>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="keyword">run</span> --name MyPostgres -<span class="keyword">d</span> -p 5432:5432 -v ~/Postgres:/<span class="keyword">var</span>/lib/postgresql/data -<span class="keyword">e</span> POSTGRES_DB=eflab -<span class="keyword">e</span> POSTGRES_USER=admin -<span class="keyword">e</span> POSTGRES_PASSWORD='12345' postgres:latest</span><br></pre></td></tr></table></figure>
<p>使用 <code>docker run</code> 由 image 建立 container，當 Docker 發現本機沒有 image，會自動從 Docker Hub 下載。</p>
<p><code>—name</code>：替 container 取一個人能夠識別的名字 <code>MyPostgres</code> (若省略，Docker 會自動以亂數建立 )<br><code>-d</code> : <code>d</code>etach，建立 container 後，就脫離目前 process</p>
<p><code>-v</code> : <code>v</code>olume，PostgresSQL 新增的資料會寫在 container 內的 <code>/var/lib/postgresql/data</code> 目錄，會改 mapping 到 host 的 <code>~/Postgres</code>，如此 container 刪除後，資料仍然會留在 host </p>
<p><code>-p</code> : <code>p</code>ort mapping，host 與 container post 的對應，格式為 host port : container port<br><code>-e</code> : <code>e</code>nvironment，設定 PostgreSQL 所需要的環境變數</p>
<ul>
<li><code>POSTGRES_DB</code> : database 名稱</li>
<li><code>POSTGRES_USER</code> : 帳號</li>
<li><code>POSTGRES_PASSWORD</code> : 密碼</li>
</ul>
<p><code>postgress:latest</code> : image 名稱，其中 <code>latest</code> 為最新版的 image</p>
<p><img src="/images/docker/postgres/post000.png" alt="post000"></p>
<h2 id="使用_Docker-Compose">使用 Docker-Compose</h2><hr>
<p><code>docker run</code> 方式雖然直接，但需要搭配一堆參數才能執行，若能將這些參數先寫在文字檔內，只要下 <code>docker-compose up -d</code> 就可執行 container。</p>
<p><code>-d</code> : <code>d</code>etach，建立 container 後，就脫離目前 process</p>
<h3 id="Docker-compose-yml">Docker-compose.yml</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version: &#34;3&#34;&#10;&#10;services:&#10;  postgres:&#10;    image: postgres:latest&#10;    container_name: MyPostgres&#10;    volumes:&#10;      - $&#123;HOST_DIR&#125;:/var/lib/postgresql/data&#10;    expose:&#10;      - 5432&#10;    ports:&#10;      - $&#123;POSTGRES_PORT&#125;:5432&#10;    environment:&#10;      - POSTGRES_DB=$&#123;POSTGRES_DB&#125;&#10;      - POSTGRES_USER=$&#123;POSTGRES_USER&#125;&#10;      - POSTGRES_PASSWORD=$&#123;POSTGRES_PASSWORD&#125;</span><br></pre></td></tr></table></figure>
<p>第 1 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version: &#34;3&#34;</span><br></pre></td></tr></table></figure>
<p>使用 <code>version</code> 設定 <code>docker-compose.yml</code> 格式的版本。</p>
<p>因為 <code>docker-compose.yml</code> 的格式版本與 Docker 版本息息相關，若你要使用新版的 Docker 所提供的功能，在 <code>docker-compose.yml</code> 的版本就必須下的更細，如 <code>3.3</code>，在此只使用了 <code>docker-compose.yml</code> 基本功能而已，使用 <code>3</code> 即可。</p>
<p>第 3 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services:&#10;  postgres:</span><br></pre></td></tr></table></figure>
<p>使用 <code>services</code> 設定有哪些 service 要一起跑。</p>
<p><code>Docker-compose.yml</code> 理論上可以同時描述多個 service，也就是多個 container，如 .NET Core + PostgreSQL + Nginx + Redis 同時啟動，但本文只想使用 PostgreSQL 而已，因此僅建立  <code>postgres</code> service。</p>
<p>第 4 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postgres:&#10;  image: postgres:latest</span><br></pre></td></tr></table></figure>
<p>設定 <code>postgres</code> service，此名稱可自行建立。</p>
<ul>
<li><strong>image</strong> :  設定使用的 image。</li>
</ul>
<blockquote>
<p><code>latest</code> 表示最新版的 <code>postgres</code></p>
</blockquote>
<p>第 6 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: MyPostgres</span><br></pre></td></tr></table></figure>
<p>使用 <code>container_name</code> 設定 container 名稱。</p>
<blockquote>
<p>相當於 <code>docker run</code> 的 <code>--name</code></p>
</blockquote>
<p>第 7 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volumes:&#10;  - $&#123;POSTGRES_HOST_DIR&#125;:/var/lib/postgresql/data</span><br></pre></td></tr></table></figure>
<p>使用 <code>volumes</code> 設定 host 與 container 所對應的目錄，將來 PostgreSQL 所寫入資料，將寫入 host 目錄。</p>
<p><code>:</code> 左側為 host 目錄，右側為 container 內目錄。</p>
<blockquote>
<p>相當於 <code>docker run</code> 的 <code>-v</code></p>
</blockquote>
<p><code>POSTGRES_HOST_DIR</code> 將在 <code>.env</code> 中設定。</p>
<p>第 9 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expose:&#10;  - 5432</span><br></pre></td></tr></table></figure>
<p>使用 <code>expose</code> 設定 container 的 port。</p>
<p>第 11 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ports:&#10;  - $&#123;POSTGRES_PORT&#125;:5432</span><br></pre></td></tr></table></figure>
<p>使用 <code>ports</code> 設定 host 與 container 所 mapping 的 port。</p>
<p><code>:</code> 左側為 host 的 port，右側為 container 的 port。</p>
<blockquote>
<p>相當於 <code>docker run</code> 的 <code>-p</code></p>
</blockquote>
<p><code>POSTGRES_PORT</code> 將在 <code>.env</code> 中設定。</p>
<p>13 行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">environment:&#10;    - POSTGRES_DB=$&#123;POSTGRES_DB&#125;&#10;    - POSTGRES_USER=$&#123;POSTGRES_USER&#125;&#10;    - POSTGRES_PASSWORD=$&#123;POSTGRES_PASSWORD&#125;</span><br></pre></td></tr></table></figure>
<p>設定 PostgreSQL 的 database、user 與 password，此為 PostgreSQL 所需要的環境變數。</p>
<blockquote>
<p>相當於 <code>docker run</code> 的 <code>-e</code></p>
</blockquote>
<p><code>POSTGRES_DB</code>、<code>POSTGRES_USER</code> 與 <code>POSTGRES_PASSWORD</code> 將在 <code>.env</code> 中設定。</p>
<h3 id="-env">.env</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">HOST_DIR=<span class="value">~/Postgres</span></span></span><br><span class="line"><span class="setting">POSTGRES_PORT=<span class="value"><span class="number">1234</span></span></span></span><br><span class="line"><span class="setting">POSTGRES_DB=<span class="value">eflab</span></span></span><br><span class="line"><span class="setting">POSTGRES_USER=<span class="value">admin</span></span></span><br><span class="line"><span class="setting">POSTGRES_PASSWORD=<span class="value"><span class="number">12345</span></span></span></span><br></pre></td></tr></table></figure>
<p>此為 <code>Docker-compose.yml</code> 所設定的環境變數，被獨立在 <code>.env</code> 中，可單獨設定，不用修改 <code>Docker-compose.yml</code>。</p>
<h3 id="Docker-compose_up">Docker-compose up</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose up <span class="operator">-d</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>docker-compose up</code> 啟動 PostgreSQL。</p>
<p><code>-d</code> : <code>d</code>etach，建立 container 後，就脫離目前 process</p>
<p><img src="/images/docker/postgres/post001.png" alt="post001"></p>
<h3 id="Docker-compose_down">Docker-compose down</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>docker-compose down</span><br></pre></td></tr></table></figure>
<p>使用 <code>docker-compose down</code> 結束 PostgreSQL，並且刪除 container。</p>
<p><img src="/images/docker/postgres/post002.png" alt="post002"></p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>要在 Mac 使用 PostgreSQL，最簡單的方式就是使用 Docker</li>
<li><code>docker-run</code> 與 <code>Docker-Compose</code> 都可以啟動 PostgreSQL，實務上建議使用 <code>Docker-Compose</code>，將變數寫在 <code>.env</code> 中，這樣可使用 <code>docker-compose up -d</code> 就可啟動 PostgreSQL，<code>docker-compose down</code> 就可結束 PostgreSQL，不用再擔心參數問題</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/PostgresDocker" target="_blank" rel="external">GitHub</a> 上找到</p>
]]></content>
    <summary type="html">
    <![CDATA[在 Mac 最簡單使用 PostgreSQL 方式就是使用 Docker]]>
    
    </summary>
    
      <category term="Docker" scheme="https://oomusou.io/tags/Docker/"/>
    
      <category term="PostgreSQL" scheme="https://oomusou.io/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入探討 C# 之 Extension Method]]></title>
    <link href="https://oomusou.io/csharp/extension-method/"/>
    <id>https://oomusou.io/csharp/extension-method/</id>
    <published>2018-07-22T12:23:43.000Z</published>
    <updated>2018-07-22T10:52:27.838Z</updated>
    <content type="html"><![CDATA[<p>C# 3 的 Extension Method 是很了不起的發明，讓我們在不修改原本 source code 的前提下，就能為 class 增加新 method，實現開放封閉原則，尤其對於 .NET Framework 或 package 的擴展特別有效。</p>
<p>事實上 Extension Method 在 Functional Programming 下另有妙用，讓我們輕易實現 Function Composition。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.6<br>.NET Core 2.1<br>C# 7.2<br>Rider 2018.1.3</p>
<h2 id="Extension_Method">Extension Method</h2><hr>
<p>首先來看 Extension Method 最標準的應用。</p>
<p><strong>Program.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Enumerable</span><br><span class="line">                .Range(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">                .Select(x =&gt; x * <span class="number">2</span>)</span><br><span class="line">                .ToList()</span><br><span class="line">                .ForEach(x =&gt; Console.WriteLine(x.ToString()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先使用 <code>Enumerable.Range()</code> 產生 <code>1, 2, 3</code>，再使用 <code>Select()</code> 變成 <code>2, 4, 6</code>，最後使用 <code>ForEach()</code> 印出來。</p>
<p>但中間出現了一個很詭異的 <code>ToList()</code>。</p>
<p>原因是因為 <code>IEnumerable</code> 沒有 <code>ForEach()</code>，只有 <code>List</code> 才有 <code>ForEach()</code>，因此我們必須先 <code>ToList()</code>。</p>
<p>但就語意來說，這是很怪的，<code>IEnumerable</code> 自帶 <code>Aggregate()</code>，為什麼卻沒有提供更常用的 <code>ForEach()</code> 呢 ?</p>
<p>既然 .NET Framework 沒有，我們就來替 <code>IEnumerable</code> 打造一個 <code>ForEach()</code> 吧。</p>
<p><strong>Extensions.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Extensions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">void</span> ForEach&lt;T&gt;(<span class="keyword">this</span> IEnumerable&lt;T&gt; source, Action&lt;T&gt; action)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (T element <span class="keyword">in</span> source)</span><br><span class="line">                action(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ForEach()</code> 第一個參數為 <code>this IEnumerable&lt;T&gt;</code>，注意特別加了 <code>this</code>，表示我們要為 <code>IEnumerable</code> 提供 <code>ForEach()</code> Extension Method。</p>
<p>且 Extension Method 必須都為 static method。</p>
<p><strong>Program.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Enumerable</span><br><span class="line">                .Range(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">                .Select(x =&gt; x * <span class="number">2</span>)</span><br><span class="line">                .ForEach(x =&gt; Console.WriteLine(x.ToString()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之後我們就能將奇怪的 <code>ToList()</code> 拿掉了，這樣的語意是不是更好呢 ?</p>
<blockquote>
<p>Extension Method 讓我們對 .NET Framework 或 package 加以擴充，用起來好像是內建的method 一樣，只要做兩件事情 :</p>
<ol>
<li>使用 static method</li>
<li>第一個參數為該 class 或 interface 型別，並加上 <code>this</code> 修飾</li>
</ol>
</blockquote>
<h2 id="Function_Composition">Function Composition</h2><hr>
<p>Function Composition 是 FP 的招牌菜，強調藉由眾多的小 functional 組合成大 function，而非傳統 imperative 寫法，總是寫出數百行的 method，且這些 method 幾乎是量身定做，不只重複使用的機會很低，且因為行數過多很難維護，也難以單元測試。</p>
<p><strong>Program.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> ConsoleApp.Email;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> john = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>);</span><br><span class="line">            <span class="function"><span class="keyword">string</span> <span class="title">EmailFor</span>(<span class="params">Person person</span>) </span>=&gt; AppendDomain(AbbreviateName(person));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> email = EmailFor(john);</span><br><span class="line">            </span><br><span class="line">            Console.WriteLine(email);</span><br><span class="line">            <span class="comment">// jodo@gmail.com</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EmailFor()</code> 能根據 user 的 <code>姓</code> 與 <code>名</code> 自動產生 email。</p>
<p>11 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">EmailFor</span>(<span class="params">Person person</span>) </span>=&gt; AppendDomain(AbbreviateName(person));</span><br></pre></td></tr></table></figure>
<p><code>EmailFor()</code> 為 C# 7 的 Local Function，藉由 <code>AbbreviateName()</code> 與 <code>AppendDomain()</code> 組合出新的 <code>EmailFor()</code>，這也就是所謂的 Function Composition : <code>h = fog = f(g)</code>，其中 <code>g</code> 就是 <code>AbbreviateName()</code>，而 <code>f</code> 就是 <code>AppendDomain()</code>。</p>
<p>這種數學式的 Function Composition 雖然重複使用性極高，但並不容易閱讀，程式碼必須 <code>由右而左</code>，違反一般人 <code>由左至右</code> 的閱讀習慣，因此想改用 Function Pipeline 方式變成 <code>由左至右</code>。</p>
<p><strong>Email.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Email</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">AbbreviateName</span>(<span class="params"><span class="keyword">this</span> Person person</span>)</span><br><span class="line">            </span>=&gt; Abbreviate(person.FirstName) + Abbreviate(person.LastName);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">AppendDomain</span>(<span class="params"><span class="keyword">this</span> <span class="keyword">string</span> localPart</span>) </span>=&gt; $<span class="string">"&#123;localPart&#125;@gmail.com"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">Abbreviate</span>(<span class="params"><span class="keyword">string</span> s</span>) </span>=&gt; s.Substring(<span class="number">0</span>, <span class="number">2</span>).ToLower();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>將 <code>AbbreviateName()</code> 與 <code>AppendDomain()</code> 的第一個參數都改加上 <code>this</code>，搖身一變成為 Extension Method。</p>
<p><strong>Program.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> ConsoleApp.Email;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConsoleApp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> email = </span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>)</span><br><span class="line">                    .AbbreviateName()</span><br><span class="line">                    .AppendDomain();</span><br><span class="line">            </span><br><span class="line">            Console.WriteLine(email);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>則原本的 <code>EmailFor()</code> Local Function 就不需要了，只要將 <code>Person</code> new 後，直接如 LINQ 般去 <code>AbbreviateName()</code> 與 <code>AppendDomain()</code>，這種風格維持了 <code>由左至右</code> 的閱讀習慣，非常清楚。</p>
<blockquote>
<p>只要將第一個參數加上 <code>this</code> 修飾成為 Extenstion Method 後，就可由 Function Composition 改成 Function Pipeline 風格</p>
</blockquote>
<h2 id="Refactoring">Refactoring</h2><hr>
<p>若 Legacy code 只用了 Function Composition，可以使用 Rider 幫我們重構成 Function Pipeline。</p>
<p><img src="/images/csharp/extension-method/em000.png" alt="em000"></p>
<p>Legacy code 並沒有使用 Extension Method。</p>
<p><img src="/images/csharp/extension-method/em001.png" alt="em001"></p>
<ol>
<li>將 cursor 放在 method 上</li>
<li>按熱鍵 <code>⌃ + T</code>，選擇 <code>Convert Static Method to Extension</code></li>
</ol>
<p><img src="/images/csharp/extension-method/em002.png" alt="em002"></p>
<ul>
<li>Rider 自動幫我們將第一個參數加上 <code>this</code></li>
</ul>
<p><img src="/images/csharp/extension-method/em003.png" alt="em003"></p>
<ol>
<li>使用端會重構成 Function Pipeline</li>
</ol>
<p><img src="/images/csharp/extension-method/em004.png" alt="em004"></p>
<p><code>EmailFor</code> 與 <code>john</code> 可以進一步 Inline 掉。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>Function Composition 與 Function Pipeline 講的是同一件事情，只是 Function Composition 偏數學，採用 <code>由右至左</code>，而 Function Pipeline 偏閱讀習慣，採用 <code>由左至右</code></li>
<li>Funciton Compostion 與 Function Pipeline 是 FP 極關鍵部分，以前總以為 C# 沒有支援，因此無法使用 C# 寫 FP，有了 Extension Method，C# 就能很輕鬆的實踐 FP</li>
<li>Rider 支援 <code>Convert static method to Extension</code>，讓我們快速重構成 Extension Method，再加上 <code>Inline Method</code> 與 <code>Inline Variable</code>，最後就會重構出 Function Pipeline</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/CSharpFunctionComposition" target="_blank" rel="external">GitHub</a> 與 <a href="https://github.com/oomusou/CSharpExtensionMethod" target="_blank" rel="external">GitHub</a> 上找到</p>
<h2 id="Reference">Reference</h2><hr>
<p>Enrico Buonanno, <a href="https://www.manning.com/books/functional-programming-in-c-sharp" target="_blank" rel="external">Functional Programming in C#</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Extension Method 是 C# 的獨門招式]]>
    
    </summary>
    
      <category term="C#" scheme="https://oomusou.io/tags/C/"/>
    
      <category term="Refactoring" scheme="https://oomusou.io/tags/Refactoring/"/>
    
      <category term="Rider" scheme="https://oomusou.io/tags/Rider/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rider Refactoring 之 Extract Local Function]]></title>
    <link href="https://oomusou.io/rider/extract-local-function/"/>
    <id>https://oomusou.io/rider/extract-local-function/</id>
    <published>2018-07-21T12:23:43.000Z</published>
    <updated>2018-07-21T15:04:49.607Z</updated>
    <content type="html"><![CDATA[<p>Local Function 是 C# 7 支援 FP 的重要功能，除了比 C# 3 的 Func 與 Action 可讀性高，速度也更快，因此建議全面使用 Local Function 取代 Func 與 Action。</p>
<p>透過 Rider，我們也可將 legacy code 快速重構成有 FP 風格的 Local Function。<br><a id="more"></a></p>
<h2 id="Version">Version</h2><p>macOS High Sierra 10.13.6<br>.NET Core 2.1<br>Rider 2018.1.3</p>
<h2 id="重構前">重構前</h2><hr>
<p><strong>Program.cs</strong></p>
<p><img src="/images/rider/extract-local-function/local000.png" alt="local000"></p>
<ol>
<li>傳統我們在寫 LINQ 時，會將 Lambda 寫在 <code>Where()</code> 內，若能將 Lambda 抽成 Local Function，則可讀性更高</li>
</ol>
<h2 id="Introduce_Variable">Introduce Variable</h2><hr>
<p><strong>Program.cs</strong></p>
<p><img src="/images/rider/extract-local-function/local001.png" alt="local001"></p>
<ol>
<li>選擇要抽的 Lambda</li>
</ol>
<p><img src="/images/rider/extract-local-function/local002.png" alt="local002"></p>
<ol>
<li>按熱鍵 <code>⌃ + T</code>，選擇 <code>Introduce Variable</code></li>
</ol>
<p><img src="/images/rider/extract-local-function/local004.png" alt="local002"></p>
<ol>
<li>Rider 會自動抽出 Func，不過卻也建議你改用 Local Function</li>
</ol>
<blockquote>
<p>Q : 為什麼 Rider 不直接抽成 Local Function ?</p>
</blockquote>
<p><img src="/images/rider/extract-local-function/local003.png" alt="local003"></p>
<p>因為 Local Function 屬於 C# 7 支援的新功能，只有當你選擇 C# 7 以上時，才會建議使用 Local Function。</p>
<h2 id="To_Local_Function">To Local Function</h2><hr>
<p><img src="/images/rider/extract-local-function/local005.png" alt="local005"></p>
<ol>
<li>將 cursor 放在 <code>predicate</code> 上</li>
<li>按熱鍵 <code>⌥ + ↩</code>，選擇 <code>To local function</code> </li>
</ol>
<p><img src="/images/rider/extract-local-function/local006.png" alt="local006"></p>
<p>Rider 會將 Local Function 轉型成 Func，這是不需要的，Rider 也已經反灰提示這是多餘的。</p>
<ol>
<li>將 cursor 放在反灰之處</li>
<li>按熱鍵 <code>⌥ + ↩</code>，選擇 <code>Remove redundant code in file</code> </li>
</ol>
<h2 id="Rename_Variable">Rename Variable</h2><hr>
<p><img src="/images/rider/extract-local-function/local007.png" alt="local007"></p>
<p>Rider 預設抽出的 Local Function 名稱都是 <code>Predicate</code>，可讀性不高，需要進一步重構</p>
<ol>
<li>將 cursor 放在 <code>Predicate</code> 上</li>
<li>按熱鍵 <code>⌥ + ↩</code>，選擇 <code>Rename</code> </li>
</ol>
<p><img src="/images/rider/extract-local-function/local008.png" alt="local008"></p>
<ol>
<li>重新命名為 <code>IsOdd</code></li>
</ol>
<h2 id="重構後">重構後</h2><hr>
<p><img src="/images/rider/extract-local-function/local009.png" alt="local009"></p>
<p>如此的程式碼，可讀性就很高。</p>
<ol>
<li><code>original</code> 陣列經過 <code>Where()</code> ，再經過 <code>ForEach()</code>，這正是 FP 所謂的 Function Pipeline</li>
<li><code>Where(IsOdd)</code> 可以明顯看出要 where 的是 <code>奇數</code>，<code>ForEach(WriteLine)</code> 可以看出 writeline 要 foreach，而 <code>WriteLine()</code> 與 <code>IsOdd()</code> 又各自是小小的 Local Function 構成，這正是 FP 所謂的 Function Composition</li>
</ol>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>要抽成 Local Function，直覺會想使用 Rider 的 <code>Extract Method</code>，但因為在 FP 觀念中，Function 就是 First-Class Value，所以在 Rider 要使用 <code>Introduce Variable</code>，而不是 <code>Extract Method</code></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[重構成 C# 7 的 Local Function]]>
    
    </summary>
    
      <category term="Refactoring" scheme="https://oomusou.io/tags/Refactoring/"/>
    
      <category term="Rider" scheme="https://oomusou.io/tags/Rider/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 Rider 使用 Vim ?]]></title>
    <link href="https://oomusou.io/rider/vim/"/>
    <id>https://oomusou.io/rider/vim/</id>
    <published>2018-07-21T12:23:43.000Z</published>
    <updated>2018-07-21T15:34:18.592Z</updated>
    <content type="html"><![CDATA[<p>Vim 是一個歷史悠久的編輯器，完全使用鍵盤操作，就算你使用 IDE，但其 <code>鍵盤操作</code> 的精神卻可以保留下來，讓你在開發時完全不需要摸到滑鼠與觸控板，而使用鍵盤全速開發。</p>
<p>在 Rider 只要安裝以下三個套件，就能順利在 Rider 使用 Vim，也適用於其他 JetBrains 產品。</p>
<a id="more"></a>
<h2 id="Verison">Verison</h2><hr>
<p>macOS High Sierra 10.13.6<br>Rider 2018.1.3</p>
<h2 id="IdeaVim">IdeaVim</h2><hr>
<p><img src="/images/rider/vim/extension003.png" alt="extension003"></p>
<p>由 JetBrains 自己所開發的 Vim 套件，讓你可以在 JetBrains 使用 Vim 熱鍵。</p>
<h2 id="Relative_Line_Numbers">Relative Line Numbers</h2><hr>
<p><img src="/images/rider/vim/extension004.png" alt="extension004"></p>
<p>Vim 的重要精神就是不用選取就可操作，所以必須知道目前 cursor 的相對行數。</p>
<p><img src="/images/rider/vim/extension005.png" alt="extension005"></p>
<p>裝了之後除了原本的 <code>行數</code>，還多了一排 <code>相對行數</code>。</p>
<h2 id="IdeaVimExtension">IdeaVimExtension</h2><hr>
<p><img src="/images/rider/vim/extension000.png" alt="extension000"></p>
<p>實務上在寫 <code>註解</code> 或單元測試的 <code>method 名稱</code> 時，有可能會使用中文，此時若切換回 Vim 的 Normal Mode，又必須重新切回 <code>英文輸入法</code> 才能下指令，非常不方便。</p>
<p>IdeaVimExtension 能在切換到 Normal Mode 時，自動切換到回 <code>英文輸入法</code>。</p>
<h3 id="編輯_-ideavimrc">編輯 .ideavimrc</h3><p>Rider 的 Vim 預設會執行 home directory 的 <code>.ideavimrc</code>，須在此啟動 IdeaVimExtension。</p>
<p><strong>.ideavimrc</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> keep-<span class="keyword">english</span>-<span class="operator">in</span>-<span class="keyword">normal</span></span><br></pre></td></tr></table></figure>
<p>在 <code>.ideavimrc</code> 加上這一行</p>
<p><img src="/images/rider/vim/extension002.png" alt="extension002"></p>
<p>再次重新啟動 Rider 後，當切換到 Normal Mode 時，就都會是 <code>英文輸入法</code> 。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>此技巧在 JetBrains 其他工具也適用</li>
<li>Rider 重構 + Vim 編輯，讓我們同時享受 IDE 與 Editor 的優點，等於是倚天劍 + 屠龍刀</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[完全使用鍵盤高速寫 code]]>
    
    </summary>
    
      <category term="Rider" scheme="https://oomusou.io/tags/Rider/"/>
    
      <category term="Vim" scheme="https://oomusou.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 .NET Core 使用 NUnit 與 NSubstitute ?]]></title>
    <link href="https://oomusou.io/nunit/setup/"/>
    <id>https://oomusou.io/nunit/setup/</id>
    <published>2018-07-10T13:23:43.000Z</published>
    <updated>2018-07-10T03:12:04.938Z</updated>
    <content type="html"><![CDATA[<p>在 <code>單元測試的藝術</code> 一書中，使用的是 <code>NUnit</code> 與 <code>NSubstitute</code>，但 .NET Core SDK 預設只提供 <code>MSTest</code> 與 <code>xUnit</code>，該如何在 .NET Core 使用我們熟悉的 <code>NUnit</code> 與 <code>NSubstitute</code> 呢 ?</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.4<br>.NET Core 2.1<br>NUnit 3.10.1<br>NSubstitute 3.1.0<br>Rider 2018.1.3</p>
<h2 id="Symptons">Symptons</h2><hr>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet <span class="keyword">new</span> -l</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>-l</strong> : <code>l</code>ist ，使用 <code>dotnet new</code> 加上 <code>-l</code> 參數，將列出目前系統所安裝的所有 project template。</li>
</ul>
<p><img src="/images/nunit/setup/setup000.png" alt="nunit000"></p>
<p>.NET Core SDK 預設只提供 <code>MSTest</code> 與 <code>xUnit</code> 的 project template。</p>
<p><img src="/images/nunit/setup/setup001.png" alt="nunit001"></p>
<ul>
<li>因為 .NET Core SDK 只有 <code>MSTest</code> 與 <code>XUnit</code>，因此 Rider 也只支援 <code>MSTest</code> 與 <code>xUnit</code></li>
</ul>
<h2 id="NUnit">NUnit</h2><hr>
<p><img src="/images/nunit/setup/setup002.png" alt="nunit002"></p>
<p>事實上在 .NET Core 官網的 <a href="https://github.com/dotnet/templating/wiki/Available-templates-for-dotnet-new" target="_blank" rel="external">Available templates for dotnet new</a>，還準備了不少其他 project template 可供下載，其中也包含了 <code>NUnit</code>。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet new -<span class="tag">i</span> <span class="string">"NUnit3.DotNetNew.Template::*"</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/nunit/setup/setup003.png" alt="nunit003"></p>
<p><img src="/images/nunit/setup/setup004.png" alt="nunit004"></p>
<ol>
<li>安裝完就會出現 <code>NUnit 3</code> project template</li>
</ol>
<p><img src="/images/nunit/setup/setup005.png" alt="nunit005"></p>
<ol>
<li>安裝完後，Rider 也會出現 <code>NUnit 3 Test Project</code></li>
</ol>
<h2 id="Project_Reference">Project Reference</h2><hr>
<p>將 Class Library 的 project reference 加到 Unit Test 專案。</p>
<p><img src="/images/nunit/setup/setup007.png" alt="nunit007"></p>
<ol>
<li>選擇 Unit Test 專案</li>
<li>按滑鼠右鍵選擇 <code>Add</code></li>
<li>選擇 <code>Add Reference</code></li>
</ol>
<p><img src="/images/nunit/setup/setup008.png" alt="nunit008"></p>
<ol>
<li>選擇 <code>ClassLib</code></li>
<li>按 <code>OK</code> 繼續</li>
</ol>
<h2 id="NSubstitute">NSubstitute</h2><hr>
<p>除了 <code>NUnit</code> 外，單元測試另外一個要角就是 <code>NSubstitute</code>，這要另外安裝。</p>
<p><img src="/images/nunit/setup/setup009.png" alt="nunit009"></p>
<ol>
<li>選擇 Unit Test 專案</li>
<li>按滑鼠右鍵選擇 <code>Manage NuGet Packages</code></li>
</ol>
<p><img src="/images/nunit/setup/setup006.png" alt="nunit006"></p>
<ol>
<li>在 NuGet 下輸入 <code>NSubstitute</code></li>
<li>選擇 <code>NSubstitute</code></li>
<li>在 Unit Test 專案下安裝 <code>NSubstitute</code></li>
</ol>
<h2 id="Parallel_Test">Parallel Test</h2><hr>
<p><code>NUnit</code> 預設並不是以 parallel 進行單元測試，而是以 sequential 方式，也就是 <code>一個單元測試執行完，才會進行下一個單元測試</code>，而不是每個單元測試平行執行。</p>
<p>這種方式雖然安全，但有幾個缺點：</p>
<ol>
<li>執行速度較慢，沒有完全發揮多核心 CPU 的優勢</li>
<li>Jenkins 會以 parallel 方式執行單元測試，因此每個單元測試之間不能相依，讓本機與 Jenkins 環境相同</li>
</ol>
<p><strong>AssemblyInfo.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> NUnit.Framework;</span><br><span class="line"></span><br><span class="line">[assembly:Parallelizable(ParallelScope.All)]</span><br></pre></td></tr></table></figure>
<p>在 Unit Test 專案下新增 <code>AssemblyInfo.cs</code>，對整個 Unit Test assembly 增加 <code>NUnit</code> 的 <code>Parallelizable</code> attribute，如此每個 test method 都會以 parallel 方式執行單元測試。</p>
<p><img src="/images/nunit/setup/setup010.png" alt="nunit010"></p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>.NET Core SDK 預設沒有支援 <code>NUnit</code>，但只要自行透過 <code>dotnet new -i</code>，即可安裝 <code>NUnit</code> project template</li>
<li><code>NSubstitute</code> 以 NuGet package 形式存在，必須另外安裝</li>
<li><code>NUnit</code> 預設以 sequential 方式執行 Unit Test，不僅沒發揮多核心 CPU 威力，也與 Jenkins 執行環境不同，建議在 Unit Test 專案增加 <code>AssemblyInfo.cs</code>，對整個 Unit Test assembly 增加 <code>Parallelizable(ParallelScope.All)</code> attribute，如此才會以 parallel 方式執行單元測試，也能提早發現 test method 彼此相依可能造成的問題</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/NUnitCore" target="_blank" rel="external">GitHub</a> 上找到</p>
]]></content>
    <summary type="html">
    <![CDATA[需要另外安裝 NUnit Project Template]]>
    
    </summary>
    
      <category term=".NET Core" scheme="https://oomusou.io/tags/NET-Core/"/>
    
      <category term="NSubstitute" scheme="https://oomusou.io/tags/NSubstitute/"/>
    
      <category term="NUnit" scheme="https://oomusou.io/tags/NUnit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rider Refactoring 之 Transform Parameters]]></title>
    <link href="https://oomusou.io/rider/transform-parameters/"/>
    <id>https://oomusou.io/rider/transform-parameters/</id>
    <published>2018-07-08T12:23:43.000Z</published>
    <updated>2018-07-09T04:13:01.840Z</updated>
    <content type="html"><![CDATA[<p>在實務上常會發現一些 parameter 總是以 primitive type 一起出現，導致 method 內的 parameter 個數過多，也就是 Code Smell 所謂的 <code>Primitive Obsession</code>，解決方式是將這些 parameter 抽成 class，這在 Refactoring 稱為 <code>Introduce Parameter Object</code>，而在 Rider 則稱為 <code>Transform Parameters</code>，且實務上常常搭配 <code>Make Method Non-Static</code> 一起重構。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.4<br>.NET Core 2.1<br>Rider 2018.1.3</p>
<h2 id="重構前">重構前</h2><hr>
<p><strong>StateroomService.cs</strong></p>
<p><img src="/images/rider/transform-parameters/tp004.png" alt="tp004"></p>
<p>第 9 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">decimal</span> <span class="title">TotalAmount</span>(<span class="params">DateTime startTime, DateTime endTime</span>)</span></span><br></pre></td></tr></table></figure>
<p>我們發現 <code>startTime</code> 與 <code>endTime</code> 總是一起出現，這正是典型的 <code>Primitive Obsession</code>，因此我們想將 <code>startTime</code> 與 <code>endTime</code> 抽成 <code>Period</code> class。</p>
<blockquote>
<p><strong>Primitive Obsession</strong></p>
<p>過度使用程式語言所提供的基本型別，卻忘記使用使用更有意義的 class 型別</p>
</blockquote>
<h2 id="Transform_Parameters">Transform Parameters</h2><hr>
<p>將 primitive type 的 parameter 抽成 class，也就是 Refactoring 中的 <code>Introduce Parameter Object</code>。</p>
<p><img src="/images/rider/transform-parameters/tp000.png" alt="tp000"></p>
<ol>
<li>將 cursor 放到要抽的 parameter 上</li>
<li>按熱鍵 <code>⌃ + T</code> ，選擇 <code>Transform Parameters</code></li>
</ol>
<p><img src="/images/rider/transform-parameters/tp001.png" alt="tp001"></p>
<ol>
<li>選擇要抽出的 parameter</li>
<li><strong>Method receives</strong> : 選擇要抽成 Class 或 Tuple</li>
<li>輸入 class 名稱</li>
<li>按 <code>Next</code> 繼續</li>
</ol>
<p><img src="/images/rider/transform-parameters/tp002.png" alt="tp002"></p>
<ol>
<li>抽出了 <code>Period</code> class</li>
<li><code>TotalAmount</code> 的 parameter 也由兩個 <code>DateTime</code> 重構成只有一個 <code>Period</code></li>
</ol>
<blockquote>
<p>Rider 預設會將 class 抽在同一個檔案，但實務上建議 1 個檔案只有 1 個 class，因此會繼續重構，將 <code>Period</code> class 獨立成一個檔案</p>
</blockquote>
<h2 id="Move_Class_to_File">Move Class to File</h2><hr>
<p>將 class 抽成獨立的檔案。</p>
<p><img src="/images/rider/transform-parameters/tp005.png" alt="tp005"></p>
<ol>
<li>將 cursor 放到 <code>Period</code> 上</li>
<li>按熱鍵 <code>⌥ + ↩</code>，選擇 <code>Move to &#39;Period.cs&#39;</code></li>
</ol>
<p><img src="/images/rider/transform-parameters/tp006.png" alt="tp006"></p>
<ol>
<li>重構出獨立的 <code>Period.cs</code> 檔案</li>
</ol>
<h2 id="Extract_Method">Extract Method</h2><hr>
<p>將一段 code 抽成 method。</p>
<p><img src="/images/rider/transform-parameters/tp007.png" alt="tp007"></p>
<ol>
<li><code>days</code> 由 <code>period.EndTime</code> 與 <code>period.StartTime</code> 計算所得，明明在 <code>StateroomService</code> 內，卻一直讀取 <code>Period</code> 的資料，這正是典型的 <code>Feature Envy</code>，需進一步抽成 method，然後 <code>Move Method</code> 到 <code>Period</code> </li>
</ol>
<blockquote>
<p><strong>Feature Envy</strong></p>
<p>不斷的向其他 class 取值，然後在自己的 class 運算</p>
</blockquote>
<p><img src="/images/rider/transform-parameters/tp008.png" alt="tp008"></p>
<ol>
<li>選擇要抽取的 code</li>
<li>按熱鍵 <code>⌃ + T</code> ，選擇 <code>Extract Method</code></li>
</ol>
<p><img src="/images/rider/transform-parameters/tp009.png" alt="tp009"></p>
<ol>
<li>選擇 <code>Method</code></li>
<li>按 <code>Next</code> 繼續</li>
</ol>
<p><img src="/images/rider/transform-parameters/tp010.png" alt="tp010"></p>
<ol>
<li>抽出 <code>Days</code> method</li>
<li>預設將 <code>Make static</code> 打勾</li>
<li>按 <code>Next</code> 繼續</li>
</ol>
<blockquote>
<p><strong>Make static 的重要性</strong></p>
<ul>
<li>若能抽成 <code>static</code>，Rider 會自動將 <code>Make static</code> 打勾，這表示該 method 已經與此 class 沒有任何瓜葛 (沒使用 field)，可隨時 <code>Move Method</code> 到其他 class</li>
<li>若不能抽成 <code>static</code>，則表示此 method 仍使用該 class 的 field，須先進一步重構，直到能抽成 <code>static</code> method 後，才能 <code>Move Method</code> 到其他 class</li>
<li>若要繼續使用 <code>Make Method Non-Static</code> 重構，則 <code>static</code> method 為其必要條件，否則無法繼續使用 <code>Make Method Non-Static</code></li>
</ul>
</blockquote>
<h2 id="Make_Method_Non-Static">Make Method Non-Static</h2><hr>
<p>將 <code>Static</code> method  重構到 parameter object 的 instance method，也就是 Refactoring 中的 <code>Move Method</code>。</p>
<p><img src="/images/rider/transform-parameters/tp011.png" alt="tp011"></p>
<ol>
<li>將 cursor 放在 <code>Days()</code> 上</li>
<li>按熱鍵 <code>⌃ + T</code> ，選擇 <code>Make Method Non-Static</code></li>
</ol>
<p><img src="/images/rider/transform-parameters/tp012.png" alt="tp012"></p>
<ol>
<li>選擇要 <code>Move Method</code> 到 <code>Period</code> </li>
<li>按 <code>Next</code> 繼續</li>
</ol>
<p><img src="/images/rider/transform-parameters/tp013.png" alt="tp013"></p>
<ol>
<li><code>Days()</code> 被搬到 <code>Period</code> </li>
</ol>
<p><img src="/images/rider/transform-parameters/tp014.png" alt="tp014"></p>
<ol>
<li>直接呼叫 <code>period.Days()</code></li>
</ol>
<blockquote>
<p><code>Make Method Non-Static</code> 本質上就是 <code>Move Method</code>，只是因為 <code>Make Method Non-Static</code> 的名稱，會讓人誤以為只是單純的將一個 method 由 <code>static</code> 重構成 <code>non-static</code> 而已，但事實上不只單純的重構成 <code>non-static</code>，還會將整個 method 搬到 parameter object 上，所以若 <code>Extract Method</code> 所抽出的 parameter，不是要我們要 <code>Move Method</code> 的 class，我們還會透過 <code>Change Parameter</code> 加以重構 parameter，讓 <code>Make Method Non-Static</code> 可以繼續進行</p>
</blockquote>
<h2 id="Inline_Variable">Inline Variable</h2><hr>
<p>將不必要的 <code>中介變數</code> 去除。</p>
<p><img src="/images/rider/transform-parameters/tp015.png" alt="tp015"></p>
<ol>
<li><code>days</code> 可以再加以 inline</li>
</ol>
<p><img src="/images/rider/transform-parameters/tp016.png" alt="tp016"></p>
<ol>
<li>將 cursor 放在 <code>days</code> 上</li>
<li>按熱鍵 <code>⌃ + T</code> ，選擇 <code>Inline Variable</code></li>
</ol>
<p><img src="/images/rider/transform-parameters/tp017.png" alt="tp017"></p>
<ol>
<li><code>days</code> 變數被 inline 掉了</li>
</ol>
<p><img src="/images/rider/transform-parameters/tp018.png" alt="tp018"></p>
<ol>
<li>同理，<code>days</code> 也可再被 inline 掉</li>
</ol>
<p><img src="/images/rider/transform-parameters/tp019.png" alt="tp019"></p>
<ol>
<li><code>days</code> 變數被 inline 掉了</li>
</ol>
<blockquote>
<p>由於 <code>職責</code> 變清楚，因此少掉了很多不必要的 parameter 與 variable，不只 code 變的清爽，可讀性也高，也更容易維護</p>
</blockquote>
<h2 id="執行單元測試">執行單元測試</h2><hr>
<p><img src="/images/rider/transform-parameters/tp020.png" alt="tp020"></p>
<ul>
<li>重新跑單元測試，確認 production code 沒被重構壞掉</li>
</ul>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li><code>Primitive Obsession</code> 是很常見的 Code Smell，由於太堅持使用 primitive type，而喪失發現 object 的機會，導致 OOP 名存實亡，透過 Rider 的 <code>Transform Parameters</code>，我們可以直接將 parameter 將抽成 class，這對 legacy code 重構非常方便</li>
<li><code>Feature Envy</code> 也是很常見的 Code Smell，由於 class A 一直使用 class B，因此需要很多中介的 parameter 與 variable，透過 Rider 的 <code>Extract Method</code>，我們可以直接將 class A 的一段 code 抽成 method，然後透過 <code>Make Method Non-Static</code> 般到 class B，這會使得 class 與 class 間的 <code>職責</code> 更為清楚，也可將不必要的 parameter 與 variable 重構掉</li>
<li><code>Transform Parameters</code> 與 <code>Make Method Non-Static</code> 常常一起執行，因為既然已經使用 <code>Transform Parameters</code> 將 parameter 抽成新的 object，根據 OOP 的 <code>職責</code> 思維，必然將一些 code 透過 <code>Make Method Non-Static</code> 搬到新的 class，如此才能避免 <code>Primitive Obsession</code> 與 <code>Feature Envy</code></li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/RiderTransformParameters" target="_blank" rel="external">GitHub</a> 上找到</p>
]]></content>
    <summary type="html">
    <![CDATA[Rider 最具威力的重構功能之一]]>
    
    </summary>
    
      <category term="Refactoring" scheme="https://oomusou.io/tags/Refactoring/"/>
    
      <category term="Rider" scheme="https://oomusou.io/tags/Rider/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 Rider 從 Editor 與 Terminal 快速切換 ?]]></title>
    <link href="https://oomusou.io/rider/terminal-esc/"/>
    <id>https://oomusou.io/rider/terminal-esc/</id>
    <published>2018-06-27T12:23:43.000Z</published>
    <updated>2018-06-27T05:26:10.791Z</updated>
    <content type="html"><![CDATA[<p>在 .NET Core 使用 CLI 的機會越來越多，因此如何在 Rider 從 Editor 與 Terminal 快速切換，是一個不可逃避的問題，當然可以用滑鼠慢慢的點，但若能完全使用鍵盤操作，整個 workflow 會非常的順。</p>
<p>將設定使用  <code>⌃ + ~</code> 啟動 Terminal，<code>ESC</code> 離開 Terminal 回 Editor。</p>
<a id="more"></a>
<h2 id="Verison">Verison</h2><hr>
<p>macOS High Sierra 10.13.4<br>.NET Core 2.1.1<br>Rider 2018.1.2</p>
<h2 id="重新設定_Terminal_熱鍵">重新設定 Terminal 熱鍵</h2><hr>
<p>Rider 預設的 terminal 熱鍵是 <code>⌥ + F12</code>，這個熱鍵組合勢必用到 <code>雙手</code>，我建議改成 VS Code 的 <code>⌃ + ~</code>，只要 <code>單手</code>就能啟動 terminal，非常順手。</p>
<p><img src="/images/rider/terminal-esc/esc000.png" alt="esc000"></p>
<ol>
<li><strong><em>JetBrains Rider -&gt; Preferences -&gt; Keymap</em></strong></li>
<li>輸入 <code>terminal</code></li>
<li>選擇 <code>Tool Windows -&gt; Terminal</code></li>
</ol>
<p><img src="/images/rider/terminal-esc/esc001.png" alt="esc001"></p>
<ol>
<li>按滑鼠右鍵選擇 <code>Add Keyboard Shoarcut</code></li>
</ol>
<p><img src="/images/rider/terminal-esc/esc002.png" alt="esc002"></p>
<ol>
<li>重新定義熱鍵  <code>⌃ + ~</code></li>
</ol>
<h2 id="Terminal_自動隱藏">Terminal 自動隱藏</h2><hr>
<p><img src="/images/rider/terminal-esc/esc003.png" alt="esc003"></p>
<ol>
<li>Termial 的 <code>Docked Mode</code> 與 <code>Floating Mode</code> 都不要勾選</li>
</ol>
<blockquote>
<p>如此就能隨著 <code>ESC</code> 而自動隱藏，如 Solution、Database 也建議如此設定</p>
</blockquote>
<h2 id="使用_ESC_自動隱藏_Terminal">使用 ESC 自動隱藏 Terminal</h2><hr>
<p>對於 Rider 其它視窗，如 Solution、Database，只要 <code>ESC</code> 按下就會自動隱藏，但是 Terminal 是特例，按 <code>ESC</code> 竟然不會隱藏</p>
<p><img src="/images/rider/terminal-esc/esc004.png" alt="esc004"></p>
<ol>
<li><strong><em>JetBrains Rider -&gt; Preferences -&gt; Tools -&gt; Terminal</em></strong></li>
<li><code>Override IDE shortcuts</code> 不要勾選</li>
<li>按 <code>Save</code> 存檔</li>
</ol>
<blockquote>
<p>也就是 Rider 當初有特別考量，希望 Terminal 有自己的 <code>ESC</code>，不要吃 Rider 整體的 <code>ESC</code>，但這會使 Terminal 不會隨著按下 <code>ESC</code> 而隱藏</p>
</blockquote>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>此技巧在 JetBrains 其他工具也適用</li>
<li>Rider 是一個開發 .NET Core 很舒服的工具，尤其在這麼短的時間，就已經將 Resharper 與 IntelliJ 的精華融合在 Rider 上，目前我還沒遇到什麼 Resharper 重構無法在 Rider 執行，假如你覺得 Visual Studio + Resharper 太慢，又想在 macOS 開發 .NET Core，Rider 真的是非常推薦的工具</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[完全使用鍵盤操作才會快]]>
    
    </summary>
    
      <category term="Rider" scheme="https://oomusou.io/tags/Rider/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用 pgcli 連上 PostgreSQL ?]]></title>
    <link href="https://oomusou.io/postgres/pgcli/"/>
    <id>https://oomusou.io/postgres/pgcli/</id>
    <published>2018-06-14T13:23:43.000Z</published>
    <updated>2018-06-14T15:00:24.348Z</updated>
    <content type="html"><![CDATA[<p>傳統都會使用 GUI 工具連上 database，如 DataGrip、SQLPro Studio，若只是想簡單確定資料有沒有寫入成功，簡單的 CLI 工具會更方便，pgcli 就是一套在 CLI 連接 PostgreSQL 的小工具。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.4<br>Docker for Mac 18.03-ce-mac65 (24312)<br>PostgreSQL 10.3<br>pgcli 1.9.1</p>
<h2 id="安裝_pgcli">安裝 pgcli</h2><hr>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">brew </span>install pgcli</span><br></pre></td></tr></table></figure>
<p>使用 Homebrew 安裝 pgcli。</p>
<p><img src="/images/postgres/pgcli/pgcli000.png" alt="pgcli000"></p>
<ol>
<li>pgcli 非常的小，也沒有任何 dependency</li>
</ol>
<h2 id="連上_PostgreSQL">連上 PostgreSQL</h2><hr>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>pgcli <span class="symbol">postgresql:</span>/<span class="regexp">/admin:12345@localhost:5432/eflab</span></span><br></pre></td></tr></table></figure>
<p>輸入 <code>pgcli</code> 連接 PostgreSQL。</p>
<ul>
<li>以 <code>postgresql://</code> 開頭</li>
<li><code>admin</code> 為 username，<code>12345</code> 為 password，中間以 <code>:</code> 隔開</li>
<li><code>@</code> 之後接 server 名稱，<code>5432</code> 為 port，中間以 <code>:</code> 隔開</li>
<li><code>/</code> 之後接 database</li>
</ul>
<p><img src="/images/postgres/pgcli/pgcli001.png" alt="pgcli000"></p>
<h2 id="直接下_SQL">直接下 SQL</h2><hr>
<p><img src="/images/postgres/pgcli/pgcli002.png" alt="pgcli002"></p>
<p>可直接下 SQL 指令，也有 Intellisense。</p>
<p><img src="/images/postgres/pgcli/pgcli003.png" alt="pgcli003"></p>
<p>正確顯示資料。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>若想簡單的對 PostgreSQL 下 SQL 查資料，其實不太需要全功能的 GUI 工具，只要 pgcli 就能勝任，重點是讓你完全在 CLI 工作</li>
</ul>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://github.com/dbcli" target="_blank" rel="external">dbcli</a>, <a href="https://github.com/dbcli/pgcli" target="_blank" rel="external">dbcli/pgcli</a></p>
]]></content>
    <summary type="html">
    <![CDATA[使用 CLI 管理 PostgreSQL]]>
    
    </summary>
    
      <category term="PostgreSQL" scheme="https://oomusou.io/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 Entity Framework Core 使用 Data Seeding ? (PostgreSQL)]]></title>
    <link href="https://oomusou.io/efcore/data-seeding/"/>
    <id>https://oomusou.io/efcore/data-seeding/</id>
    <published>2018-06-14T12:23:43.000Z</published>
    <updated>2018-06-14T14:37:22.451Z</updated>
    <content type="html"><![CDATA[<p>當使用 Code First 與 Migration 後，下一步就是 Data Seeding，讓我們對 table 新增基本的資料。在 EF Core 2.0，Data Seeding 只能自己手動處理，在 EF Core 2.1 正式提供 Data Seeding。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.4<br>Docker for Mac 18.03-ce-mac65 (24312)<br>.NET Core 2.1<br>Entity Framework 2.1<br>PostgreSQL 10.3<br>Npgsql EF Core Provider 2.1<br>VS Code 1.24.0<br>DataGrip 2018.4</p>
<h2 id="建立資料">建立資料</h2><hr>
<p>我們可以將一些 database 預設的資料寫在 <code>DbContext.OnModelCreating()</code>，這樣在 Migration 時，就會順便將資料寫進 database。<span class="margin-note-marker"><sup>1</sup></span> <span class="block margin-div-outer"><span class="block margin-div-inner"><span class="block margin-note"><span class="margin-note-marker">1</span>本文為 <a href="/efcore/migration/">如何在 Entity Framework Core 使用 Migration ? (PostgreSQL)</a> 內容之延續，請搭配參考</span></span></span></p>
<p><strong>EFLabDbContext.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">EFCoreMigration</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EFLabDbContext</span>: <span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;Customer&gt; Customers &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> DbConnectionString = <span class="string">"Host=localhost;Port=5432;Database=eflab;Username=admin;Password=12345"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            optionsBuilder.UseNpgsql(DbConnectionString);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            modelBuilder.Entity&lt;Customer&gt;().HasData(<span class="keyword">new</span> Customer &#123;</span><br><span class="line">                Name = <span class="string">"Sam"</span>,</span><br><span class="line">                Age = <span class="number">18</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            modelBuilder.Entity&lt;Customer&gt;().HasData(<span class="keyword">new</span> Customer &#123;</span><br><span class="line">                Name = <span class="string">"Kevin"</span>,</span><br><span class="line">                Age = <span class="number">19</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    modelBuilder.Entity&lt;Customer&gt;().HasData(<span class="keyword">new</span> Customer &#123;</span><br><span class="line">        Name = <span class="string">"Sam"</span>,</span><br><span class="line">        Age = <span class="number">18</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">            </span><br><span class="line">    modelBuilder.Entity&lt;Customer&gt;().HasData(<span class="keyword">new</span> Customer &#123;</span><br><span class="line">        Name = <span class="string">"Kevin"</span>,</span><br><span class="line">        Age = <span class="number">19</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如同設定 connection string 要 override <code>OnConfiguring()</code>，若要使用 Data Seeding 則要 override <code>OnModelCreating()</code>。</p>
<p>使用 <code>modelBuilder.Entity&lt;T&gt;().HasData()</code> 新增資料，其中 <code>&lt;T&gt;</code> 為要新增的 Entity 型別。</p>
<p>因為 <code>CustomerID</code> 為 PK，PostgreSQL 會自動處理，所以我們就不特別指定，只設定 <code>Name</code> 與 <code>Age</code> 兩個欄位。</p>
<p><img src="/images/efcore/data-seeding/seeding000.png" alt="seeding000"></p>
<h2 id="建立_Migration">建立 Migration</h2><hr>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/EFCoreMigration $ dotnet ef migrations <span class="keyword">add </span>Migration02</span><br></pre></td></tr></table></figure>
<p>因為我們對 DbContext 做了變動，所以要重新建立 Migration。</p>
<p>輸入 <code>dotnet ef migrations add</code> 建立新的 Migration。</p>
<p><img src="/images/efcore/data-seeding/seeding001.png" alt="seeding001"></p>
<ol>
<li>建立 Migration 出現錯誤，EF Core 抱怨 <code>CustomerID</code> 沒有提供。</li>
</ol>
<p>這目前在 .NET Core 2.1 為 <a href="https://github.com/aspnet/EntityFrameworkCore/issues/11776" target="_blank" rel="external">Known Issue</a>，當使用  <code>modelBuilder.Entity&lt;T&gt;().HasData()</code> 做 Data Seeding 時，目前連 PK 這種 auto-generated 欄位，也必須手動提供。</p>
<p><strong>EFLabDbContext.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">EFCoreMigration</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EFLabDbContext</span>: <span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;Customer&gt; Customers &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> DbConnectionString = <span class="string">"Host=localhost;Port=5432;Database=eflab;Username=admin;Password=12345"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            optionsBuilder.UseNpgsql(DbConnectionString);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> customerID = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            modelBuilder.Entity&lt;Customer&gt;().HasData(<span class="keyword">new</span> Customer &#123;</span><br><span class="line">                CustomerID = customerID++,</span><br><span class="line">                Name = <span class="string">"Sam"</span>,</span><br><span class="line">                Age = <span class="number">18</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            modelBuilder.Entity&lt;Customer&gt;().HasData(<span class="keyword">new</span> Customer &#123;</span><br><span class="line">                CustomerID = customerID++,</span><br><span class="line">                Name = <span class="string">"Kevin"</span>,</span><br><span class="line">                Age = <span class="number">19</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> customerID = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    modelBuilder.Entity&lt;Customer&gt;().HasData(<span class="keyword">new</span> Customer &#123;</span><br><span class="line">        CustomerID = customerID++,</span><br><span class="line">        Name = <span class="string">"Sam"</span>,</span><br><span class="line">        Age = <span class="number">18</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">            </span><br><span class="line">    modelBuilder.Entity&lt;Customer&gt;().HasData(<span class="keyword">new</span> Customer &#123;</span><br><span class="line">        CustomerID = customerID++,</span><br><span class="line">        Name = <span class="string">"Kevin"</span>,</span><br><span class="line">        Age = <span class="number">19</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>將 PK 的 <code>CustomerID</code> 加入，並自行使用 <code>customerID++</code> 處理。</p>
<p><img src="/images/efcore/data-seeding/seeding007.png" alt="seeding007"></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/EFCoreMigration $ dotnet ef migrations <span class="keyword">add </span>Migration02</span><br></pre></td></tr></table></figure>
<p>再重新建立一次 Migration，這次就成功了。</p>
<p><img src="/images/efcore/data-seeding/seeding002.png" alt="seeding002"></p>
<p><strong>Migration02.cs</strong></p>
<p><img src="/images/efcore/data-seeding/seeding003.png" alt="seeding003"></p>
<p>觀察 <code>Migration02.Up()</code>，發現我們剛剛使用  <code>modelBuilder.Entity&lt;T&gt;().HasData()</code> 新增的資料，已經成為 Migration 的一部分。</p>
<p><strong>ModelSnapshot.cs</strong></p>
<p><img src="/images/efcore/data-seeding/seeding004.png" alt="seeding004"></p>
<p>觀察 <code>ModelSnapshot.cs</code>，發現我們剛剛使用  <code>modelBuilder.Entity&lt;T&gt;().HasData()</code> 新增的資料也寫入了 <code>ModelSnapshot.cs</code>，因此之後再建立新的 Migration 時，就有了 golden sample 可以比對，不會重複新增 Data Seeding 資料。</p>
<h2 id="執行_Migration">執行 Migration</h2><hr>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/<span class="type">EFCoreMigration</span> $ <span class="keyword">dotnet</span> ef database update</span><br></pre></td></tr></table></figure>
<p>輸入 <code>dotnet ef database update</code> 執行 Migration。</p>
<p><img src="/images/efcore/data-seeding/seeding005.png" alt="seeding005"></p>
<ol>
<li>只執行了 <code>Migration02</code></li>
</ol>
<h2 id="確認資料">確認資料</h2><hr>
<p><img src="/images/efcore/data-seeding/seeding006.png" alt="seeding006"></p>
<ul>
<li>兩筆資料已經透過 Data Seeding 新增至 database</li>
</ul>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>理論上在 Data Seeding 時，PK 欄位應該要省略，但目前 EF Core 2.1 的 <code>HasData()</code> 仍必須自己處理 PK 欄位，是比較可惜的地方</li>
<li>Data Seeding 最大的用處在於使用 Docker 的 <code>整合測試</code>，當一個測試案例執行時，PostgreSQL 隨著 <code>docker-compose up -d</code> 而跑起來，此時 database 是空的，必須重新執行 Migration 與 Data Seeding，將 schema 與基本資料建立起來，然後才能讓每個測試案例新增測試資料跑測試</li>
<li>Data Seeding 也可以用在 production 環境，當 production 環境需要一些基本資料才能正常執行時，就適合使用 Data Seeding</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/EFCoreMigration" target="_blank" rel="external">GitHub</a> 上找到</p>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://docs.microsoft.com/en-us/" target="_blank" rel="external">Microsoft Docs</a>, <a href="https://docs.microsoft.com/en-us/ef/core/modeling/data-seeding" target="_blank" rel="external">Data Seeding</a><br><a href="https://github.com/aspnet/EntityFrameworkCore" target="_blank" rel="external">Entity Framework Core</a>, <a href="https://github.com/aspnet/EntityFrameworkCore/issues/11776" target="_blank" rel="external">Seeding data: The seed entity for entity type ‘X’ cannot be added because there was no value provided for the required property ‘Id’.</a></p>
]]></content>
    <summary type="html">
    <![CDATA[EF Core 2.1 終於支援 Data Seeding]]>
    
    </summary>
    
      <category term="EF Core" scheme="https://oomusou.io/tags/EF-Core/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 Entity Framework Core 使用 Migration ? (PostgreSQL)]]></title>
    <link href="https://oomusou.io/efcore/migration/"/>
    <id>https://oomusou.io/efcore/migration/</id>
    <published>2018-06-13T12:23:43.000Z</published>
    <updated>2018-06-21T05:43:14.751Z</updated>
    <content type="html"><![CDATA[<p>透過 PostgreSQL 官方提供的 Npgsql EF Core Provider，Entity Framework Core 也能簡單地存取 PostgreSQL。</p>
<p>本文將使用 Code First 方式對 PostgreSQL 建立 database schema，並解釋 Migration 背後運作原理。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.4<br>Docker for Mac 18.03-ce-mac65 (24312)<br>.NET Core 2.1<br>Entity Framework 2.1<br>PostgreSQL 10.3<br>Npgsql EF Core Provider 2.1<br>VS Code 1.24.0<br>DataGrip 2018.1.4</p>
<h2 id="Definition">Definition</h2><hr>
<blockquote>
<p><strong>Code First</strong></p>
<p>會先在 code 建立 <code>DbContext</code> 與 <code>Entity</code> ，然後透過 Migration 在 database 建立 schema</p>
<p>Q : 為什麼要使用 Code First 與 Migration ?</p>
</blockquote>
<p>A : 傳統都會使用視覺化工具建立 database schema，這種方式雖然直覺，但有以下缺點：</p>
<ul>
<li>Schema 建立步驟無法透過 Git 版控</li>
<li>無法很簡單的同步 development / lab / stage / production 各 server 環境的 database schema</li>
</ul>
<p>EF Core 提供以下解決方案：</p>
<ul>
<li>透過 Code First，schema 改用 Entity 描述，我們可將 Migration 檔案進行 Git 版控，明確地知道 schema 變化過程</li>
<li>透過 Migration，只要在各 server 執行 <code>dotnet ef database update</code>，就能確保 schema 同步</li>
</ul>
<h2 id="建立_Console_App">建立 Console App</h2><hr>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet <span class="keyword">new</span> <span class="built_in">console</span> -o EFCoreMigration</span><br></pre></td></tr></table></figure>
<p>使用 <code>dotnet new</code> 建立 .NET Core App。</p>
<ul>
<li><strong>new</strong>：建立 project</li>
<li><strong>console</strong>：建立 console 類型 project</li>
<li><strong>-o</strong>：以 <code>EFCorePostgres</code> 為專案名稱並建立目錄</li>
</ul>
<p><img src="/images/efcore/migration/migration000.png" alt="post000"></p>
<h2 id="以_VS_Code_開啟">以 VS Code 開啟</h2><hr>
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="char">$ </span>cd <span class="class">EFCoreMigration</span></span><br><span class="line">~/<span class="class">EFCorrMigration</span> <span class="char">$ </span>code .</span><br></pre></td></tr></table></figure>
<p>進入專案目錄，呼叫 VS Code 開啟。</p>
<p><img src="/images/efcore/migration/migration001.png" alt="post001"></p>
<p><img src="/images/efcore/migration/migration002.png" alt="post002"></p>
<h2 id="安裝_EF_Core_Package">安裝 EF Core Package</h2><hr>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/EFCoreMigration $ dotnet add package Microsoft<span class="class">.EntityFrameworkCore</span><span class="class">.Design</span></span><br></pre></td></tr></table></figure>
<p>將來會在 CLI 執行 migration，而 <code>dotnet ef</code> 必須透過 <code>Microsoft.EntityFrameworkCore.Design</code> 才能存取 Entity 與 DbContext，所以必須另外安裝 package。</p>
<p><img src="/images/efcore/migration/migration005.png" alt="post005"></p>
<ol>
<li>輸入 <code>dotnet add package Microsoft.EntityFrameworkCore.Design</code> 安裝 package</li>
</ol>
<p><img src="/images/efcore/migration/migration003.png" alt="post003"></p>
<ol>
<li>安裝完 package 會在 <code>.csproj</code> 會增加新的 <code>&lt;PackageReference/&gt;</code></li>
</ol>
<h2 id="安裝_PostgreSQL_Database_Provider">安裝 PostgreSQL Database Provider</h2><hr>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/EFCoreMigration $ dotnet add package Npgsql<span class="class">.EntityFrameworkCore</span><span class="class">.PostgreSQL</span></span><br></pre></td></tr></table></figure>
<p>EF Core 預設提供了 MSSQL、SQLite 與 InMemory 3 個 Database Provider，其餘的 provider 則由原廠 vendor 提供。</p>
<p>其中 Npgsql 為 PostgreSQL 所提供的 EFCore Database Provider。</p>
<p><img src="/images/efcore/migration/migration006.png" alt="post006"></p>
<ol>
<li>使用 <code>dotnet add package</code> 安裝 <code>Npgsql.EntityFrameworkCore.PostgreSQL</code> package</li>
</ol>
<p><img src="/images/efcore/migration/migration004.png" alt="post004"></p>
<ol>
<li>安裝完 package 會在 <code>.csproj</code> 會增加新的 <code>&lt;PackageReference/&gt;</code></li>
</ol>
<blockquote>
<p>目前在 <code>.csproj</code> 一共會看到 <code>Microsoft.EntityFrameworkCore.Design</code> 與 <code>Npgsql.EntityFrameworkCore.PostgreSQL</code> 兩個 package</p>
</blockquote>
<h2 id="EF_Core">EF Core</h2><hr>
<p>在 EF Core，database 在 ORM 中都有相對應的物件：</p>
<ul>
<li><strong>Database</strong>：EF Core 的 <code>DbContext</code></li>
<li><strong>Table</strong>：EF Core 的 <code>Entity</code></li>
<li><strong>Column</strong>：EF Core 的 <code>Property</code></li>
</ul>
<p>我們即將在 PostgreSQL 建立 :</p>
<ul>
<li><strong>Database</strong> : <code>eflab</code></li>
</ul>
<ul>
<li><strong>Table</strong>：<code>Customers</code></li>
<li><strong>Column</strong>：<ul>
<li><code>CustomerID</code> : int (PK)</li>
<li><code>Name</code> : string</li>
</ul>
</li>
</ul>
<h2 id="Code_First">Code First</h2><hr>
<p><strong>建立 Entity</strong></p>
<p><code>Entity</code> 在 EF Core 中代表 table，我們將建立自己的 Entity。</p>
<p>其中 <code>Customer</code> entity 代表 <code>Customers</code> table。</p>
<blockquote>
<p>Entity 名稱為 <code>單數</code>，而 table 名稱為 <code>複數</code></p>
</blockquote>
<p><strong>Customer.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">EFCoreMigration</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> CustomerID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 3 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br></pre></td></tr></table></figure>
<p>Entity 為 <code>單數</code>，所以使用單數的 <code>Customer</code>。</p>
<p>第 5 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> CustomerID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>Column 以 property 呈現。</p>
<blockquote>
<p>Q : string 是否能指定長度 ?</p>
</blockquote>
<p>A : EF Core 能使用 <code>[StringLength()]</code> 指定 string 的 column 長度，我們將在稍後改變長度，目前先不指定長度，看看不指定長度下的 string，在 PostgreSQL 會如何 ?</p>
<p>第 5 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> CustomerID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>Table 的 PK，EF Core 規定要以 <code>table name</code> + <code>ID</code> 表示，則 migration 時會自動將該欄位建立成 PK，不需要額外 attribute。</p>
<p><img src="/images/efcore/migration/migration009.png" alt="migration009"></p>
<p><strong>建立 DbContext</strong></p>
<p><code>DbContext</code> 在 EF Core 中代表 database，我們將繼承 <code>DbContext</code> 建立自己的 database context。</p>
<p>其中 <code>EFLabDbContext</code> DbContext 代表 <code>eflab</code> database。</p>
<p><strong>EFLabDbContext.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">EFCoreMigration</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EFLabDbContext</span>: <span class="title">DbContext</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> DbSet&lt;Customer&gt; Customers &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> DbConnectionString = <span class="string">"Host=localhost;Port=5432;Database=eflab;Username=admin;Password=12345"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            optionsBuilder.UseNpgsql(DbConnectionString);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 5 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EFLabDbContext</span>: <span class="title">DbContext</span></span><br></pre></td></tr></table></figure>
<p>建立自己的 <code>EFLabDbContext</code>，繼承自 <code>DbContext</code>。</p>
<p>第 7 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DbSet&lt;Customer&gt; Customers &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>使用 property 宣告 table，其型別為 <code>DbSet&lt;Customer&gt;</code>，這表示其在 EF Core 為 <code>Customer</code> entity，而在 database 為 <code>Customers</code> table。</p>
<blockquote>
<p>Entity 名稱為 <code>單數</code>，而 table 名稱為 <code>複數</code></p>
</blockquote>
<p>第 8 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> DbConnectionString = <span class="string">"Host=localhost;Port=5432;Database=eflab;Username=admin;Password=12345"</span>;</span><br></pre></td></tr></table></figure>
<p>連接 database server 需要基本的資訊，統稱為 database connection string，包含以下資料：</p>
<ul>
<li><strong>Host</strong> : 設定 PostgreSQL server 的名稱</li>
<li><strong>Port</strong> : 設定 PostgreSQL 對外的 port</li>
<li><strong>Database</strong> : 設定要連接的 database</li>
<li><strong>Username</strong> : 設定 user name</li>
<li><strong>Password</strong> : 設定 password</li>
</ul>
<blockquote>
<p> 這些資訊在建立 PostgreSQL 的 <code>docker-compose.yml</code> 時，都已經在 <code>.env</code> 建立</p>
</blockquote>
<p>第 10 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    optionsBuilder.UseNpgsql(DbConnectionString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Override <code>OnConfiguring()</code> 設定 database。</p>
<p>EF Core 會傳入 <code>DbContextOptionBuider</code>，因為我們要連接的是 PostgreSQL，其 database provider 為 <code>Npgsql</code>， 所以將 connection string 傳入 <code>OptionBuilder.UseNpgsql()</code> 。</p>
<p><img src="/images/efcore/migration/migration010.png" alt="migration010"></p>
<h2 id="Migration">Migration</h2><hr>
<p>Migration 分兩個階段：</p>
<ul>
<li>建立 Migration</li>
<li>執行 Migration</li>
</ul>
<p><strong>建立 Migration</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/EFCoreMigration $ dotnet ef migrations <span class="keyword">add </span>Migration00</span><br></pre></td></tr></table></figure>
<p>輸入 <code>dotnet ef migrations add</code> 建立 Migration，其中 <code>Migration00</code> 為 Migration 名稱，請自行建立不重複的名稱。</p>
<p><img src="/images/efcore/migration/migration007.png" alt="migration007"></p>
<p><img src="/images/efcore/migration/migration011.png" alt="migration011"></p>
<ol>
<li>執行完 <code>dotnet ef migrations add Migration00</code>，會發現新增了 <code>Migrations</code> 目錄，並增加了 <code>3</code> 個檔案</li>
</ol>
<blockquote>
<p>Q : 為什麼需要這 3 個 Migration 檔案 ?</p>
</blockquote>
<p>A : 稍後在 <code>Migration 工作原理</code> 會一併並解釋。</p>
<p><strong>執行 Migration</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/<span class="type">EFCoreMigration</span> $ <span class="keyword">dotnet</span> ef database update</span><br></pre></td></tr></table></figure>
<p>輸入 <code>dotnet ef database update</code> 執行 Migration。</p>
<blockquote>
<p>EF Core 將根據剛剛在 <code>Migrations</code> 所建立的 3 個檔案，與 <code>DbContext.OnConfiguration()</code> 的設定，對 PostgreSQL 進行 Migration</p>
</blockquote>
<p><img src="/images/efcore/migration/migration008.png" alt="migration008"></p>
<ol>
<li>執行了 <code>Migration00</code></li>
</ol>
<p><strong>確認 Database</strong></p>
<p><img src="/images/efcore/migration/migration012.png" alt="migration012"></p>
<ol>
<li>展開 <code>eflab</code> database</li>
<li>EF Core 的 Migration 在 <code>eflab</code> 建立了 <code>__EFMigrationHistory</code> 與 <code>Customers</code> 兩個 table</li>
<li><code>Customers</code> 則建立 <code>CustomerID</code> 與 <code>Name</code> 兩個 column，並有 <code>PK_Customers</code></li>
</ol>
<p>注意 <code>Name</code> 的型別為 <code>text</code>，也就是在 Entity 的 <code>string</code>，預設在 PostgreSQL 為 <code>text</code>，而不是 <code>varchar</code>。</p>
<blockquote>
<p>若 Migration 沒有建立成功，請確認 Docker 與 PostgreSQL container 已經正常執行</p>
<p>Q : 為什麼會多了 <code>__EFMigrationHistory</code> table 呢 ?</p>
</blockquote>
<p>A : 稍後在 <code>Migration 工作原理</code> 會一併並解釋。</p>
<h2 id="Code_First-1">Code First</h2><hr>
<p><strong>新增 Field</strong></p>
<p>若只是單純將 Entity 建立成 table，還顯不出 Migration 的威力。</p>
<p>實務上因為需求的變動，我們會想在 table 新增 column，我們只要繼續在 Entity 新增 property 即可。</p>
<p><strong>Customer.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">EFCoreMigration</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> CustomerID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 7 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>新增 <code>Age</code> property。</p>
<p><img src="/images/efcore/migration/migration013.png" alt="migration013"></p>
<h2 id="Migration-1">Migration</h2><hr>
<p><strong>建立 Migration</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/EFCoreMigration $ dotnet ef migrations <span class="keyword">add </span>Migration01</span><br></pre></td></tr></table></figure>
<p>輸入 <code>dotnet ef migrations add</code> 建立 Migration，其中 <code>Migration01</code> 為 Migration 名稱，有別於剛剛建立的 <code>Migration00</code>。</p>
<p><img src="/images/efcore/migration/migration014.png" alt="migration007"></p>
<p><img src="/images/efcore/migration/migration017.png" alt="migration017"></p>
<ol>
<li>新增兩個 Migration 檔案</li>
</ol>
<blockquote>
<p>Q : 為什麼第二次 Migration 只新增了兩個檔案 ?</p>
</blockquote>
<p>A : 稍後在 <code>Migration 工作原理</code> 會一併並解釋。</p>
<p><strong>執行 Migration</strong><br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/<span class="type">EFCoreMigration</span> $ <span class="keyword">dotnet</span> ef database update</span><br></pre></td></tr></table></figure></p>
<p>輸入 <code>dotnet ef database update</code> 執行 Migration。</p>
<p><img src="/images/efcore/migration/migration015.png" alt="migration015"></p>
<ul>
<li>只執行了 <code>Migration01</code>，並沒有執行 <code>Migration00</code></li>
</ul>
<blockquote>
<p>Q : 為什麼 EF Core 知道只執行新的 Migration，而不是全部 Migration 重跑一次 ?</p>
</blockquote>
<p>A : 稍後在 <code>Migration 工作原理</code> 會一併並解釋。</p>
<p><strong>確認 Database</strong></p>
<p><img src="/images/efcore/migration/migration016.png" alt="migration016"></p>
<ol>
<li><code>Customers</code> 只新增了 <code>Age</code> column</li>
</ol>
<h2 id="Code_First-2">Code First</h2><hr>
<p><strong>指定 Column 長度</strong></p>
<p><strong>Customer.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.ComponentModel.DataAnnotations;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">EFCoreMigration</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> CustomerID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        [StringLength(<span class="number">20</span>)]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>實務上也常會有改變欄位長度的需求，目前我們將 <code>Name</code> 加上 <code>StringLength()</code> attribute，指定長度為 <code>20</code>。</p>
<p><img src="/images/efcore/migration/migration021.png" alt="migration021"></p>
<ol>
<li>在 <code>Name</code> 加上 <code>StringLength()</code> attribute</li>
<li>加上 <code>using System.ComponentModel.DataAnnotations;</code> namespace</li>
</ol>
<h2 id="Migration-2">Migration</h2><hr>
<p><strong>建立 Migration</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/EFCoreMigration $ dotnet ef migrations <span class="keyword">add </span>Migration02</span><br></pre></td></tr></table></figure>
<p>由於 <code>Customer</code> entity 被修改，因此必須建立新的 Migration。</p>
<p><img src="/images/efcore/migration/migration022.png" alt="migration022"></p>
<ul>
<li>由於我們是將 <code>text</code> 改成 <code>varchar(20)</code>，因此有可能會 loss 資料，EF Core 特別提出警告</li>
</ul>
<p><strong>執行 Migration</strong></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>dotnet ef database update</span><br></pre></td></tr></table></figure>
<p>輸入 <code>dotnet ef database update</code> 執行 Migration。</p>
<p><img src="/images/efcore/migration/migration023.png" alt="migration023"></p>
<ul>
<li>只執行了 <code>Migration02</code>，並沒有執行其他 Migration</li>
</ul>
<p><strong>確認 Database</strong></p>
<p><img src="/images/efcore/migration/migration024.png" alt="migration024"></p>
<ol>
<li><code>Name</code> 由 <code>text</code> 變成 <code>varchar(20)</code></li>
</ol>
<h2 id="Migration_工作原理">Migration 工作原理</h2><hr>
<p>目前 Migration 已經正常執行，Table 與 Column 也都如預期建立在 PostgreSQL，但我們累積了很多疑問：</p>
<ul>
<li>Q : 為什麼需要這 3 個 Migration 檔案 ?</li>
<li>Q : 為什麼會多了 <code>__EFMigrationHistory</code> table 呢 ?</li>
<li>Q : 為什麼第二次 Migration 只有兩個檔案 ?</li>
<li>Q : 為什麼 EF Core 知道只執行新的 Migration，而不是全部 Migration 重跑一次 ?</li>
</ul>
<p>這些都是 Migration 的黑魔法，我們必須從 EF Core 的 Migration 工作原理談起。</p>
<p><strong>建立 Migration</strong><br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet ef migrations <span class="keyword">add</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/images/efcore/migration/migration018.svg" alt="migration018"></p>
<ol>
<li>根據 <code>DbContext</code> 與 <code>Entity</code> 蒐集要建立 Migration 的資訊</li>
<li>比對 <code>ModelSnapshot.cs</code> 與 <code>DbContext</code> 與 <code>Entity</code> 的差異，決定 Migration 檔案要如何建立</li>
<li><code>MyMigrate.Designer.cs</code> 與 <code>MyMigrate.cs</code> 就是實際的 Migration 檔案</li>
<li>將新增異動的 schema 寫入 <code>ModelSnapshot.cs</code></li>
</ol>
<p><strong>ModelSnapshot.cs</strong><br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;auto-generated /&gt;</span></span><br><span class="line"><span class="keyword">using</span> EFCoreMigration;</span><br><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore;</span><br><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore.Infrastructure;</span><br><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore.Storage.ValueConversion;</span><br><span class="line"><span class="keyword">using</span> Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">EFCoreMigration.Migrations</span></span><br><span class="line">&#123;</span><br><span class="line">    [DbContext(<span class="keyword">typeof</span>(EFLabDbContext))]</span><br><span class="line">    <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">EFLabDbContextModelSnapshot</span> : <span class="title">ModelSnapshot</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildModel</span>(<span class="params">ModelBuilder modelBuilder</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> <span class="keyword">warning</span> disable 612, 618</span></span><br><span class="line">            modelBuilder</span><br><span class="line">                .HasAnnotation(<span class="string">"Npgsql:ValueGenerationStrategy"</span>, NpgsqlValueGenerationStrategy.SerialColumn)</span><br><span class="line">                .HasAnnotation(<span class="string">"ProductVersion"</span>, <span class="string">"2.1.0-rtm-30799"</span>)</span><br><span class="line">                .HasAnnotation(<span class="string">"Relational:MaxIdentifierLength"</span>, <span class="number">63</span>);</span><br><span class="line"></span><br><span class="line">            modelBuilder.Entity(<span class="string">"EFCoreMigration.Customer"</span>, b =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    b.Property&lt;<span class="keyword">int</span>&gt;(<span class="string">"CustomerID"</span>)</span><br><span class="line">                        .ValueGeneratedOnAdd();</span><br><span class="line"></span><br><span class="line">                    b.Property&lt;<span class="keyword">int</span>&gt;(<span class="string">"Age"</span>);</span><br><span class="line"></span><br><span class="line">                    b.Property&lt;<span class="keyword">string</span>&gt;(<span class="string">"Name"</span>)</span><br><span class="line">                        .HasMaxLength(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">                    b.HasKey(<span class="string">"CustomerID"</span>);</span><br><span class="line"></span><br><span class="line">                    b.ToTable(<span class="string">"Customers"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> <span class="keyword">warning</span> restore 612, 618</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>描述了 database schema 該有哪些 table 與 column。</p>
<blockquote>
<p><code>ModelSnapshot.cs</code> 可視為前一次 Migration 所產生 database schema 的 golden sample，因此可用目前的 <code>DbContext</code> 、 <code>Entity</code> 與 <code>ModelSnapshot</code> 做比對，產生新的 Migration 檔案</p>
</blockquote>
<p><strong>Migration02.Designer.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;auto-generated /&gt;</span></span><br><span class="line"><span class="keyword">using</span> EFCoreMigration;</span><br><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore;</span><br><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore.Infrastructure;</span><br><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore.Migrations;</span><br><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore.Storage.ValueConversion;</span><br><span class="line"><span class="keyword">using</span> Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">EFCoreMigration.Migrations</span></span><br><span class="line">&#123;</span><br><span class="line">    [DbContext(<span class="keyword">typeof</span>(EFLabDbContext))]</span><br><span class="line">    [Migration(<span class="string">"20180615035640_Migration03"</span>)]</span><br><span class="line">    <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Migration03</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildTargetModel</span>(<span class="params">ModelBuilder modelBuilder</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> <span class="keyword">warning</span> disable 612, 618</span></span><br><span class="line">            modelBuilder</span><br><span class="line">                .HasAnnotation(<span class="string">"Npgsql:ValueGenerationStrategy"</span>, NpgsqlValueGenerationStrategy.SerialColumn)</span><br><span class="line">                .HasAnnotation(<span class="string">"ProductVersion"</span>, <span class="string">"2.1.0-rtm-30799"</span>)</span><br><span class="line">                .HasAnnotation(<span class="string">"Relational:MaxIdentifierLength"</span>, <span class="number">63</span>);</span><br><span class="line"></span><br><span class="line">            modelBuilder.Entity(<span class="string">"EFCoreMigration.Customer"</span>, b =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    b.Property&lt;<span class="keyword">int</span>&gt;(<span class="string">"CustomerID"</span>)</span><br><span class="line">                        .ValueGeneratedOnAdd();</span><br><span class="line"></span><br><span class="line">                    b.Property&lt;<span class="keyword">int</span>&gt;(<span class="string">"Age"</span>);</span><br><span class="line"></span><br><span class="line">                    b.Property&lt;<span class="keyword">string</span>&gt;(<span class="string">"Name"</span>)</span><br><span class="line">                        .HasMaxLength(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">                    b.HasKey(<span class="string">"CustomerID"</span>);</span><br><span class="line"></span><br><span class="line">                    b.ToTable(<span class="string">"Customers"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> <span class="keyword">warning</span> restore 612, 618</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>描述了這次 Migration 建立後最終的 schema。</p>
<p><strong>Migration02.cs</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.EntityFrameworkCore.Migrations;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">EFCoreMigration.Migrations</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Migration03</span> : <span class="title">Migration</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Up</span>(<span class="params">MigrationBuilder migrationBuilder</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            migrationBuilder.AlterColumn&lt;<span class="keyword">string</span>&gt;(</span><br><span class="line">                name: <span class="string">"Name"</span>,</span><br><span class="line">                table: <span class="string">"Customers"</span>,</span><br><span class="line">                maxLength: <span class="number">20</span>,</span><br><span class="line">                nullable: <span class="keyword">true</span>,</span><br><span class="line">                oldClrType: <span class="keyword">typeof</span>(<span class="keyword">string</span>),</span><br><span class="line">                oldNullable: <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Down</span>(<span class="params">MigrationBuilder migrationBuilder</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            migrationBuilder.AlterColumn&lt;<span class="keyword">string</span>&gt;(</span><br><span class="line">                name: <span class="string">"Name"</span>,</span><br><span class="line">                table: <span class="string">"Customers"</span>,</span><br><span class="line">                nullable: <span class="keyword">true</span>,</span><br><span class="line">                oldClrType: <span class="keyword">typeof</span>(<span class="keyword">string</span>),</span><br><span class="line">                oldMaxLength: <span class="number">20</span>,</span><br><span class="line">                oldNullable: <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>描述了 <code>dotnet ef database update</code> 與 <code>dotnet ef migrations remove</code> 要執行的動作。</p>
<p>第 7 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Up</span>(<span class="params">MigrationBuilder migrationBuilder</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    migrationBuilder.AlterColumn&lt;<span class="keyword">string</span>&gt;(</span><br><span class="line">       name: <span class="string">"Name"</span>,</span><br><span class="line">       table: <span class="string">"Customers"</span>,</span><br><span class="line">       maxLength: <span class="number">20</span>,</span><br><span class="line">       nullable: <span class="keyword">true</span>,</span><br><span class="line">       oldClrType: <span class="keyword">typeof</span>(<span class="keyword">string</span>),</span><br><span class="line">       oldNullable: <span class="keyword">true</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>當執行 <code>dotnet ef datebase update</code> 時，就會執行 <code>Up()</code>，包含如何建立 schema。</p>
<p>以 <code>Migration02</code> 為例，這次 migration 的目的就是將 <code>Name</code> 的 <code>text</code> 改成 <code>varchar(20)</code>，因此在 <code>Up</code> 只看到 <code>AlterColumn&lt;T&gt;()</code>。</p>
<p>18 行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Down</span>(<span class="params">MigrationBuilder migrationBuilder</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    migrationBuilder.AlterColumn&lt;<span class="keyword">string</span>&gt;(</span><br><span class="line">        name: <span class="string">"Name"</span>,</span><br><span class="line">        table: <span class="string">"Customers"</span>,</span><br><span class="line">        nullable: <span class="keyword">true</span>,</span><br><span class="line">        oldClrType: <span class="keyword">typeof</span>(<span class="keyword">string</span>),</span><br><span class="line">        oldMaxLength: <span class="number">20</span>,</span><br><span class="line">        oldNullable: <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>當執行 <code>dotnet ef migrations remove</code> 時，就會執行 <code>Down()</code>，包含如何還原此次 Migration 所需要的動作。</p>
<p>由於 <code>Migration02</code> 主要動作就是將 <code>Name</code> 由 <code>text</code> 改成 <code>varchar(20)</code>，因此 <code>Down()</code> 就是反過來由 <code>varchar(20)</code> 改成 <code>text</code>。</p>
<blockquote>
<p>由於 <code>MyMigrate.Designer.cs</code> 與 <code>MyMigrate.cs</code> 都是 C# 檔案，因此可以進入 Git 版控，可藉由 Migration 檔案的變化，得知 database schema 變化的歷程，且若真的 Migration 錯誤，還可以透過 <code>dotnet ef migrations remove</code> 還原 Migration 所變動的 database schema</p>
<p><code>MyMigrate.Designer.cs</code> 與 <code>MyMigrate.cs</code> 雖然是由 CLI 產生，但並非不能修改，一些進階的Migration 功能，就得自行修改才能實現，如想利用 Migration 建立 Stored Procedure，就必須自行修改 <code>MyMigrate.cs</code> 的 <code>Up()</code></p>
<p>但 <code>ModelSnapshot.cs</code> 則不應該修改，應該交由 Migration 去維護，否則會發生錯亂</p>
</blockquote>
<p>這解釋了 :</p>
<ol>
<li>Q : 為什麼需要這 3 個 Migration 檔案 ?</li>
<li>Q : 為什麼第二次 Migration 只有兩個檔案 ?</li>
</ol>
<p><strong>執行 Migration</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>dotnet ef database update</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/efcore/migration/migration019.svg" alt="migration019"></p>
<ol>
<li>檢查是否有 <code>__EFMigrationHistory</code> table，若沒有，表示是第一次執行 Migration</li>
<li>若是第一次執行 Migration，會建立 <code>__EFMigrationHistory</code> table</li>
<li>若已經有 <code>__EFMigrationHistory</code>，表示已經執行過 Migration，因此在 <code>__EFMigrationHistory</code> 會有 Migration 紀錄，可查詢已經執行過哪些 Migration</li>
<li>執行尚未執行過的 Migration</li>
<li>將執行過的 Migration <code>名稱</code> 寫進 <code>__EFMigrationHistory</code></li>
</ol>
<p><img src="/images/efcore/migration/migration020.png" alt="migration020"></p>
<p><code>__EFMigrationHistory</code> 記載了執行過的 Migration 名稱。</p>
<p>透過 <code>__EFMigrationHistory</code>，<code>dotnet ef database update</code> 就知道每次該執行哪些沒執行過的 Migration，且在不同環境下，如 development / lab / stage / production，因為各自有各自的 <code>__EFMigrationHistory</code>，也能根據不同環境執行不同的 Migration。</p>
<p>這解釋了  : </p>
<ol>
<li>Q : 為什麼會多了 __EFMigrationHistory table 呢 ?</li>
<li>Q : 為什麼 EF Core 知道只執行新的 Migration，而不是全部 Migration 重跑一次 ?</li>
</ol>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>Code First 與 Migration 解決了 database schema 無法 Git 版控與 schema 同步問題，且完全使用開發端技術，而不是資料庫端技術 </li>
<li>Migration 另外一個優點就是用在 <code>整合測試</code>，當配合 Docker 時，每個測試案例在執行前先 <code>docker-compose up</code> 建立 PostgreSQL container，接著跑 Migration 建立 schema，然後跑整合測試讀寫 PostgreSQL， 測試完畢後再 <code>docker-compose down</code> 刪除 PostgreSQL container，所有在 PostgreSQL 的測試資料也跟著刪除，下一個測試案例再重新 <code>docker-compose up</code> 建立新的 container，重新跑 Migration …，如此能確保每個整合測試都是全新乾淨的 database，完全沒有任何 side effect</li>
<li>因為不了解 Migration，所以很多人在實務上不敢用 Migration，事實上對於新的技術，只要能充分了解其背後原理與機制，就不再是黑魔法了</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 <a href="https://github.com/oomusou/EFCoreMigration" target="_blank" rel="external">GitHub</a> 上找到</p>
<h2 id="Reference">Reference</h2><hr>
<p><a href="http://www.npgsql.org/doc/index.html" target="_blank" rel="external">Npgsql</a>, <a href="http://www.npgsql.org/efcore/index.html" target="_blank" rel="external">Entity Framework Core</a><br>John P Smith, <a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="external">Entity Framework Core in Action</a></p>
]]></content>
    <summary type="html">
    <![CDATA[了解 Migration 的黑魔法]]>
    
    </summary>
    
      <category term="EF Core" scheme="https://oomusou.io/tags/EF-Core/"/>
    
      <category term="PostgreSQL" scheme="https://oomusou.io/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rider Refactoring 之 Extract Higher Order Function]]></title>
    <link href="https://oomusou.io/rider/extract-higher-order-function/"/>
    <id>https://oomusou.io/rider/extract-higher-order-function/</id>
    <published>2018-06-12T12:23:43.000Z</published>
    <updated>2018-06-11T16:34:23.071Z</updated>
    <content type="html"><![CDATA[<p>Higher Order Function 是 JavaScript 或 FP 語言常見的語言機制，事實上 C# 也支援某種程度的 FP，如 Func、 Predicate 與 Action。</p>
<p>透過 Rider，我們也能將既有 method 重構出具 FP 風格的 Higher Order Function。</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.4<br>.NET Core 2.1<br>Rider 2018.1.2</p>
<h2 id="Func">Func</h2><hr>
<h3 id="重構前">重構前</h3><p><strong>OrderService.cs</strong></p>
<p><img src="/images/rider/extract-higher-order-function/hof000.png" alt="hof000"></p>
<p><code>price</code> 實務上會從 repository 而來，為了簡化起見，暫時 hardcore <code>price</code> 為 <code>100</code>。</p>
<p>因為 <code>全館八折</code>，所以 <code>price</code> 一律打八折。</p>
<p><strong>Program.cs</strong></p>
<p><img src="/images/rider/extract-higher-order-function/hof001.png" alt="hof001"></p>
<p>Client 呼叫 <code>OrderService.CalculatePrice()</code>。</p>
<h3 id="重構後">重構後</h3><p><strong>OrderService.cs</strong></p>
<p><img src="/images/rider/extract-higher-order-function/hof002.png" alt="hof002"></p>
<p>目前 <code>全館八折</code> 的 <code>price * 0.8</code> 是寫死的，但考量折扣的算法常常會變，寫死並不是一個好方法，因此想將 <code>price * 0.8</code> 整個 expression 抽成 parameter。</p>
<ol>
<li>選擇 <code>price * 0.8</code></li>
<li>熱鍵 <code>⌃ + T</code> ，呼叫出 <code>Refactor This</code></li>
<li>選擇 <code>Introduce Parameter</code></li>
</ol>
<p><img src="/images/rider/extract-higher-order-function/hof003.png" alt="hof003"></p>
<ol>
<li>將下方的 <code>Select parameters to enlambda</code> 的 parameter 打勾，parameter 型別將為 <code>Func&lt;double, double&gt;</code></li>
<li>輸入 parameter 名稱為 <code>discountStrategy</code></li>
</ol>
<p><img src="/images/rider/extract-higher-order-function/hof004.png" alt="hof004"></p>
<ol>
<li>原來的 <code>price * 0.8</code> 重構成 <code>discountStrtegy(price)</code></li>
<li><code>discountStrategy</code> parameter 型別為 <code>Func&lt;double, double&gt;</code></li>
</ol>
<p><strong>Program.cs</strong></p>
<p><img src="/images/rider/extract-higher-order-function/hof005.png" alt="hof005"></p>
<ol>
<li>原來的 <code>price * 0.8</code> 重構成 <code>price =&gt; price * 0.8</code> 以 Lambda 形式傳入</li>
</ol>
<blockquote>
<p>Q : 這樣重構有什麼好處呢 ?</p>
<p>若將來折扣規則改成 <code>全館折價 100</code>，只要傳入 <code>price =&gt; price - 100</code> 即可，<code>OrderService</code> 完全不用修改，符合 <code>開放封閉原則</code> 要求</p>
</blockquote>
<h2 id="Predicate">Predicate</h2><hr>
<h3 id="重構前-1">重構前</h3><p><strong>OrderService.cs</strong></p>
<p><img src="/images/rider/extract-higher-order-function/hof006.png" alt="hof006"></p>
<p><code>price</code> 實務上會從 repository 而來，為了簡化起見，暫時 hardcore <code>price</code> 為 <code>100</code>。</p>
<p>因為 <code>滿千送百</code>，所以 <code>price</code> 超過 <code>1000.0</code> 會自動折價 <code>100.0</code>。</p>
<p><strong>Program.cs</strong></p>
<p><img src="/images/rider/extract-higher-order-function/hof007.png" alt="hof007"></p>
<p>Client 呼叫 <code>OrderService.CalculatePrice()</code>。</p>
<h3 id="重構後-1">重構後</h3><p><strong>OrderService.cs</strong></p>
<p><img src="/images/rider/extract-higher-order-function/hof008.png" alt="hof008"></p>
<p>目前 <code>滿千送百</code> 的 <code>price &gt; 1000.0</code> 是寫死的，但考量折扣的算法常常會變，寫死並不是一個好方法，因此想將 <code>price &gt; 1000.0</code> 整個 expression 抽成 parameter。</p>
<ol>
<li>選擇 <code>price &gt; 1000.0</code></li>
<li>熱鍵 <code>⌃ + T</code> ，呼叫出 <code>Refactor This</code></li>
<li>選擇 <code>Introduce Parameter</code></li>
</ol>
<p><img src="/images/rider/extract-higher-order-function/hof011.png" alt="hof011"></p>
<ol>
<li>將下方的 <code>Select parameters to enlambda</code> 的 parameter 打勾，parameter 型別將為 <code>Func&lt;double, bool&gt;</code></li>
<li>輸入 parameter 名稱為 <code>discountPredicate</code></li>
</ol>
<p><img src="/images/rider/extract-higher-order-function/hof009.png" alt="hof009"></p>
<ol>
<li>原來的 <code>price &gt; 1000.0</code> 重構成 <code>discountPredicate(price)</code></li>
<li><code>discountStrategy</code> parameter 型別為 <code>Func&lt;double, bool&gt;</code></li>
</ol>
<blockquote>
<p>理想上當然是抽成 <code>Predicate&lt;double&gt;</code>，但目前 Rider 只能抽成 <code>Func&lt;double, bool&gt;</code>，但因為兩個型別等價，所以不滿意但可以接受</p>
</blockquote>
<p><img src="/images/rider/extract-higher-order-function/hof010.png" alt="hof010"></p>
<ol>
<li>原來的 <code>price &gt; 1000.0</code> 重構成 <code>price =&gt; price &gt; 1000.0</code> 以 Lambda 形式傳入</li>
</ol>
<blockquote>
<p>Q : 這樣重構有什麼好處呢 ?</p>
<p>若將來折扣規則改成 <code>只有 1000 ~ 2000 之間有折扣</code>，只要傳入 <code>price =&gt; price &gt; 1000.0 &amp;&amp; price &lt; 2000.0</code> 即可，<code>OrderService</code> 完全不用修改，符合 <code>開放封閉原則</code> 要求</p>
</blockquote>
<h2 id="Action">Action</h2><hr>
<h3 id="重構前-2">重構前</h3><p><strong>OrderService.cs</strong></p>
<p><img src="/images/rider/extract-higher-order-function/hof012.png" alt="hof012"></p>
<p><code>price</code> 實務上會從 repository 而來，為了簡化起見，暫時 hardcore <code>price</code> 為 <code>2000</code>。</p>
<p>因為過年活動 <code>全館折價 100</code>，所以 <code>price - 100</code> 。</p>
<p>因為過年，所以特別顯示 <code>Happy New Year!!</code>。</p>
<p><strong>Program.cs</strong></p>
<p><img src="/images/rider/extract-higher-order-function/hof013.png" alt="hof013"></p>
<p>Client 呼叫 <code>OrderService.CalculatePrice()</code>。</p>
<h3 id="重構後-2">重構後</h3><p><strong>OrderService.cs</strong></p>
<p><img src="/images/rider/extract-higher-order-function/hof014.png" alt="hof014"></p>
<p>目前 <code>Happy New Year!!</code> 是寫死的，但考量不同節慶顯示不同訊息，甚至不同顯示方式 (呼叫其他 service ?)，寫死並不是一個好方法，因此想將 <code>Console.WriteLine(&#39;Happy New Year!!&#39;)</code> 整個 statement 抽成 parameter。</p>
<ol>
<li>選擇 <code>Console.WriteLine(&#39;Happy New Year!!&#39;)</code></li>
<li>熱鍵 <code>⌃ + T</code> ，呼叫出 <code>Refactor This</code></li>
<li>目前並無  <code>Introduce Parameter</code> 可選，只剩下 <code>Extract Method</code> 與 <code>Introduce Variable</code>，試試看先 <code>Introduce Variable</code> 後再 <code>Introduce Parameter</code></li>
</ol>
<p><img src="/images/rider/extract-higher-order-function/hof015.png" alt="hof015"></p>
<ol>
<li>若選擇 <code>Introduce Variable</code>，則顯示 <code>Expression type is void</code> ，無法繼續重構</li>
</ol>
<p><img src="/images/rider/extract-higher-order-function/hof016.png" alt="hof016"></p>
<ol>
<li>這裡必須自己寫 code，先自行宣告 <code>Action</code> 型別變數，將 <code>Console.WriteLine(&#39;Happy New Year!!&#39;)</code> 包在 Lambda 內，最後再用 <code>Action.Invoke()</code> 執行 <code>action</code></li>
</ol>
<p><img src="/images/rider/extract-higher-order-function/hof017.png" alt="hof017"></p>
<ol>
<li>選擇 <code>action</code> 變數</li>
<li>熱鍵 <code>⌃ + T</code> ，呼叫出 <code>Refactor This</code>，選擇 <code>Introduce Parameter</code></li>
</ol>
<p><img src="/images/rider/extract-higher-order-function/hof019.png" alt="hof019"></p>
<ol>
<li>已經抓出 parameter 型別為 <code>Action</code></li>
<li>輸入 parameter 名稱</li>
</ol>
<p><img src="/images/rider/extract-higher-order-function/hof020.png" alt="hof020"></p>
<ol>
<li>原來的 <code>Action action = () =&gt; { Console.WriteLine(&quot;Happy New Year!!&quot;); };</code> 重構成 <code>action</code> parameter</li>
<li><code>action</code> parameter 型別為 <code>Action</code></li>
</ol>
<p><img src="/images/rider/extract-higher-order-function/hof021.png" alt="hof021"></p>
<ol>
<li>原來的 <code>Action action = () =&gt; { Console.WriteLine(&quot;Happy New Year!!&quot;); };</code> 重構成 <code>() =&gt; { Console.WriteLine(&quot;Happy New Year!!&quot;); }</code> 以 Lambda 形式傳入</li>
</ol>
<blockquote>
<p>Q : 這樣重構有什麼好處呢 ?</p>
<p>若將來顯示訊息改變，甚至呼叫其他 service 顯示，只要傳入 <code>（）=&gt; {}</code> 即可，<code>OrderService</code> 完全不用修改，符合 <code>開放封閉原則</code> 要求</p>
</blockquote>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>隨著 C# 支援 FP 越來越完整，Extract Higher Order Function 的需求會越來越多，而 Extract Method 卻無法抽出 Higher Order Function，必須靠 Introduce Parameter，才能抽出 Func、Predicate 與 Action</li>
<li>目前 Rider 無法直接抽出 Predicate，所幸 Predicate 也都可以用 Func 表示，雖不滿意但尚可接受</li>
<li>目前 Rider 無法直接抽出 Action，必須搭配一些小技巧，才能順利抽出 Action</li>
</ul>
<h2 id="Sample_Code">Sample Code</h2><hr>
<p>完整的範例可以在我的 GitHub 上找到</p>
<ul>
<li><a href="https://github.com/oomusou/RiderExtractFunc" target="_blank" rel="external">Extract Func</a></li>
<li><a href="https://github.com/oomusou/RiderExtractPredicate" target="_blank" rel="external">Extract Predicate</a></li>
<li><a href="https://github.com/oomusou/RiderExtractAction" target="_blank" rel="external">Extract Action</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[C# 也能輕鬆抽出 Higher Order Function]]>
    
    </summary>
    
      <category term="Refactoring" scheme="https://oomusou.io/tags/Refactoring/"/>
    
      <category term="Rider" scheme="https://oomusou.io/tags/Rider/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在 CLI 呼叫 Typora 開啟 Markdown ?]]></title>
    <link href="https://oomusou.io/typora/typora-cli/"/>
    <id>https://oomusou.io/typora/typora-cli/</id>
    <published>2018-06-07T13:23:43.000Z</published>
    <updated>2018-06-07T14:54:45.727Z</updated>
    <content type="html"><![CDATA[<p>隨著 CLI 的流行，在 CLI 下以 <code>code .</code> 開啟 VS Code 非常方便，對於常用的 Markdown 檔案，是否也能在 CLI 以 <code>typora .</code> 開啟 Typora 呢 ?</p>
<a id="more"></a>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.4<br>zsh 5.3<br>Typora 0.9.9.16.2</p>
<h2 id="設定_Alias">設定 Alias</h2><hr>
<p><strong>.zshrc</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> typora=<span class="string">"open -a typora"</span></span><br></pre></td></tr></table></figure>
<p>只要在你的 <code>.zshrc</code> 加上這個 alias，就可以在任何目錄</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>typora .</span><br></pre></td></tr></table></figure>
<p>以 Typora 開啟目前目錄</p>
<p>或</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ typora foo.<span class="built_in">md</span></span><br></pre></td></tr></table></figure>
<p>直接以 Typora 開啟某個檔案。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>Typora 是非常好用的 Markdown 編輯器，有別於傳統左右視窗的 Markdown 編輯器，Typora 是 WYSISWYG，除了直接使用 Markdown 語法外，也可以搭配熱鍵，還支援自動 outline 功能</li>
<li>透過簡單的 alias，就可以使用 CLI 方式開啟 Typora 了</li>
</ul>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://typora.io" target="_blank" rel="external">Typora</a>, <a href="https://support.typora.io/Use-Typora-From-Shell-or-cmd/" target="_blank" rel="external">Use Typora from shell or Cmd</a></p>
]]></content>
    <summary type="html">
    <![CDATA[完全在 CLI 開啟 Typora]]>
    
    </summary>
    
      <category term="CLI" scheme="https://oomusou.io/tags/CLI/"/>
    
      <category term="Typora" scheme="https://oomusou.io/tags/Typora/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何架設企業內部的 NuGet Server ?]]></title>
    <link href="https://oomusou.io/netcore/nuget/nuget-server/"/>
    <id>https://oomusou.io/netcore/nuget/nuget-server/</id>
    <published>2018-06-07T12:23:43.000Z</published>
    <updated>2018-06-07T10:09:01.388Z</updated>
    <content type="html"><![CDATA[<p>.NET Core 目前仍延續 .NET Framework 使用 NuGet 為 package，除了使用公用的 NuGet server 外，企業也需要自己內部使用 NuGet server。</p>
<p>NuGet Foundation 提供了 <code>NuGet.Server</code> 免費使用，但目前只有 .NET Framework 版本，因此還是只能安裝在 Windows Server 上。<br><a id="more"></a></p>
<h2 id="Version">Version</h2><hr>
<p>macOS High Sierra 10.13.4<br>Parallel Desktop 13 for Mac Pro Edition 13.3.1 (43365)<br>Windows 10 Pro 1803 17134.81<br>Visual Studio Enterprise 2017 15.7.3<br>NuGet.Server 3.1.2<br>.NET Framework 4.6.1<br>.NET Core 2.1</p>
<h2 id="建立_NuGet_Server">建立 NuGet Server</h2><hr>
<p>NuGet.Server 已經被封裝的 NuGet package，只要建立 ASP.NET MVC Application，並且加入 <code>NuGet.Server</code> package，不用寫任何一行 code，編譯後就是可用的 NuGet server。</p>
<h2 id="建立_ASP-NET_Web_Application">建立 ASP.NET Web Application</h2><hr>
<p><img src="/images/netcore/nuget/nuget-server/nuget000.png" alt="nuget000"></p>
<ol>
<li>選擇 <code>Web</code></li>
<li>選擇 <code>ASP.NET Web Application</code> (不是 ASP.NET Core)</li>
<li><strong>Name</strong>：輸入 project 名稱</li>
<li><strong>Framework</strong>：注意是 <code>.NET Framework 4.6</code>，不是 .NET Core</li>
<li>按 <code>OK</code> 繼續</li>
</ol>
<p><img src="/images/netcore/nuget/nuget-server/nuget001.png" alt="nuget001"></p>
<ol>
<li>選擇 <code>Empty</code> ，其餘什麼都不用勾選</li>
<li>按 <code>OK</code> 繼續</li>
</ol>
<h2 id="安裝_NuGet-Server_Package">安裝 NuGet.Server Package</h2><hr>
<p><img src="/images/netcore/nuget/nuget-server/nuget002.png" alt="nuget002"></p>
<p><strong><em>Tools -&gt; NuGet Package Manager -&gt; Manage NuGet Package for Solution</em></strong></p>
<p><img src="/images/netcore/nuget/nuget-server/nuget003.png" alt="nuget003"></p>
<ol>
<li>輸入 <code>NuGet.Server</code></li>
<li>選擇 <code>NuGet.Server</code></li>
<li>勾選 <code>NuGetServer</code> project</li>
<li>按 <code>Install</code> 開始安裝 package</li>
</ol>
<p><img src="/images/netcore/nuget/nuget-server/nuget004.png" alt="nuget004"></p>
<ol>
<li>按 <code>OK</code> 繼續</li>
</ol>
<p><img src="/images/netcore/nuget/nuget-server/nuget005.png" alt="nuget005"></p>
<ol>
<li>按 <code>I Accept</code> 繼續</li>
</ol>
<p><img src="/images/netcore/nuget/nuget-server/nuget006.png" alt="nuget006"></p>
<ol>
<li><code>NuGet.Server</code> package 安裝完成</li>
</ol>
<h2 id="編輯_Web-config">編輯 Web.config</h2><hr>
<p><img src="/images/netcore/nuget/nuget-server/nuget007.png" alt="nuget007"></p>
<ol>
<li>將 18 行的 <code>&lt;compilation debug=&quot;true&quot; targetFramework=&quot;4.6&quot; /&gt;</code> 刪除，這算是 bug，重複兩個相同的 <code>targetFramework</code> 會無法執行</li>
</ol>
<h2 id="設定_API_Key">設定 API Key</h2><hr>
<p><img src="/images/netcore/nuget/nuget-server/nuget009.png" alt="nuget009"></p>
<ol>
<li>當使用 <code>dotnet nuget push</code> 上傳時，會需要指定 API Key，可在 <code>Web.config</code> 內設定。</li>
</ol>
<h2 id="測試_NuGet_Server">測試 NuGet Server</h2><hr>
<p><img src="/images/netcore/nuget/nuget-server/nuget008.png" alt="nuget008"></p>
<ol>
<li>按熱鍵 <code>Alt + Shift + R</code> Start Without Debug，此時會啟動 IIS Express 執行</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dotnet nuget push MyClassLib<span class="number">.1</span><span class="number">.0</span><span class="number">.0</span>.nupkg -k <span class="number">12345</span> -s http:<span class="comment">//localhost:49771/nuget</span></span><br></pre></td></tr></table></figure>
<p>使用 .NET Core CLI 的 <code>dotnet nuget push</code> 將 <code>.nupkg</code> 上傳到 NuGet server。</p>
<ul>
<li><strong>-k</strong> : 指定 API Key</li>
<li><strong>-s</strong> : 指定 NuGet server 網址</li>
</ul>
<p><img src="/images/netcore/nuget/nuget-server/nuget010.png" alt="nuget010"></p>
<p>目前為止，<code>NuGet.Server</code> 已經正常啟動，也可接受 <code>dotnet nuget push</code> 將 <code>.nupkg</code> 上傳到 NuGet server，但 IIS Express 會動態選擇 port，只適合開發測試用，最後還是得將 NuGet.Server 安裝到 IIS 上。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li>目前 NuGet.Server 還沒有 .NET Core 版本，這也意味著若使用 NuGet.Server，只能搭配 .NET Framework，也就是只能用於 Windows Server，還無法跨平台裝在 Linux 上</li>
</ul>
<h2 id="Reference">Reference</h2><hr>
<p><a href="https://poychang.github.io" target="_blank" rel="external">Poy Chang</a>, <a href="https://poychang.github.io" target="_blank" rel="external">架設私有的 NuGet 伺服器</a></p>
]]></content>
    <summary type="html">
    <![CDATA[可惜目前只有 .NET Framework 版本]]>
    
    </summary>
    
      <category term=".NET Core" scheme="https://oomusou.io/tags/NET-Core/"/>
    
      <category term=".NET Framework" scheme="https://oomusou.io/tags/NET-Framework/"/>
    
      <category term="NuGet" scheme="https://oomusou.io/tags/NuGet/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入淺出 Dockerfile 與 Docker Compose]]></title>
    <link href="https://oomusou.io/docker/dockerfile-dockercompose/"/>
    <id>https://oomusou.io/docker/dockerfile-dockercompose/</id>
    <published>2018-06-05T12:23:43.000Z</published>
    <updated>2018-06-08T05:19:26.198Z</updated>
    <content type="html"><![CDATA[<p>Dockerfile 與 Docker Compose 是 Docker 兩個最重要的概念，也是初學者最容易卡關的地方，本文以 <code>使用需求</code> 為觀點解釋這兩者的差異。</p>
<a id="more"></a>
<h2 id="Image_與_Container">Image 與 Container</h2><hr>
<p>在解釋 Dockerfile 與 Docker Compose 之前，先複習兩個更基礎的概念：</p>
<h3 id="Image">Image</h3><hr>
<p>將 Service 打包成 image，通常會從 Docker Hub 下載官方的 image 使用，也可以根據官方的 image 再包成自己的 image，或者完全自行製作自己的 image。</p>
<h3 id="Container">Container</h3><hr>
<p>Image 類似 template，基於壓好的 image 產生隔離的執行環境，稱之為 container。</p>
<p>一般會以 Microservice 方式使用 container，也就是會同時啟動多個 container 形成 service。</p>
<blockquote>
<p>Image 與 container 都會佔硬碟空間，尤其 container 若執行完畢後，雖然 container 從記憶體釋放，但在硬碟仍然會留一份 container 的 <code>屍體</code> ，需要自行刪除，或者在 <code>docker run</code> 時增加 <code>--rm</code> 參數，在執行完自行從硬碟刪除 container</p>
</blockquote>
<h2 id="Dockerfile">Dockerfile</h2><hr>
<p>實務上我們會從 Docker Hub 下載官方的 Docker Image 使用，但官方的 image 功能可能過於陽春，我們可能想根據自己的需求，再安裝其他的 app，最後再打包成自己的 Docker image。</p>
<p>在傳統 VM 時代，要打造自己的 image，必須用 export 方式，但這樣有幾個缺點：</p>
<ul>
<li>Image 可能非常龐大</li>
<li>安裝步驟無法進 git 版控</li>
</ul>
<p>Docker 以 <code>Infrastructure as Code</code> 概念，將  infrastructure 以 code 形式描述：</p>
<p><strong>Dockerfile</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FROM</span> ubuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install Linux library dependency</span></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash">apt-get update</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y wget apt-transport-https gpg</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># Install microsoft.gpg</span></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash">wget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; microsoft.asc.gpg</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">mv microsoft.asc.gpg /etc/apt/trusted.gpg.d/</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">wget -q https://packages.microsoft.com/config/ubuntu/<span class="number">18.04</span>/prod.list</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">mv prod.list /etc/apt/sources.list.d/microsoft-prod.list</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">chown root:root /etc/apt/trusted.gpg.d/microsoft.asc.gpg</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">chown root:root /etc/apt/sources.list.d/microsoft-prod.list</span><br><span class="line"></span></span><br><span class="line"><span class="comment"># Install .NET Core SDK</span></span><br><span class="line"><span class="built_in">RUN</span> <span class="bash">apt-get update</span><br><span class="line"></span><span class="built_in">RUN</span> <span class="bash">apt-get install -y dotnet-sdk-<span class="number">2.1</span></span><br><span class="line"></span></span><br><span class="line"><span class="comment"># Display Greeting</span></span><br><span class="line"><span class="built_in">CMD</span> <span class="bash">[ <span class="string">"echo"</span>, <span class="string">"Ubuntu 18.04 LTS with .NET Core 2.1"</span>]</span></span><br></pre></td></tr></table></figure>
<p>以上為典型的 <code>Dockerfile</code>，只需一個文字檔，就清楚描述一個 Docker image。</p>
<p>以前若要在 Ubuntu 安裝其他 dependency，只能透過 Bash 安裝一堆 package，最後再 export 成 image，但 image 可能很龐大，且安裝步驟也無法 git 版控。</p>
<p>但透過 Dockerfile 之後，整個新的 Ubuntu 都是以 code 形式描述，你只要將 <code>Dockerfile</code> 給其他人，對方只要使用 <code>docker build</code> 就能自行根據 <code>Dockerfile</code> 建立 Docker image，最後再根據 <code>docker run</code> 執行客製化過的 Ubuntu container。</p>
<ul>
<li><code>Dockerfile</code> 檔案很小，只是文字檔而已</li>
<li>由於 <code>Dockerfile</code> 是文字檔，可以 git 版控</li>
</ul>
<blockquote>
<p>簡單的說，<code>Dockerfile 就是描述如何產生客製化的 image</code>，只是採用 code 形式描述</p>
</blockquote>
<h2 id="Docker_Compose">Docker Compose</h2><hr>
<p>實務上一個服務，一定由眾多 service 共同運作。如一個典型的 Web 服務，最少就必須有</p>
<blockquote>
<p>.NET Core Runtime + Nginx + Redis + PosgreSQL</p>
</blockquote>
<p>4 個 service 一起運行，若只使用 <code>docker run</code>，則勢必寫 Bash 來管理 4 個 service，還必須考慮：</p>
<ul>
<li>4 個 service 必須在同一個虛擬 network 下</li>
<li>4 個 service 的啟動順序</li>
</ul>
<p>… 等問題。</p>
<p>Docker 為此提出 Docker Compose 概念，在 <code>docker-compose.yml</code> 檔描述各 service 間的參數與關係：</p>
<p><strong>docker-compose.yml</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version: &#34;3&#34;&#10;&#10;services:&#10;  netcore:&#10;    image: microsoft/dotnet&#10;    container_name: MyNETCore&#10;    volumes:&#10;      - $&#123;NETCORE_HOST_DIR&#125;:/code/&#10;    tty: true&#10;    networks: &#10;      - netcore-dev&#10;    depends_on:&#10;      - postgres&#10;&#10;  postgres:&#10;    image: postgres&#10;    container_name: MyPostgres&#10;    volumes:&#10;      - $&#123;POSTGRES_HOST_DIR&#125;/data:/var/lib/postgresql/data&#10;    expose:&#10;      - &#34;5432&#34;&#10;    ports:&#10;      - &#34;$&#123;POSTGRES_PORT&#125;:5432&#34;&#10;    environment:&#10;      - POSTGRES_DB=$&#123;POSTGRES_DB&#125;&#10;      - POSTGRES_USER=$&#123;POSTGRES_USER&#125;&#10;      - POSTGRES_PASSWORD=$&#123;POSTGRES_PASSWORD&#125;&#10;    networks:&#10;      - netcore-dev&#10;&#10;networks:&#10;  netcore-dev:</span><br></pre></td></tr></table></figure>
<p>以上為典型的 <code>docker-compose.yml</code>，只需一個文字檔，就清楚描述 .NET Core Runtime 與 PostgreSQL 兩個 service，將 <code>docker-compose.yml</code> 拿到任何裝有 Docker 的電腦，都成重現 .NET Core + PostreSQL 的環境，也就是 <code>Infrastructure as Code</code>。</p>
<ul>
<li><code>docker-compose.yml</code> 檔案很小，只是文字檔而已</li>
<li>由於 <code>docker-compose.yml</code> 是文字檔，可以 git 版控</li>
</ul>
<blockquote>
<p>間單的說，<code>docker-compose.yml 就是 container 的管理文件</code>，只是採用 code 形式描述</p>
</blockquote>
<h2 id="FAQ">FAQ</h2><hr>
<blockquote>
<p>Q：<code>Dockerfile</code> 與 <code>docker-compose.yml</code> 看起來很像，都是在描述 server，有什麼差別呢 ?</p>
</blockquote>
<ul>
<li><code>Dockerfile</code> 是用來描述 image，也就是如何產生客製化的 image，通常用來安裝 package，將檔案複製進 image 用</li>
<li><code>docker-compose.yml</code> 是用來描述 container，也就是管理一個以上的 container，彼此串連，把同一組架構寫在一起，通常用來設定 container 參數，設定 container 的網路，設定 container 啟動順序或 service 的環境變數 … 等</li>
</ul>
<blockquote>
<p>Q：<code>Dockerfile</code> 是用來描述 image，<code>docker-compose.yml</code> 是用來描述 container，但若我們還有客製化的 <code>邏輯</code> 該怎麼辦 ?</p>
</blockquote>
<p>若在使用 <code>Dockerfile</code> 或 <code>docker-compose.yml</code> 時，還必須搭配額外的 <code>if else</code> 或 <code>for loop</code> 邏輯，就必須再搭配 Bash。</p>
<p><code>Dockerfile</code> 與 <code>docker-composer.yml</code> 只是設計用來描述 <code>infrastructure</code>，並不是描述 <code>邏輯</code>。</p>
<blockquote>
<p>Q：單一 service 也適用 <code>docker-compose.yml</code> 嗎 ?</p>
</blockquote>
<p>由於實務上，儘管是單一 service，如只為了使用 PostgreSQL，也必須在 <code>docker run</code> 搭配一堆參數，但人的腦容量有限，很難記住所有的參數，與其寫在 Bash，建議寫在 <code>docker-compose.yml</code> ，統一由 <code>docker-compose</code> 管理。</p>
<h2 id="Conclusion">Conclusion</h2><hr>
<ul>
<li><code>Dockerfile</code> 用來描述 image；而 <code>docker-compose.yml</code> 用來描述 container</li>
<li>若 <code>Dockerfile</code> 與 <code>docker-compose.yml</code> 還無法達到客製化的需求，就必須搭配 Bash</li>
<li><code>Dockerfile</code> 與 <code>docker-compose.yml</code> 都是文字檔，因此檔案很小，也容易 git 版控，實現 <code>Infrastructur as Code</code> 理想。</li>
<li>儘管只有一個 container，也建議使用 <code>docker-compose.yml</code></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[兩個初學者最容易卡關的概念]]>
    
    </summary>
    
      <category term="Docker" scheme="https://oomusou.io/tags/Docker/"/>
    
  </entry>
  
</feed>
